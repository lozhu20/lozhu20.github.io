<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🐷&#39;s 部落格</title>
  
  
  <link href="https://zhu.happy365.day/atom.xml" rel="self"/>
  
  <link href="https://zhu.happy365.day/"/>
  <updated>2025-11-02T01:35:33.188Z</updated>
  <id>https://zhu.happy365.day/</id>
  
  <author>
    <name>zhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode58-最后一个单词的长度</title>
    <link href="https://zhu.happy365.day/2025/11/02/1944a433fb0f/"/>
    <id>https://zhu.happy365.day/2025/11/02/1944a433fb0f/</id>
    <published>2025-11-01T16:30:00.000Z</published>
    <updated>2025-11-02T01:35:33.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。<br><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p><strong>示例 1：</strong><br>输入：s &#x3D; “Hello World”<br>输出：5<br>解释：最后一个单词是“World”，长度为 5。</p><p><strong>示例 2：</strong><br>输入：s &#x3D; “   fly me   to   the moon  “<br>输出：4<br>解释：最后一个单词是“moon”，长度为 4。</p><p><strong>示例 3：</strong><br>输入：s &#x3D; “luffy is still joyboy”<br>输出：6<br>解释：最后一个单词是长度为 6 的“joyboy”。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 中至少存在一个单词</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>用一个变量记录单词的长度，遍历整个字符串，对每个字符有以下情况：</p><ul><li>当前字符是空白字符<ul><li>什么也不做</li></ul></li><li>当前字符不是空白字符<ul><li>如果前一个字符是空白字符<ul><li>将记录的单词长度重置为 1</li></ul></li><li>如果前一个字符不是空白字符<ul><li>将长度加 1</li></ul></li></ul></li></ul><p>代码如下：</p><pre><code class="python">class Solution:    def lengthOfLastWord(self, s: str) -&gt; int:        length = 0        for i in range(len(s)):            char = s[i]            if char != &quot; &quot;:                preChar = s[i - 1] if i &gt; 1 else 0                if preChar == &quot; &quot;:                    length = 1                else:                    length += 1        return length</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 &lt;strong&gt;最后</summary>
      
    
    
    
    <category term="解题记录" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="LeetCode" scheme="https://zhu.happy365.day/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode20-有效的括号</title>
    <link href="https://zhu.happy365.day/2025/11/01/3d6e49f8f384/"/>
    <id>https://zhu.happy365.day/2025/11/01/3d6e49f8f384/</id>
    <published>2025-10-31T16:35:00.000Z</published>
    <updated>2025-11-02T01:35:33.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。<br>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong><br>输入：s &#x3D; “()”<br>输出：true</p><p><strong>示例 2：</strong><br>输入：s &#x3D; “()[]{}”<br>输出：true</p><p><strong>示例 3：</strong><br>输入：s &#x3D; “(]”<br>输出：false</p><p><strong>示例 4：</strong><br>输入：s &#x3D; “([])”<br>输出：true</p><p><strong>示例 5：</strong><br>输入：s &#x3D; “([)]”<br>输出：false</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>相比大家在学习数据结构中的栈时，都学过怎么利用栈来对逆波兰表达式求解了。遇到左侧括号先入栈，遇到右侧括号则弹出栈顶元素，判断是否匹配。如果匹配消去，如果不匹配直接返回匹配失败，最后再看栈中的元素是否清空，没有的话就表示不完全匹配。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Java 代码实现如下：</p><pre><code class="java">class Solution20 &#123;    public boolean isValid(String s) &#123;        Map&lt;Character, Character&gt; map = Map.of(&#39;(&#39;, &#39;)&#39;, &#39;[&#39;, &#39;]&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;);        char[] charArray = s.toCharArray();        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (char c : charArray) &#123;            if (map.containsKey(c)) &#123;                stack.push(c);            &#125; else if (map.containsValue(c)) &#123;                if (stack.isEmpty()) &#123;                    return false;                &#125;                Character pop = stack.peek();                if (c != map.get(pop)) &#123;                    return false;                &#125;            &#125;        &#125;        return stack.isEmpty();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;cod</summary>
      
    
    
    
    <category term="解题记录" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="LeetCode" scheme="https://zhu.happy365.day/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode2-两数相加</title>
    <link href="https://zhu.happy365.day/2025/11/01/a8f3178c226f/"/>
    <id>https://zhu.happy365.day/2025/11/01/a8f3178c226f/</id>
    <published>2025-10-31T16:19:00.000Z</published>
    <updated>2025-11-02T01:35:33.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个非单空链表逆序的表示两个非负整数，链表中的每个节点存储数字中的一个数位，链表起始节点表示个位、第二个节点表示十位….，最后一个节点表示最高位。除了数字 0 之外，这两个数字都不会以 0 开头。<br>图示如下：<br>单链表1：2 -&gt; 4 -&gt; 3<br>单链表2：5 -&gt; 6 -&gt; 4<br>表示数字 342 和 465。<br>要求输入两个链表的头节点，以相同形式输出这两个数相加的结果。</p><p>示例：<br>输入：l1 &#x3D; [2, 4, 3] l2 &#x3D; [5, 6, 4]<br>输出：[7, 0, 8]<br>解释：342 + 465 &#x3D; 807</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>观察链表的表示可以发现这种表示方式中，链表头节点是最低位，尾节点是最高位。并且有前提“两个数字除了 0 之外，都不会以 0 开头“，这说明两个数的数位正好是对齐的。如果以两个指针从前往后同步遍历两个链表，则个位对个位，十位对十位。运算时，只要将对应指针指向的节点的数值相加，超过 10 的则用一个临时变量存储 1 表示进位，下一次循环中加上这个进位的 1。要注意，产生进位后，当前节点值的和应减去 10。<br>另外，有可能两个链表长度不一致，而且有可能最后一位的运算会产生进位，所以结束循环的条件应该是两个指针均指向空且上一次加法中没有产生进位，即存储进位的临时变量值 !&#x3D; 1。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Python3 代码实现如下：</p><pre><code class="python">class Solution:    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:        nodeIndex1 = l1        nodeIndex2 = l2        l3 = None        nodeIndex3 = None        tempVal = 0        while nodeIndex1 != None or nodeIndex2 != None or tempVal != 0:            tempNode = ListNode(0, None)            val1 = nodeIndex1.val if nodeIndex1 else 0            val2 = nodeIndex2.val if nodeIndex2 else 0            val3 = val1 + val2 + tempVal            if (val3 &gt;= 10):                tempVal = 1                val3 = val3 - 10            else:                tempVal = 0                        tempNode.val = val3            if l3 is None:                l3 = tempNode                nodeIndex3 = l3            else:                nodeIndex3.next = tempNode                nodeIndex3 = nodeIndex3.next            nodeIndex1 = nodeIndex1.next if nodeIndex1 else None            nodeIndex2 = nodeIndex2.next if nodeIndex2 else None                return l3</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;用两个非单空链表逆序的表示两个非负整数，链表中的每个节点存储数字中的一个数位，链表起始节点表示个位、第二个节点表示十位….，</summary>
      
    
    
    
    <category term="解题记录" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="LeetCode" scheme="https://zhu.happy365.day/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode70-爬楼梯</title>
    <link href="https://zhu.happy365.day/2025/10/30/acf5b521f80e/"/>
    <id>https://zhu.happy365.day/2025/10/30/acf5b521f80e/</id>
    <published>2025-10-30T14:16:00.000Z</published>
    <updated>2025-11-02T01:35:33.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong><br>输入：*n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol><p><strong>示例 2：</strong><br>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><p><strong>提示</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先手动算出 n &#x3D; 4 时的结果，将 n &#x3D; 1…4 的结果列出来的时候，看着就像是 Fibonacci 数列，花了好长时间往这个数列上去理解，但是死活想不通。</p><p>最后去看了官方题解，就一句话“要上到 n 阶台阶只有两种方式：要么从 n - 1 阶台阶上跨 1 步上来，要么从 n - 2 阶台阶上跨 2 步上来，所以上 n 阶台阶的方式就是上 n - 1 阶台阶的方式加上 n - 2 阶台阶的方式“。</p><p>以为全部理解了，就写了递归求数列的代码拿去提交了。结果提交了好几次都在 44 这个测试用例上超时，所以递归是不行的，只能用递推的方式实现。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>递归很简单但是性能不佳，需采用递推的方式实现，也很简单。</p><pre><code class="python">class Solution:    def climbStairs(self, n: int) -&gt; int:        first = 0        second = 1        for i in range(n):            result = first + second            first = second            second = result        return result</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;假设你正在爬楼梯。需要 &lt;code&gt;n&lt;/code&gt; 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 &lt;code&gt;1&lt;/co</summary>
      
    
    
    
    <category term="解题记录" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="LeetCode" scheme="https://zhu.happy365.day/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode7-整数反转</title>
    <link href="https://zhu.happy365.day/2025/10/29/3a0d567614e2/"/>
    <id>https://zhu.happy365.day/2025/10/29/3a0d567614e2/</id>
    <published>2025-10-28T16:26:00.000Z</published>
    <updated>2025-11-02T01:35:33.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231,  231 − 1]</code> ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p><strong>示例 1：</strong><br>输入：x &#x3D; 123<br>输出：321</p><p><strong>示例 2：</strong><br>输入：x &#x3D; -123<br>输出：-321</p><p><strong>示例 3：</strong><br>输入：x &#x3D; 120<br>输出：21</p><p><strong>示例 4：</strong><br>输入：x &#x3D; 0<br>输出：0</p><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= x &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>基于状态机的接发还没看懂，下面是自己的理解。<br>首先固定读取顺序为 空格 -&gt; 符号 -&gt; 字符，其中空格可能没有，也可能有多个，符号也是如此，但是符号最多只读取一次，如果读取到就从下一个字符开始读取数字部分，如果没有读取到则本次就要读取数字部分。<br>代码如下。</p><pre><code class="python"># !/usr/bin/python3# -*- coding: utf-8 -*-class Solution:    def reverse(self, x: int) -&gt; int:        num_str = str(x)        stack = []        sign = &quot;&quot;        for index in range(len(num_str)):            char = num_str[index]            if (char == &quot;-&quot;):                sign = char            else:                stack.append(num_str[index])        if (len(sign) &gt; 0):            stack.append(sign)        num_str = &quot;&quot;        for index in range(len(stack)):            char = stack.pop()            num_str += char        num = int(num_str)        if (num &gt; 2**31 - 1 or num &lt; -2**31):            return 0        else:            return num</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个 32 位的有符号整数 &lt;code&gt;x&lt;/code&gt; ，返回将 &lt;code&gt;x&lt;/code&gt; 中的数字部分反转后的结</summary>
      
    
    
    
    <category term="解题记录" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="LeetCode" scheme="https://zhu.happy365.day/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>博客调整</title>
    <link href="https://zhu.happy365.day/2025/10/26/a4d3c56821b7/"/>
    <id>https://zhu.happy365.day/2025/10/26/a4d3c56821b7/</id>
    <published>2025-10-26T12:09:27.000Z</published>
    <updated>2025-11-02T01:35:33.193Z</updated>
    
    <content type="html"><![CDATA[<p>距离更换博客主题为 hexo-theme-cactus 已经一年半了，最近有点时间进行了一些调整和优化，记录一下调整的地方。</p><p>主要有：<br>域名：精简域名为 zhu.happy365.day。</p><p>页面布局：</p><ul><li>将导航中的“开往”移到页面底部中间位置，同时增加“十年之约”入口。</li><li>删除首页中间位置的社交元素，更改为欢迎语。</li><li>友链页面将友链列表放在页面顶部，站点信息下移</li></ul><p>样式：</p><ul><li>主题色调整为绿色。</li><li>删除萌国备案信息中的空格以节省空间。</li></ul><p>其他：</p><ul><li>更新“关于”页面。</li><li>移除部分无法访问的友链，新增 2 个友链。</li><li>部分元素国际化调整。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;距离更换博客主题为 hexo-theme-cactus 已经一年半了，最近有点时间进行了一些调整和优化，记录一下调整的地方。&lt;/p&gt;
&lt;p&gt;主要有：&lt;br&gt;域名：精简域名为 zhu.happy365.day。&lt;/p&gt;
&lt;p&gt;页面布局：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将导航中的“</summary>
      
    
    
    
    <category term="博客维护" scheme="https://zhu.happy365.day/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
    <category term="博客维护" scheme="https://zhu.happy365.day/tags/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="https://zhu.happy365.day/2025/10/24/99677b39ea2d/"/>
    <id>https://zhu.happy365.day/2025/10/24/99677b39ea2d/</id>
    <published>2025-10-24T15:56:20.000Z</published>
    <updated>2025-11-02T01:35:33.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-KMP-算法"><a href="#什么是-KMP-算法" class="headerlink" title="什么是 KMP 算法"></a>什么是 KMP 算法</h2><p>KMP 算法是一种用于字符串模式匹配的高效算法，由 Knuth、Morris、Pratt 三位大佬于 1977 年提出，算法名称来源于这几个人的名字首字母。可以将时间复杂度从傻瓜式的暴力匹配的 O(m x n) 降低到 O(m + n) 级别，效率提升非常大。</p><h2 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h2><p>傻瓜式的暴力匹配原理很简单，对于 text 的第 i 个字符，分别用 p、t 指针分别指向 text 的第 i 个字符、pattern 的起始字符，然后判断两个下标指针位置的字符是否相等；如果相等，则两个下标指针后移一位；如果不相等，则对 text 字符串的第 （i + 1)  个字符循环上述过程，直到 pattern 中的字符全部匹配成功或者到达 text 的最后一个字符。</p><p>第一轮：</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_11.51.33.png"></p><p>第二轮：</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_11.55.49.png"></p><p>第三轮：</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_11.56.57.png"></p><p>代码实现如下。</p><pre><code class="python">def match(text, pattern):    text_list = list(text)    pattern_list = list(pattern)    i = 0    while i &lt; len(text_list):        t = i        p = 0        while t &lt; len(pattern_list):            if (text_list[t] == pattern_list[p]):                t += 1                p += 1            else:                break                if p == len(pattern_list):            return i        elif t == len(text_list):            return -1        i += 1    return -1</code></pre><p>这种匹配方式实现起来非常简单，时间复杂度为 O(m x n)。 但是这样的匹配方式存在回溯问题，每次遇到不匹配的字符时需要回退到 text 的第 i + 1 个字符。</p><h2 id="KMP-算法的匹配过程"><a href="#KMP-算法的匹配过程" class="headerlink" title="KMP 算法的匹配过程"></a>KMP 算法的匹配过程</h2><p>KMP 算法消除了暴力匹配的回溯问题。</p><p>观察匹配过程：</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_11.51.33.png"></p><p>直到第 5 个字符： A、C 不匹配时，前面的 4 个字符都是匹配的，并且观察可以发现前 4 个字符中存在重复的序列 AB，因为前 4 个字符是匹配的，所有同样重复的序列在 pattern 中同样存在。于是可以想有没有可能不回溯 text，而是将 pattern 向右移动，移动时跳过重复的 AB 字符？如下图，这样就能保证在当前匹配到的第 5 个位置之前的字符都是匹配的，然后就可以继续往后匹配了，从而节省回溯 text 之后的几次重复无用匹配。</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_12.28.49.png"></p><p>这就是 KMP 算法的思想，利用 pattern 中子串重复的信息来指示当遇到不匹配字符时 pattern 串应该跳过多少次匹配（也就是跳过多少个存在重复的最长子串），确保 text 不回溯，从而提高匹配的效率。</p><p>next 数组就是用来保存 pattern 串中截止到每个字符最长的重复子串信息的。</p><h2 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a>next 数组</h2><p>上面提到，next 数组是用来保存 pattern 串中截止到当前字符最长重复子串长度信息的。</p><p>要计算 next 数组，需要几个概念：最长前缀、最长后缀和最长公共前后缀。</p><p><strong>最长前缀</strong></p><p>前缀是指所有以第二个字符开始的连续子串，最长前缀就是这些连续子串中最长的一个。</p><p>比如 ABAB ，前缀有：A、AB、ABA，最长前缀为 ABA。</p><p><strong>最长后缀</strong></p><p>后缀是指所有以倒数第二个字符结尾的连续子串，最长后缀就是这些连续子串中最长的一个。</p><p>比如 ABAB 中，后缀有：A、BA、ABA。</p><p><strong>最长公共前后缀</strong></p><p>就是字符串对应的最长前缀和最长后缀的交集中长度最长的一个。</p><p>比如 ABAB 中，公共前缀和后缀有：A、ABA，最长的公共前后缀就是 ABA。</p><p><strong>next 数组</strong></p><p>next 数组是指字符串中以第一个字符开始，以每个字符结尾的子串对应的最长公共前缀的长度为元素的数组。</p><p>比如 ABABC 中：</p><p>A：不存在公共前后缀，所以长度为 0。</p><p>B：子串为 AB，不存在公共前后缀，所以长度为 0。</p><p>A：子串为 ABA，最长公共前后缀为 B，长度为 1。</p><p>B：子串为 ABAB，最长公共前后缀为 BA，长度为 2。</p><p>C：字串为 ABABC，不存在公共前后缀，所以长度为 0。</p><p>于是得到 ABABC 的 next 数组如下。</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_12.54.12.png"></p><h2 id="代码实现-next-数组的计算"><a href="#代码实现-next-数组的计算" class="headerlink" title="代码实现 next 数组的计算"></a>代码实现 next 数组的计算</h2><p>可以使用暴力求解，遍历 pattern 字符串，对于每个字符，向前找出所有的前缀、向后找出所有的后缀，求两个集合的交集，如果交集为空，则返回 0，否则取出交集中最长的子串的长度即为结果。</p><p>在网上看到有效率更高的方法，采用动态规划，从左到右来求最长公共前后缀。大致过程如下：</p><ol><li>用 next 数组记录结果，用 i 记录当前字符的下标位置，用 lenth 来记录两个指针已经连续匹配上多少个字符，即 text 中对应字符的 next 值。</li><li>初始化时，next[0] &#x3D; 0 且 i &#x3D; 1（即默认第一个字符 next 值为 0，从第 2 个字符开始进行计算），length &#x3D; 0，lenth 用来记录前一个字符的 next 值，并且可以用作第 2 个指针。</li><li>对于 text 中的每个字符：<ol><li>如果 text[i] &#x3D;&#x3D; text[len]，说明当前字符在前面出现过，于是 length + 1，并且两个指针都往后移动一位，即 i + 1，lenth 已经也加过 1。</li><li>如果 text[i] !&#x3D; text[length]，说明重复序列结束了，即 text[0] 至 text[length - 1] 这个子串和 text[i - length] 至 text[i - 1] 这个字串相同，但是 text[0] 至 text[length] 这个子串和 text[i - length] 至 text[i] 这个子串最后一位不相同，相同序列结束了，让 length 指针退回到重复序列之前，即 lenth &#x3D; next[length - 1]，再重复上面的步骤，如果 length 退回到了起始位置，说明当前字符对应的最长公共子串为 0。</li></ol></li></ol><p>代码实现如下。</p><pre><code class="python">def next(pattern):    pattern_list = list(pattern)    next = []    next.append(0)    i = 1    lenth = 0    while i &lt; len(pattern_list):        if pattern_list[i] == pattern_list[lenth]:            lenth += 1            next.insert(i, lenth)            i += 1        else:            if lenth == 0:                next.insert(i, 0)                i += 1            else:                lenth = next[lenth - 1]    return next</code></pre><h2 id="代码实现-KMP-算法"><a href="#代码实现-KMP-算法" class="headerlink" title="代码实现 KMP 算法"></a>代码实现 KMP 算法</h2><p>求出 next 数组之后，text 中的指针只管往后走，每当遇到不匹配的字符时，只需要将 pattern 中的 p 指针移动到 p - next[p - 1] 的位置处，跳过 next[p - 1] 次比较即可。循环上面的过程，如果 p 指针走到了最后，说明匹配到结果；如果 i 指针走到了最后并且 p 指针没走到最后，则匹配失败。</p><p>Python 代码如下。</p><pre><code class="python">def kmp_match(self, text, pattern):    next = self.next(pattern)    text_list = list(text)    pattern_list = list(pattern)    i = 0    p = 0    while i &lt; len(text_list) and p &lt; len(pattern_list):        if text_list[i] == pattern_list[p]:            i += 1            p += 1        else:            p = p - next[p - 1]            if p == len(pattern_list):            return i - p    return -1 </code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>这个算法比较难理解，这次花了很长时间才算是勉强搞明白其中的原理。</p><p>可以参考一下这些讲得很不错资料：</p><ul><li><a href="https://www.cnblogs.com/Higurashi-kagome/p/18013626">图文详解 KMP 算法</a></li><li><a href="https://blog.csdn.net/qq_62982856/article/details/128003067">KMP算法——通俗易懂讲好KMP算法</a></li></ul><p>B 站上也有一些视频，结合视频动画理解匹配过程会更容易理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是-KMP-算法&quot;&gt;&lt;a href=&quot;#什么是-KMP-算法&quot; class=&quot;headerlink&quot; title=&quot;什么是 KMP 算法&quot;&gt;&lt;/a&gt;什么是 KMP 算法&lt;/h2&gt;&lt;p&gt;KMP 算法是一种用于字符串模式匹配的高效算法，由 Knuth、Morris</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhu.happy365.day/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="https://zhu.happy365.day/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="KMP算法" scheme="https://zhu.happy365.day/tags/KMP%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Excel中隔N行取一行</title>
    <link href="https://zhu.happy365.day/2025/10/24/ad37b84c4d4b/"/>
    <id>https://zhu.happy365.day/2025/10/24/ad37b84c4d4b/</id>
    <published>2025-10-24T14:00:46.000Z</published>
    <updated>2025-11-02T01:35:33.186Z</updated>
    
    <content type="html"><![CDATA[<p>先上每两行中取出一行的公式</p><p><code>INDEX(A$2:A$10, ROW(A2) * 2 - 2, 1)</code> </p><p>从 A2:A10 的区域中，获取 A2、A4、A6、A8… 的值。</p><p>事情是这样的，之前做了一个批量提交审批的功能，没有做防重复提交处理，而且每个提交人每次需要处理的数据量还挺大。这周有个人提交数据之后刷新页面发现还有未提交状态的数据加载出来，于是又全部勾选再次进行了提交。就这样，申请表中就出现了部分重复的数据。</p><p>这些重复的数据需要清理掉其中的一条，重复数据除了 id 之外，其他字段都一样，需要先找出要删除的数据 id。</p><p>先用 SQL 按业务字段 group by 出来重复的数据，导出到 Excel 中，然后按业务字段进行排序，将重复数据排到一起。</p><p>然后每两行中取出一行的 id，拿到这些 id 就去进行删除就行了。怎么每两行取取出其中的一行呢？</p><p>需要用到两个函数：INDEX(array, row_num, [column_num]) 和 ROW()。</p><p><strong>INDEX(array, row_num, [column_num])</strong></p><p>从 array 区域中获取 row_num 行 column 列 的值。</p><p><strong>ROW()</strong></p><p>获取某个单元格的行号，比如 ROW(A1) 结果就是 1。</p><p>技巧就在于怎么得到目标行号，然后放到 INDEX() 函数中。</p><table><thead><tr><th>单元格行</th><th>要获取的目标行的行号（隔1行）</th><th>对应的公式计算公式</th><th>对应的 Excel 公式</th></tr></thead><tbody><tr><td>A1</td><td>1</td><td>2 x ROW(A1) - 1</td><td>INDEX(A$1:A$10, 2 * ROW(A1) - 1, 1)</td></tr><tr><td>A2</td><td>3</td><td>2 x ROW(A2) - 1</td><td></td></tr><tr><td>A3</td><td>5</td><td>2 x ROW(A3) - 1</td><td></td></tr><tr><td>A4</td><td>7</td><td>2 x ROW(A4) - 1</td><td></td></tr><tr><td>A5</td><td>9</td><td>2 x ROW(A5) - 1</td><td></td></tr><tr><td>A6</td><td></td><td></td><td></td></tr><tr><td>A7</td><td></td><td></td><td></td></tr><tr><td>A8</td><td></td><td></td><td></td></tr><tr><td>A9</td><td></td><td></td><td></td></tr><tr><td>A10</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>单元格行</th><th>要获取的目标行的行号（隔2行）</th><th>对应的公式计算公式</th><th>对应的 Excel 公式</th></tr></thead><tbody><tr><td>A1</td><td>1</td><td>3 x ROW(A1) - 2</td><td>INDEX(A$1:A$10, 3 * ROW(A1) - 2, 1)</td></tr><tr><td>A2</td><td>4</td><td>3 x ROW(A2) - 2</td><td></td></tr><tr><td>A3</td><td>7</td><td></td><td></td></tr><tr><td>A4</td><td>10</td><td></td><td></td></tr><tr><td>A5</td><td></td><td></td><td></td></tr><tr><td>A6</td><td></td><td></td><td></td></tr><tr><td>A7</td><td></td><td></td><td></td></tr><tr><td>A8</td><td></td><td></td><td></td></tr><tr><td>A9</td><td></td><td></td><td></td></tr><tr><td>A10</td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先上每两行中取出一行的公式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INDEX(A$2:A$10, ROW(A2) * 2 - 2, 1)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;从 A2:A10 的区域中，获取 A2、A4、A6、A8… 的值。&lt;/p&gt;
&lt;p&gt;事情是这样的，之前做了一个批量提交审</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhu.happy365.day/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Excel" scheme="https://zhu.happy365.day/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>在macOS上编译OpenJDK8</title>
    <link href="https://zhu.happy365.day/2025/08/02/1e117267d714/"/>
    <id>https://zhu.happy365.day/2025/08/02/1e117267d714/</id>
    <published>2025-08-02T12:14:00.000Z</published>
    <updated>2025-11-02T01:35:33.193Z</updated>
    
    <content type="html"><![CDATA[<p>在 MacOS 系统上编译 OpenJDK 遇到的一些问题及对应的解决方案的记录。因为 Java8 发布时间已经比较久，到现在各个操作系统很多地方都已经发生很大变化，所以小问题比较多，建议编译更好版本的 JDK，坑应该会少一些。</p><span id="more"></span><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>1、Mac 上安装 Mercurial 总是报错，没找到什么原因，所以用不了 <code>hg clone <a href="http://hg.openjdk.java.net/jdk8">http://hg.openjdk.java.net/jdk8</a></code> 这种方式。</p><p>jdk8 源码地址：<a href="http://jdk.java.net/java-se-ri/8-MR3">jdk8u41源码下载</a>  <a href="https://download.java.net/openjdk/openjdk/jdk8/promoted/b132/openjdk-8-src-b132-03_mar_2014.zip">zip文件下载</a></p><p>2、安装 freetype 和 ccache：</p><p><code>brew install freetype</code></p><p><code>brew install ccache</code></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>运行 configure：</p><pre><code class="bash">./configure --with-freetype-include=/usr/local/include/freetype2 --with-freetype-lib=/usr/local/lib/ --disable-warnings-as-errors --with-debug-level=slowdebug --with-jvm-variants=server --enable-ccache</code></pre><p><em>遇到的报错及解决方案</em></p><p>1、The C compiler (located as &#x2F;usr&#x2F;bin&#x2F;gcc) does not seem to be the required GCC compiler.</p><pre><code>打开文件common/autoconf/generated-configure.sh，搜索compiler is required注释或把报错命令改为echo即可。</code></pre><br><p>比较顺利，只遇到上面一个错误。</p><p>成功输出：</p><pre><code>........config.status: creating /Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-release/spec.shconfig.status: creating /Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-release/Makefileconfig.status: creating /Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-release/config.h====================================================A new configuration has been successfully created in/Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-releaseusing configure arguments &#39;--with-freetype-include=/usr/local/include/freetype2 --with-freetype-lib=/usr/local/lib/&#39;.Configuration summary:* Debug level:    release* JDK variant:    normal* JVM variants:   server* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64Tools summary:* Boot JDK:       openjdk version &quot;1.8.0_292&quot; OpenJDK Runtime Environment (Zulu 8.54.0.21-CA-macosx) (build 1.8.0_292-b10) OpenJDK 64-Bit Server VM (Zulu 8.54.0.21-CA-macosx) (build 25.292-b10, mixed mode)  (at /opt/java/zulu8.54.0.21-ca-jdk8.0.292-macosx_x64)* C Compiler:      version  (at /usr/bin/gcc)* C++ Compiler:    version  (at /usr/bin/g++)Build performance summary:* Cores to use:   4* Memory limit:   16384 MB* ccache status:  installed, but disabled (version older than 3.1.4)Build performance tip: ccache gives a tremendous speedup for C++ recompilations.You have ccache installed, but it is a version prior to 3.1.4. Try upgrading.</code></pre><br><p>运行 <code>make all</code></p><p>报错及解决：</p><p>1、clang: error: include path for libstdc++ headers not found; pass ‘-stdlib&#x3D;libc++’ on the command line to use the libc++ standard library instead [-Werror,-Wstdlibcxx-not-found]</p><p><a href="https://blog.csdn.net/quantum7/article/details/108466760">MAC编译OpenJDK8：clang: error: include path for libstdc++ headers not found</a></p><p><a href="https://github.com/quantum6/xcode-missing-libstdcpp.git">The missing libstdc++ headers and libraries for Xcode 10 or above.</a></p><p>2、</p><pre><code>l-op-parentheses]    if ( instr-&gt;is_ideal_branch() &amp;&amp; instr-&gt;label_position() == -1 ||         ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~/Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/hotspot/src/share/vm/adlc/archDesc.cpp:336:35: note: place parentheses around the &#39;&amp;&amp;&#39; expression to silence this warning    if ( instr-&gt;is_ideal_branch() &amp;&amp; instr-&gt;label_position() == -1 ||                                  ^         (                                                        )</code></pre><h1 id="其他可能遇到的错误"><a href="#其他可能遇到的错误" class="headerlink" title="其他可能遇到的错误"></a>其他可能遇到的错误</h1><p>&#x2F;Users&#x2F;lozhu&#x2F;Documents&#x2F;projects&#x2F;jdk12-06222165c35f&#x2F;src&#x2F;java.base&#x2F;macosx&#x2F;native&#x2F;libosxsecurity&#x2F;KeystoreImpl.m note: did not find header ‘JavaNativeFoundation.h’ in framework ‘JavaNativeFoundation’ (loaded from ‘&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX14.0.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks’)</p><p>现在的位置：&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX14.sdk</p><p>编辑 .&#x2F;make&#x2F;test&#x2F;JtregNativeJdk.gmk</p><p>BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestMainKeyWindow :&#x3D; -framework JavaVM <br>      -framework Cocoa -framework JavaNativeFoundation</p><p>修改为</p><p>BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestMainKeyWindow :&#x3D; -framework Cocoa -framework JavaNativeFoundation</p><p>编辑 .&#x2F;build&#x2F;macosx-x86_64-server-slowdebug&#x2F;spec.gmk</p><p>删除 -F &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX11.1.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Frameworks</p><p>编辑 .&#x2F;build&#x2F;macosx-x86_64-server-slowdebug&#x2F;buildjdk-spec.gmk</p><p>参考: <a href="https://www.jianshu.com/p/885c718df9de">macOS Catalina + Xcode 12 编译OpenJDK 14 错误解决</a></p><hr><p>.&#x2F;configure –with-freetype-include&#x3D;&#x2F;usr&#x2F;local&#x2F;include&#x2F;freetype2 –with-freetype-lib&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;</p><p>报错：The C compiler (located as &#x2F;usr&#x2F;bin&#x2F;gcc) does not seem to be the required GCC compiler.<br>打开文件common&#x2F;autoconf&#x2F;generated-configure.sh，搜索compiler is required<br>注释或把报错命令改为echo即可。</p><hr><p>(base) ➜  jdk8 make<br>Building OpenJDK for target ‘default’ in configuration ‘macosx-x86_64-normal-server-release’</p><p>Starting langtools</p><p>&#x2F;bin&#x2F;sh: line 0: cd: &#x2F;Users&#x2F;chenxii&#x2F;Documents&#x2F;Java&#x2F;jdk8&#x2F;jdk8&#x2F;langtools&#x2F;make: No such file or directory<br>make: *** [langtools-only] Error 1</p><p>解决方案参考：<a href="https://stackoverflow.com/questions/34703703/jdk8-build-error-langtools">https://stackoverflow.com/questions/34703703/jdk8-build-error-langtools</a></p><hr><p>执行：.&#x2F;get_source.sh</p><p>(base) ➜  jdk8 .&#x2F;get_source.sh</p><p>Repositories:  corba jaxp jaxws langtools jdk hotspot nashorn</p><pre><code>            corba:   hg clone http://hg.openjdk.java.net/jdk8/jdk8/corba corba             jaxp:   hg clone http://hg.openjdk.java.net/jdk8/jdk8/jaxp jaxp            corba:   requesting all changes</code></pre><p>Waiting 5 secs before spawning next background command.</p><p>lcm.cpp:52:35: error: ordered comparison between pointer and zero (‘address’ (aka ‘unsigned char *’) and ‘int’) </p><p>解决：编辑&#x2F;hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;opto&#x2F;lcm.cpp:52 原：if (Universe::narrow_oop_base() &gt; 0) 修改后： if (Universe::narrow_oop_base()!&#x3D; NULL) { &#x2F;&#x2F; Implies UseCompressedOops.</p><hr><p>error: ordered comparison between pointer and zero</p><p>修改openjdk&#x2F;hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;virtualspace.cpp<br>　　修改331行为<br>　　if (base() !&#x3D; 0) {</p><hr><p>fatal error: ‘JavaNativeFoundation&#x2F;JavaNativeFoundation.h’ file not found<br>#import &lt;JavaNativeFoundation&#x2F;JavaNativeFoundation.h&gt;</p><p>(base) ➜  openjdk  sudo find &#x2F; -name “<em>JavaNativeFoundation.h</em>“<br>Password:<br>find: &#x2F;Library&#x2F;Application Support&#x2F;com.apple.TCC: Operation not permitted<br>&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX11.1.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaNativeFoundation.framework&#x2F;Versions&#x2F;A&#x2F;Headers&#x2F;JavaNativeFoundation.h<br>&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX10.15.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Versions&#x2F;A&#x2F;Frameworks&#x2F;JavaNativeFoundation.framework&#x2F;Versions&#x2F;A&#x2F;Headers&#x2F;JavaNativeFoundation.h</p><p>编辑：<br>vim hotspot&#x2F;make&#x2F;bsd&#x2F;makefiles&#x2F;saproc.make 61行：<br>SALIBS &#x3D; -g -framework Foundation -F&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX10.15.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Frameworks -framework JavaNativeFoundation -framework Security -framework CoreFoundation</p><p>105行：<br>-I&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX10.15.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Headers</p><hr><p>执行：make CONF&#x3D;macosx-x86_64-normal-server-release clean<br>make CONF&#x3D;macosx-x86_64-normal-server-release install</p><p>—– Build times ——-<br>Start 2021-07-11 10:50:45<br>End   2021-07-11 10:59:52<br>00:00:16 corba<br>00:00:50 demos<br>00:01:24 docs<br>00:02:10 hotspot<br>00:01:01 images<br>00:00:09 jaxp<br>00:00:14 jaxws<br>00:02:35 jdk<br>00:00:18 langtools<br>00:00:08 nashorn</p><p>00:09:07 TOTAL</p><p>Finished building OpenJDK for target ‘all’</p><p>WARNING: You have the following ALT_ variables set:<br>ALT_PARALLEL_COMPILE_JOBS&#x3D;2<br>ALT_ variables are deprecated and will be ignored. Please clean your environment.</p><p>[1]    90140 bus error  build&#x2F;macosx-x86_64-normal-server-release&#x2F;jdk&#x2F;bin&#x2F;java -version</p><p>&#x2F;Users&#x2F;chenxii&#x2F;Documents&#x2F;Java&#x2F;jdk8&#x2F;openjdk&#x2F;build&#x2F;macosx-x86_64-normal-server-release&#x2F;jdk&#x2F;bin</p><p>？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 MacOS 系统上编译 OpenJDK 遇到的一些问题及对应的解决方案的记录。因为 Java8 发布时间已经比较久，到现在各个操作系统很多地方都已经发生很大变化，所以小问题比较多，建议编译更好版本的 JDK，坑应该会少一些。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://zhu.happy365.day/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://zhu.happy365.day/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Debian12主机无法被ping通的问题</title>
    <link href="https://zhu.happy365.day/2025/07/28/174112c250b1/"/>
    <id>https://zhu.happy365.day/2025/07/28/174112c250b1/</id>
    <published>2025-07-28T13:14:02.000Z</published>
    <updated>2025-11-02T01:35:33.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给 mini 主机安装了 Debian12 做为服务器使用，配置好 ssh 之后从 Mac 上进行远程登录，虽然连接的都是同一个Wi-Fi，但是一直连接失败。<br>ping 了一下延迟非常高，接近 100% 的丢包率。从 debian 系统 ping Mac 又是正常的，平均延迟在 10 秒左右，非常奇怪。</p><p>参考了网上很多资料这个问题都没有解决，前后浪费了好几个小时的时间。最后还是看到网上提到了 Docker，Docker 网络可能会对宿主机的网络产生影响，然后去问了 AI，根据 AI 的提示 <strong>修改 nftables 配置</strong> 解决了这个问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>允许 ICMP（ping）通过 nftables</p><pre><code class="bash"># 临时允许ICMP（立即生效，重启nftables后失效）sudo nft add rule inet filter input meta l4proto icmp accept# 若需永久生效，需写入nft配置文件sudo vim /etc/nftables.conf# 在&quot;input&quot;链中添加（确保在&quot;drop&quot;规则之前）：# chain input &#123;#   ...#   meta l4proto icmp accept  # 允许ICMP#   ...# &#125;# 重启nftables生效sudo systemctl restart nftables</code></pre><p>修改 &#x2F;etc&#x2F;nftables.conf，在 input 部分添加 <code>meta l4proto icmp accept</code>，然后重启 nftables，就能正常 ping 通了。</p><p>更早之前看到一篇博客说在 &#x2F;etc&#x2F;sysctl.conf 配置最下面新增配置 <code>net.ipv4.icmp_echo_ignore_all = 0</code>，但是在我这里没有效果。</p><h2 id="其他可能的原因"><a href="#其他可能的原因" class="headerlink" title="其他可能的原因"></a>其他可能的原因</h2><p>其他可能导致此类的问题的原因及排查方向：</p><ul><li>服务端和客户端没有连接同一个网络</li><li>服务端配置了防火墙</li><li>服务端配置忽略 ICMP 请求，就是我这种情况</li><li>服务端配置了静态 IP，IP 的网段、子网掩码长度、网关地址配置可能有误</li><li>服务端安装了 docker，服务端宿主机 IP 网段和 docker 默认配置的网络的网段有冲突，类似 172.12.0.1&#x2F;16</li><li>客户端路由表可能指向了错误的地址或者存在缓存，使用 <code>arp -a</code>查看本机路由表</li><li>客户端 DNS 配置可能有误，检查下是否可以访问百度等网站</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;给 mini 主机安装了 Debian12 做为服务器使用，配置好 ssh 之后从 Mac 上进行远程登录，虽然连接的都是同一个Wi-Fi，</summary>
      
    
    
    
    <category term="解决方案" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Debian" scheme="https://zhu.happy365.day/tags/Debian/"/>
    
    <category term="网络" scheme="https://zhu.happy365.day/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Debian12配置Clash代理拉取docker镜像</title>
    <link href="https://zhu.happy365.day/2025/07/28/3bf22fba5636/"/>
    <id>https://zhu.happy365.day/2025/07/28/3bf22fba5636/</id>
    <published>2025-07-28T12:58:48.000Z</published>
    <updated>2025-11-02T01:35:33.186Z</updated>
    
    <content type="html"><![CDATA[<p>debian12 中安装了 docker，由于一些为你好的原因，死活拉取不了镜像，一直超时。第一次在 Linux 环境下配置 clash，踩了一些坑，记录一下，供遇到相同问题的参考。</p><p>项目地址：<a href="https://github.com/wnlen/clash-for-linux">wnlen&#x2F;clash-for-linux</a></p><p>拉取项目</p><pre><code class="bash">git clone https://github.com/wnlen/clash-for-linux.git clash-for-linux</code></pre><p>编辑 .env 文件，将 CLASH_URL 变量替换为订阅链接，将 CLASH_SECRET 替换为自定义的密码。</p><p>运行启动脚本</p><pre><code class="bash">chmod +x start.sh./start.sh</code></pre><p>开启代理</p><pre><code class="bash">source /etc/profile.d/clash.shproxy_on</code></pre><p>检查环境变量</p><pre><code class="bash">env | grep -E &#39;http_proxy|https_proxy&#39;http_proxy=http://127.0.0.1:7890https_proxy=http://127.0.0.1:7890</code></pre><p>以上步鄹如果正常，说明服务clash程序启动成功。</p><p>重启程序</p><p>如果需要对Clash配置进行修改，请修改 <code>conf/config.yaml</code> 文件。然后运行 <code>restart.sh</code> 脚本进行重启。</p><p><strong>注意：</strong> 重启脚本 <code>restart.sh</code> 不会更新订阅信息。</p><p>关闭服务</p><pre><code class="bash">sudo bash shutdown.sh</code></pre><p>关闭代理</p><pre><code class="bash">proxy_off</code></pre><p>访问 <a href="http://ip:9090/ui">http://ip:9090/ui</a> 登录管理界面，可以选择节点等。</p><p>配置好代理之后，发现还是连不上 docker hub，拉取镜像还是超时。虽然在 clash 管理界面中配置了全局代理，但是还需要在 docker 中单独配置一下。</p><p>配置 docker 优先使用 ipv4，修改 &#x2F;etc&#x2F;daemon.json 如下：</p><pre><code class="json">&#123;  &quot;ipv6&quot;: false,  &quot;fixed-cidr-v6&quot;: &quot;2001:db8:1::/64&quot;,  # 值不影响  &quot;experimental&quot;: false&#125;</code></pre><p>然后配置 systemd：</p><pre><code class="bash">sudo mkdir -p /etc/systemd/system/docker.service.dsudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</code></pre><p>文件内容如下：</p><pre><code>[Service]Environment=&quot;HTTP_PROXY=http://127.0.0.1:7890&quot;Environment=&quot;HTTPS_PROXY=http://127.0.0.1:7890&quot;</code></pre><p>重启服务</p><pre><code class="bash">sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p>执行 <code>docker search hello-world</code> 测试一下吧！</p><p>参考：</p><ul><li><a href="https://neucrack.com/p/286">docker 设置代理，以及国内加速镜像设置</a></li><li><a href="https://github.com/wnlen/clash-for-linux">wnlen&#x2F;clash-for-linux</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;debian12 中安装了 docker，由于一些为你好的原因，死活拉取不了镜像，一直超时。第一次在 Linux 环境下配置 clash，踩了一些坑，记录一下，供遇到相同问题的参考。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/wnlen</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhu.happy365.day/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Debian" scheme="https://zhu.happy365.day/tags/Debian/"/>
    
    <category term="clash" scheme="https://zhu.happy365.day/tags/clash/"/>
    
    <category term="网络代理" scheme="https://zhu.happy365.day/tags/%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Debian12中SSH免密登录不生效问题</title>
    <link href="https://zhu.happy365.day/2025/07/24/ea31e94b21c0/"/>
    <id>https://zhu.happy365.day/2025/07/24/ea31e94b21c0/</id>
    <published>2025-07-23T17:04:00.000Z</published>
    <updated>2025-11-02T01:35:33.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题和原因"><a href="#问题和原因" class="headerlink" title="问题和原因"></a>问题和原因</h2><p>最近有碎片化笔记的需求，比较了 Flomo 和 Memos，flomo 的免费图片存储空间只有 500M，不适合长期使用，最后选择自己部署 Memos。据说 Memos 功能增删很随意，打算部署网上比较推荐的 0.24.0。正好可以将去年买的迷你主机利用起来。</p><p>安装了 Debian12（Debian13 8 月9 日发布，必定是要第一时间升级的），配置免密登录的时候一直不成功，复制了 ssh id 还是需要输入密码，网上看到的可能的原因：.ssh 目录、authorized_keys 文件的权限等等都确认无误，在这里卡了一个小时，记录一下。</p><p>网上看到的可能的原因都确认了一遍之后，我突然想着把服务端复制过去的 ssh id 输出来对比一下，果然问题就出在这里。服务端的 authorized_keys 文件中的内容最后的邮箱地址和我现在用的邮箱地址不一致，然后查看我本机的 .ssh 目录，里面有两份 ssh key，貌似是很久之前连接 GitHub 有问题所以生成了两个 key 分开用。我用 ssh-copy-id 复制到服务端的密钥不是我本机默认的 id_rsa.pub。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>搞明白问题出在哪里之后就很简单了，先删除服务端之前传过去的 key，复制 ssh id 的时候指定密钥文件就好了：<code>ssh-copy-id -i ~/.ssh/id_rsa.pub</code> 。复制完之后再尝试登录，就直接进入系统了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题和原因&quot;&gt;&lt;a href=&quot;#问题和原因&quot; class=&quot;headerlink&quot; title=&quot;问题和原因&quot;&gt;&lt;/a&gt;问题和原因&lt;/h2&gt;&lt;p&gt;最近有碎片化笔记的需求，比较了 Flomo 和 Memos，flomo 的免费图片存储空间只有 500M，不适合长期</summary>
      
    
    
    
    <category term="解决方案" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="SSH" scheme="https://zhu.happy365.day/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>Nuphy AIR 60 机械键盘 F 功能键问题</title>
    <link href="https://zhu.happy365.day/2025/07/20/2e53ac6e1a64/"/>
    <id>https://zhu.happy365.day/2025/07/20/2e53ac6e1a64/</id>
    <published>2025-07-20T11:29:00.000Z</published>
    <updated>2025-11-02T01:35:33.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>目前给 Mac mini 配的是 Nuphy AIR 60 二代矮轴机械键盘，这个键盘只有 60 个键位，当初就是看中了它小巧精致的外观才选的这个键盘。最近调试程序的频率比较高，需要使用到 F 功能键，这个键盘 F1 到 F12 默认是媒体功能。认为 FN 组合对应的 F 功能键就能使用 F 功能本来是一件自然而然的事情，没想到我还是高估了这个键盘的易用性。</p><h2 id="可尝试的方法"><a href="#可尝试的方法" class="headerlink" title="可尝试的方法"></a>可尝试的方法</h2><p>在 Reddit 上看到 3 年前一位老哥也遇到了同样的问题：<a href="https://www.reddit.com/r/NuPhy/comments/w58nmi/function_keys_on_mac/">Function keys on mac</a> ，下面有好几个回答，大概有下面这几种方案。</p><h3 id="FN-Tab-F-功能键"><a href="#FN-Tab-F-功能键" class="headerlink" title="FN + Tab + F 功能键"></a>FN + Tab + F 功能键</h3><p>用 FN + Tab + F 功能键组合来实现 F 功能键（开始我还以为是 FN + Tab + F 键可以在功能键和媒体功能之间切换），但是我试了几次，没有生效，FN + Tab + F12 还是增加音量。</p><h3 id="FN-X-F-功能键"><a href="#FN-X-F-功能键" class="headerlink" title="FN + X + F 功能键"></a>FN + X + F 功能键</h3><p>这个组合键需要先在 系统设置 &gt; 键盘 &gt; 快捷键 &gt; 功能键 中开启选项“使用 F1… 功能键“选项。不过我试了这个组合键在我这里也不生效。</p><h3 id="FN-Shift-F-功能键"><a href="#FN-Shift-F-功能键" class="headerlink" title="FN + Shift + F 功能键"></a>FN + Shift + F 功能键</h3><p>这个组合键终于能用了，不过测试了几下感觉键位太多了，使用起来比较累，还是没有直接 FN + F 使用起来方便。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Reddit 上的方案都尝试了一遍，没找到理想的解决方案。</p><p>在 V2EX 上看到几个月前的一个帖子：<a href="https://www.v2ex.com/t/1094555">macOS 如何使用 标准 F1~F12 的功能</a> ，很多号称支持 Mac 的键盘，FN 功能键是残废的。不过帖子里有人提供了一个简单的方法：将键盘改回 win 模式，然后在 系统设置 &gt; 键盘 &gt; 键盘快捷键 &gt; 修饰键 中，将 Command 键映射成 Option 键，将 Option 键映射为 Command 键，至此这个问题完美解决。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="关闭显示桌面快捷键"><a href="#关闭显示桌面快捷键" class="headerlink" title="关闭显示桌面快捷键"></a>关闭显示桌面快捷键</h3><p>系统设置中默认 F11 是显示桌面的快捷键，在这里关闭：系统设置 &gt; 键盘 &gt; 快捷键 &gt; 调度中心，取消勾选显示桌面。</p><h3 id="工具网站推荐"><a href="#工具网站推荐" class="headerlink" title="工具网站推荐"></a>工具网站推荐</h3><p>在线键盘测试网站：因为尝试各种方案的时候，不知道 FN 键生效没生效，在 <a href="https://www.zfrontier.com/lab/keyboardTester">在线键盘测试</a> 这个网站中，可以实时看到自己按下了哪个键，很实用。</p><p>快捷键网：这个机械键盘的灯效、亮度、设备切换等功能需要使用 FN 加上某些快捷键来实现，又不常用，常常用到的时候需要临时翻下说明书，很麻烦。终于发现个网站：<a href="http://www.kjjw.cc/nuphy-air60/">快捷键网</a> ，这里可以查到常见厂家的机械键盘的快捷键，很实用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;目前给 Mac mini 配的是 Nuphy AIR 60 二代矮轴机械键盘，这个键盘只有 60 个键位，当初就是看中了它小巧精致的外观才选</summary>
      
    
    
    
    <category term="解决方案" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="机械键盘" scheme="https://zhu.happy365.day/tags/%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98/"/>
    
    <category term="F功能键" scheme="https://zhu.happy365.day/tags/F%E5%8A%9F%E8%83%BD%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>curl 学习笔记</title>
    <link href="https://zhu.happy365.day/2025/07/19/b0a04d6723ef/"/>
    <id>https://zhu.happy365.day/2025/07/19/b0a04d6723ef/</id>
    <published>2025-07-19T14:24:00.000Z</published>
    <updated>2025-11-02T01:35:33.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时接口调试都是 postman 用得比较多，图形界面，操作简单，缺点就是要多开一个软件，切换窗口。于是就想着学习一下 curl 的使用，直接在终端里调试接口。记录一下常用的请求方式及相关参数。</p><h2 id="常用的参数"><a href="#常用的参数" class="headerlink" title="常用的参数"></a>常用的参数</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET 比较简单，不需要额外的参数。</p><pre><code class="sh">curl http://localhost:8000/api/mall/users?userId=1752938209629</code></pre><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><ul><li>-X 指定请求方式</li><li>-d 指定 POST 数据，默认 Content-Type 为 application&#x2F;x-www-form-urlencoded</li><li>– json 发送 json 数据，自动设置 Content-Type 为 application&#x2F;json</li></ul><pre><code class="sh">curl -X POST --json &#39;&#123;    &quot;username&quot;: &quot;比六&quot;,    &quot;gender&quot;: &quot;F&quot;&#125;&#39; http://localhost:8000/api/mall/users</code></pre><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>PUT 请求和 POST 请求类似</p><pre><code class="sh">curl -X PUT --json &#39;&#123;    &quot;userId&quot;: 1752938209629,    &quot;username&quot;: &quot;比六1&quot;&#125;&#39; http://localhost:8000/api/mall/users</code></pre><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE 请求和 GET 请求类似</p><pre><code class="sh">curl -X DELETE http://localhost:8000/api/mall/users?userId=1752938209629</code></pre><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><ul><li>-F 发送表单，可用来上传文件</li></ul><pre><code class="sh">curl -F &quot;file=@/file&quot; http://localhost:8000/api/mall/upload</code></pre><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><ul><li>-O 使用远程文件名保存文件到本地</li><li>-o 下载文件并重命名</li></ul><pre><code class="sh">curl -O http://localhost:8000/api/mall/downloadcurl -o myfile.zip http://localhost:8000/api/mall/download</code></pre><h3 id="其他常用参数"><a href="#其他常用参数" class="headerlink" title="其他常用参数"></a>其他常用参数</h3><ul><li>-v 输出详细信息</li><li>-H 指定请求头，如 <code>-H &quot;Content-Type: application/json&quot;</code></li><li>-i 输出响应头信息</li></ul><h2 id="终端-JSON-格式化"><a href="#终端-JSON-格式化" class="headerlink" title="终端 JSON 格式化"></a>终端 JSON 格式化</h2><p>请求之后调用 python json 进行格式化：</p><pre><code class="sh">curl http://localhost:8000/api/mall/users | python3 -m json.tool</code></pre><p>如果遇到中文乱码问题，需要修改 python&#x2F;tool.py 文件： <code>/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/json/tool.py</code></p><p>将 <code>dump_args</code> 修改如下：</p><pre><code class="python">dump_args = &#123;  &#39;sort_keys&#39;: options.sort_keys,  &#39;indent&#39;: options.indent,  # &#39;ensure_ascii&#39;: options.ensure_ascii,  &#39;ensure_ascii&#39;: False  # 修改后的配置项&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;平时接口调试都是 postman 用得比较多，图形界面，操作简单，缺点就是要多开一个软件，切换窗口。于是就想着学习一下 curl 的使用，直</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhu.happy365.day/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="curl" scheme="https://zhu.happy365.day/tags/curl/"/>
    
  </entry>
  
  <entry>
    <title>使用STMP协议发送邮件</title>
    <link href="https://zhu.happy365.day/2025/07/02/5e4bf064e5ad/"/>
    <id>https://zhu.happy365.day/2025/07/02/5e4bf064e5ad/</id>
    <published>2025-07-02T14:43:12.000Z</published>
    <updated>2025-11-02T01:35:33.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近拿到一个需求，需要给一个基于jdk1.6开发的系统增加登录验证码，这个过程中需要调用第三方接口，如果第三方接口调用失败，则需发送告警邮件到指定邮箱。比较坑的是，因为系统比较老，加了 jar 包之后一直不生效，所以不能引入其他依赖，比如 mail-api 之类的。</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>只基于一些工具包做过邮件发送，趁此机会了解了一下 SMTP 协议。<br>使用 SMTP 协议发送邮件分为几个步骤：</p><ul><li>与 SMTP 服务器建立连接</li><li>身份认证（用户名和密码需通过 base64 进行编码，一般不是邮箱密码，而是一个一次性密码）</li><li>指定收件人（没有抄送人选项，抄送通过多次指定收件人实现）</li><li>邮件内容</li><li>退出</li></ul><h2 id="基于命令行"><a href="#基于命令行" class="headerlink" title="基于命令行"></a>基于命令行</h2><pre><code class="shell"># 使用 telnet 连接到 smtp 服务器&gt; telnet smtp.163.com 25Trying 240e:938:a07:6:0:14:203:45...Connected to smtp163.mail.ntes53.netease.com.Escape character is &#39;^]&#39;.220 163.com Anti-spam GT for Coremail System (163com[20141201])</code></pre><pre><code class="shell"># HELO 命令&gt; HELO stmp.163.com250 OK</code></pre><pre><code class="shell"># 认证 （dXNlcm5hbWU6 即为 username:、UGFzc3dvcmQ6 即为 password:）&gt; AUTH LOGIN334 dXNlcm5hbWU6# 输入 base64 编码后的用户名&gt; emh1bG9uZ2t1bjIwQDE2My5jb334 UGFzc3dvcmQ6# 输入 base64 编码的密码&gt; WU54UktjYVJLZFhLWmV235 Authentication successful</code></pre><p>到这里已经成功登录到服务器了。</p><pre><code class="shell"># 发件人&gt; MAIL FROM:&lt;wuyifan2@163.com&gt;250 Mail OK# 收件人&gt; RCPT TO:&lt;liyifeng29@163.com&gt;250 Mail OK# 抄送人&gt; RCPT TO:&lt;76612151@qq.com&gt;250 Mail OK</code></pre><p>邮件内容命令为 DATA，然后以 . 作为结束。</p><pre><code class="shell">&gt; DATA354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;&gt; Subject: Greet Email&gt; This is a greet email from 163!&gt; .250 Mail OK queued as gzsmtp2,PSgvCgBnBIxyor+sPBA--.4614S2 1751466502 # 已经进入发送队列# 使用 QUIT 命令退出&gt; QUIT221 ByeConnection closed by foreign host.</code></pre><p>以上就是使用命令行发送邮件的全过程，其中要注意，短时间内发送多封邮件，可能会被反垃圾邮件程序拦截掉，邮件标题、内容最好不要太随意。</p><h2 id="纯-Java-实现"><a href="#纯-Java-实现" class="headerlink" title="纯 Java 实现"></a>纯 Java 实现</h2><p>基于 socket 和 IO 流实现邮件发送，代码如下：</p><pre><code class="java">import java.io.*;  import java.net.InetSocketAddress;  import java.net.Socket;  import java.nio.charset.StandardCharsets;  import java.util.Base64;    public class MyMail &#123;      public static void sendMail(String host, int port, String username, String password,                                  String receiver, String ccReceiver, String subject, String body) throws IOException &#123;          Socket socket = new Socket();          InetSocketAddress inetSocketAddress = new InetSocketAddress(host, port);          socket.connect(inetSocketAddress);          OutputStream outputStream = socket.getOutputStream();          InputStream inputStream = socket.getInputStream();          readInputStream(inputStream);            // 发送 HELO 命令          sendCommand(outputStream, &quot;HELO &quot; + host);          readInputStream(inputStream);            // 发送 AUTH LOGIN 命令          sendCommand(outputStream, &quot;AUTH LOGIN&quot;);          readInputStream(inputStream);            sendCommand(outputStream, base64Encode(username));          readInputStream(inputStream);            sendCommand(outputStream, base64Encode(password));          readInputStream(inputStream);            sendCommand(outputStream, &quot;MAIL FROM:&lt;&quot; + username + &quot;&gt;&quot;);          readInputStream(inputStream);            sendCommand(outputStream, &quot;RCPT TO:&lt;&quot; + receiver + &quot;&gt;&quot;);          readInputStream(inputStream);            sendCommand(outputStream, &quot;RCPT TO:&lt;&quot; + ccReceiver + &quot;&gt;&quot;);          readInputStream(inputStream);            sendCommand(outputStream, &quot;DATA&quot;);          readInputStream(inputStream);            sendCommand(outputStream, &quot;Subject: &quot; + subject);          sendCommand(outputStream, body);          sendCommand(outputStream, &quot;.&quot;);          readInputStream(inputStream);            sendCommand(outputStream, &quot;QUIT&quot;);          readInputStream(inputStream);      &#125;        public static String base64Encode(String text) &#123;          return Base64.getEncoder().encodeToString(text.getBytes());      &#125;        private static void readInputStream(InputStream inputStream) throws IOException &#123;          BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));          StringBuilder response = new StringBuilder();          String line;          while ((line = bufferedReader.readLine()) != null) &#123;              response.append(line).append(&quot;\n&quot;);              if (line.length() &gt;= 3 &amp;&amp; line.charAt(3) == &#39; &#39;) &#123;                  break;              &#125;          &#125;          System.out.println(response.toString().trim());      &#125;        private static void sendCommand(OutputStream outputStream, String command) throws IOException &#123;          BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));          bufferedWriter.write(command + &quot;\r\n&quot;);          bufferedWriter.flush();      &#125;        public static void main(String[] args) &#123;          try &#123;              sendMail(&quot;smtp.163.com&quot;, 25,                      &quot;wuyifan2@163.com&quot;, &quot;YNxRKcadfsdXsdfa&quot;,                      &quot;liyifeng@163.com&quot;, &quot;123766119@qq.com&quot;,                      &quot;Greet day&quot;, &quot;Today is a great day!&quot;);          &#125; catch (Exception e) &#123;              e.printStackTrace();              System.out.println(&quot;邮件发送失败&quot;);          &#125;    &#125;  &#125;</code></pre><p>注意，认证的密码不是邮箱的密码，而是一次性授权码，在邮箱设置里开启“POP3&#x2F;SMTP服务”可以获取到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近拿到一个需求，需要给一个基于jdk1.6开发的系统增加登录验证码，这个过程中需要调用第三方接口，如果第三方接口调用失败，则需发送告警邮件</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://zhu.happy365.day/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://zhu.happy365.day/tags/Java/"/>
    
    <category term="SMTP" scheme="https://zhu.happy365.day/tags/SMTP/"/>
    
    <category term="邮件" scheme="https://zhu.happy365.day/tags/%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>在idea2024中编译jdk6项目</title>
    <link href="https://zhu.happy365.day/2025/06/23/b5802d61aac8/"/>
    <id>https://zhu.happy365.day/2025/06/23/b5802d61aac8/</id>
    <published>2025-06-22T16:33:00.000Z</published>
    <updated>2025-11-02T01:35:33.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近接手一个基于 jdk6 的 jsp 老项目，需要给这个项目加点功能。在 idea2024 版中修改完代码，使用 jdk8 编译好 class 文件后替换到 tomcat 中项目跑不起来，查看日志发现有错误提示：</p><pre><code>Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: org/catalina/startup/Bootstrap : Unsupported major.minor version 52.0</code></pre><p>查看 tomcat 中配置文件后发现使用的 jdk6，之前看到 WEB-INF 下的 lib 包里有 spring-aop-3.2.2 之类的依赖，看错了看成 spring-boot-3.2.2 了还疑惑了一下老系统都升级到 Springboot3 了吗，还打算使用 jdk17 来编译，原来是看错了。</p><p>然后去查了一下，Spring3 支持 jdk6 和 jdk7，于是在 idea 上将项目的 jdk 版本切换为 jdk6 来编译，但是编译的时候 idea2024 提示最低支持的 jdk 版本是 jdk7。本来将项目使用的 jdk 版本切换成 jdk7 去编译就可以了，可是这个老项目是在云桌面里开发的，里面有 jdk6、jdk8，偏偏没有 jdk7 文件，还无法下载也无法上传。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>先是根据 AI 的提示修改了 idea 的相关配置，但还是报错，无法成功编译。</p><p>最后在 segmentfault 里看到一个同样的问题，按回复中的方法试了一下成功编译出来了，替换到 tomcat 中后功能正常。<br><a href="https://segmentfault.com/q/1010000045021590">IDEA环境配置失败，Java项目需要JDK 1.6如何解决？</a></p><p>具体的配置：</p><ol><li>打开 File - Project Structure，设置 Project SDK 为 jdk8，Project Language Level 设置为 7（保持兼容性）</li><li>将 Module 中的 jdk 版本设置成 jdk6</li><li>在 File &gt; Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Java Compiler 中，在 Additional command-line parameters 中添加：<code>-source 1.7 -target 1.7</code>，强制用高版本 jdk 编译出兼容低版本 jdk 的字节码，设置完之后就可以进行编译了。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;最近接手一个基于 jdk6 的 jsp 老项目，需要给这个项目加点功能。在 idea2024 版中修改完代码，使用 jdk8 编译好 cla</summary>
      
    
    
    
    <category term="解决方案" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="idea2024" scheme="https://zhu.happy365.day/tags/idea2024/"/>
    
    <category term="jdk6" scheme="https://zhu.happy365.day/tags/jdk6/"/>
    
  </entry>
  
  <entry>
    <title>iCloud Drive中无法创建Documents文件夹</title>
    <link href="https://zhu.happy365.day/2025/05/03/6dedb1702b09/"/>
    <id>https://zhu.happy365.day/2025/05/03/6dedb1702b09/</id>
    <published>2025-05-03T04:28:58.000Z</published>
    <updated>2025-11-02T01:35:33.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有跨设备同步文件的需求，分别试用了 OneDrive 和谷歌硬盘，还了解了 Dropbox。</p><p>OneDrive 在国内不需要 VPN 就直接能用，这点比较方便，而且手机、平板、PC 都有对应的客户端，用起来很方便。缺点就是免费容量只有 5G，随便存几个 PDF 就已经占用了大半，免费额度无法长期使用。付费的话最低 1.99 美元每个月，容量是 100G，我用不上这么多空间，一个月 15 块钱还是有点贵。</p><p>谷歌硬盘有 15G 免费空间，足够我同步常用的文件使用了，但是需要 VPN 才能使用，而且 PC 端是没有客户端的，只能用网页版，不是特别的方便，但是用来存放一些使用频率不高的文件还是挺好的。</p><p>Dropbox 免费空间只有 2G，不付费基本不能用，而且月费特别贵，根本不用考虑。</p><p>最终选择了苹果的 50G 的套餐，一个月 6 块钱，不需要第三方客户端，体验更好。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在 iCloud Drive 中想创建一个 Documents 文件夹，发现过了两秒钟，文件夹名称会自动变成“untitled folder“，先命名成”Document“，再改为”Documents“也是一样，会自动变成之前的名称“Document“。</p><p>于是想着是不是苹果把这个文件夹名称占用了，网上搜了一下，发现确实如此，准确来说是被保留了。</p><p><a href="https://www.reddit.com/r/MacOS/comments/z41468/why_cant_i_rename_or_delete_this_folder/?rdt=37650">Why can’t I rename or delete this folder?</a></p><p><a href="https://support.apple.com/en-us/109344">Add your Desktop and Documents files to iCloud Drive</a></p><p>因为在系统设置里面可以设置是否开启将 Desktop &#x2F; Documents 文件夹同步到 iCloud Drive，所以自己创建的文件夹就不能叫这个名字了。这个功能虽说很方便实用，我的 Documents 下的文件很多不需要同步，貌似也不能排除不需要同步的文件。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>两种方式：</p><ul><li>在设置里将同步 Desktop &#x2F; Documents 目录打开</li><li>选择其他名称</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近有跨设备同步文件的需求，分别试用了 OneDrive 和谷歌硬盘，还了解了 Dropbox。&lt;/p&gt;
&lt;p&gt;OneDrive 在国内不需</summary>
      
    
    
    
    <category term="解决方案" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="iCloud" scheme="https://zhu.happy365.day/tags/iCloud/"/>
    
    <category term="文件夹名称占用" scheme="https://zhu.happy365.day/tags/%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0%E5%8D%A0%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch入门</title>
    <link href="https://zhu.happy365.day/2025/05/01/cf9622d9262a/"/>
    <id>https://zhu.happy365.day/2025/05/01/cf9622d9262a/</id>
    <published>2025-05-01T12:32:30.000Z</published>
    <updated>2025-11-02T01:35:33.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>感谢知乎上大数据梦想家分享的入门教程，很实用。教程地址：<a href="https://zhuanlan.zhihu.com/p/358744225">从 0 到 1 学习 elasticsearch ，这一篇就够了！(建议收藏)</a></p><span id="more"></span><h2 id="Elasticsearch-是什么"><a href="#Elasticsearch-是什么" class="headerlink" title="Elasticsearch 是什么"></a>Elasticsearch 是什么</h2><p>Elasticsearch 简称 ES，是一个开源的高扩展的分布式全文检索引擎，可以近实时的存储、检索数据。ES 使用 Lucene 作为其核心来实现所有索引及搜索的功能，使用 RESTful API来隐藏 Lucene 的复杂性，从而使全文检索变得简单易用。</p><h2 id="Elasticsearch-与-Solr-的比较"><a href="#Elasticsearch-与-Solr-的比较" class="headerlink" title="Elasticsearch 与 Solr 的比较"></a>Elasticsearch 与 Solr 的比较</h2><ul><li>ES 和 Solr 都基于 Lucene。</li><li>ES 自带分布式协调管理功能，Solr 依赖 Zookeeper 进行分布式管理。</li><li>ES 只支持 json 格式，Solr 支持 json、XML、CSV 等格式。</li><li>ES 很多功能需要第三方插件支持，Solr 本身功能较为丰富。</li><li>ES 建立索引快，适用于实时性较强的场景；Solr 查询较快，但是索引更新慢，适用于电商等查询较多的场景。</li></ul><h2 id="Elastisearch-安装及启动"><a href="#Elastisearch-安装及启动" class="headerlink" title="Elastisearch 安装及启动"></a>Elastisearch 安装及启动</h2><p>从官网 <a href="https://www.elastic.co/downloads/elasticsearch">Download Elasticsearch</a> 根据平台选择对应的版本进行下载。下载完成后将下载压缩包文件拷贝到安装路径（~&#x2F;.opt&#x2F;elasticsearch）并解压，在该目录下新建 data 目录用于存储索引。</p><p>修改配置文件 $ES_HOME&#x2F;config&#x2F;elasticsearch.yml 文件：</p><pre><code class="yaml">cluster.name: demo-elasticsearchnode.name: node01path.data: ~/.opt/elasticsearch/datapath.logs: ~/.opt/elasticsearch/logsnetwork.host: 0.0.0.0host.port: 9200cluster.initial_master_nodes: [&quot;node01&quot;]xpack.security.enabled: falsexpack.security.enrollment.enabled: falsexpack.security.http.ssl:    enabled: false    keystore.path: certs/http.p12</code></pre><p>修改 jvm.options 文件中的配置：</p><pre><code>-Xms1g-Xmx1g</code></pre><p>据说 Elasticsearch 不允许使用 root 用户操作，需要新建 elsearch 用户组及 elsearch 用户进行集群的操作，但是我在 macOS 上直接使用 admin 账号操作没遇到什么问题，并且在 macOS 上新建用户组和用户和 Linux 上的命令不通用，所以跳过新建用户这一步。</p><p>启动 es：</p><pre><code class="sh">bin/elasticsearch</code></pre><p>启动之后，可以访问 <a href="http://localhost:9200/">http://localhost:9200</a> 查看。如果没有关闭 xpack.security.http.ssl 配置的话，需要访问 <a href="https://localhost:9200。">https://localhost:9200。</a></p><p>这个页面会返回一些集群相关的信息：</p><pre><code class="json">&#123;  &quot;name&quot; : &quot;node01&quot;,  &quot;cluster_name&quot; : &quot;demo-elasticsearch&quot;,  &quot;cluster_uuid&quot; : &quot;2pFl_UiuQFSwsGD-6CTtMQ&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;9.0.0&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;tar&quot;,    &quot;build_hash&quot; : &quot;112859b85d50de2a7e63f73c8fc70b99eea24291&quot;,    &quot;build_date&quot; : &quot;2025-04-08T15:13:46.049795831Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;10.1.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;8.18.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;8.0.0&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;</code></pre><h2 id="Elasticsearch-head-安装"><a href="#Elasticsearch-head-安装" class="headerlink" title="Elasticsearch-head 安装"></a>Elasticsearch-head 安装</h2><p>Elasticsearch-head 是 Elasticsearch 的一个开源的图形化界面，在 GitHub 上可以获取：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a>。将源码克隆到本地，然后通过 npm 启动。</p><pre><code class="sh">cd elasticsearch-headnpm install npm start</code></pre><p>因为跨域的原因，需要在 elasticsearch.yml 中增加相关的配置：</p><pre><code class="yaml">http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;</code></pre><p>修改配置后，重启 es，访问 <a href="http://localhost:9100，就能看到">http://localhost:9100，就能看到</a> es-head 页面了，可以查看索引和查询之类的功能。</p><h2 id="kibana-安装"><a href="#kibana-安装" class="headerlink" title="kibana 安装"></a>kibana 安装</h2><h3 id="kibana-安装-1"><a href="#kibana-安装-1" class="headerlink" title="kibana 安装"></a>kibana 安装</h3><p>kibana 可以将更友好的展示和分析 es 的数据。在 es 官网可以进行下载：<a href="https://www.elastic.co/cn/downloads/kibana%EF%BC%8C%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8Ckibana">https://www.elastic.co/cn/downloads/kibana，要注意的是，kibana</a> 的版本需要和 es 的版本保持一致。</p><p>下载后放到指定路径 ~&#x2F;.opt&#x2F;kibana 并解压。</p><p>修改配置文件：~&#x2F;.opt&#x2F;kibana&#x2F;config&#x2F;kibana.yml：</p><pre><code class="yaml">server.port: 5601server.host: 0.0.0.0elasticsearch.hosts: [&quot;http://localhost:9200&quot;]elasticsearch.username: &quot;elsearch&quot;elasticsearch.password: &quot;elsearch&quot;</code></pre><p>通过 <code>bin/kibana</code> 启动 kibana。</p><p>访问 <a href="http://localhost:5601/">http://localhost:5601</a> 访问 kibana 页面。</p><h3 id="ik-分词器安装"><a href="#ik-分词器安装" class="headerlink" title="ik 分词器安装"></a>ik 分词器安装</h3><p>原下载地址：<a href="https://github.com/infinilabs/analysis-ik/releases%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%B7%B2%E4%B8%8D%E5%9C%A8">https://github.com/infinilabs/analysis-ik/releases，但是最新版本已不在</a> GitHub 更新，需要到 <a href="https://release.infinilabs.com/analysis-ik/stable/">https://release.infinilabs.com/analysis-ik/stable/</a> 进行下载。</p><p>下载后拷贝到 $ES_HOME&#x2F;plugins&#x2F;ik 路径下，重启 kibana。</p><p>测试分词器（最少切分）：梦想家</p><pre><code>GET _analyze&#123;    &quot;analyzer&quot;: &quot;ik_smart&quot;,    &quot;text&quot;: &quot;梦想家&quot;&#125;</code></pre><p>最细粒度切分：梦想家、梦想、想家</p><pre><code>GET _analyze&#123;    &quot;analyzer&quot;: &quot;ik_max_word&quot;,    &quot;text&quot;: &quot;梦想家&quot;&#125;</code></pre><p>分词器自定义词典：</p><p>在 $ES_HOME&#x2F;plugins&#x2F;ik&#x2F;config 路径下新建文件 my.dic，写入需要被识别成一个词的词。</p><p>修改 IKAnalyzer.cfg.xml 文件：</p><pre><code class="xml">&lt;properties&gt;   &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!-- 用户可以在这里配置自己的扩展字典 --&gt;   &lt;entry key=&quot;ext_dict&quot;&gt;my.dic&lt;/entry&gt; &lt;!-- 用户可以在这里配置自己的扩展停止词字典 --&gt;   &lt;entry key=&quot;ext_stopwords&quot;&gt;&lt;/entry&gt;&lt;/properties&gt;</code></pre><p>修改完成保存并重启 es，此时 my.dic 中的词就不会再被切分。</p><h2 id="Elasticsearch-基本操作"><a href="#Elasticsearch-基本操作" class="headerlink" title="Elasticsearch 基本操作"></a>Elasticsearch 基本操作</h2><p>创建文档：</p><pre><code class="json">PUT /test1/_doc/1&#123;  &quot;name&quot;: &quot;大数据梦想家&quot;,  &quot;age&quot;: 24&#125;</code></pre><p>创建成功后可在 es-head 页面浏览数据标签页中看到对应的索引 test1。</p><p>创建索引并指定字段类型：</p><pre><code class="json">PUT /test2&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;name&quot;: &#123;        &quot;type&quot;: &quot;text&quot;      &#125;,      &quot;age&quot;: &#123;        &quot;type&quot;: &quot;long&quot;      &#125;,      &quot;birthday&quot;: &#123;        &quot;type&quot;: &quot;date&quot;      &#125;    &#125;  &#125;&#125;</code></pre><p>查看刚才创建的索引：</p><p><code>GET /test2</code></p><p>向该索引增加数据：</p><pre><code class="json">PUT /test2/_doc/1&#123;  &quot;name&quot;: &quot;大数据梦想家&quot;,  &quot;age&quot;: 21,  &quot;birthday&quot;: &quot;2020-01-01&quot;&#125;</code></pre><p>查看文档信息：</p><pre><code class="json">GET /test2/_doc/1</code></pre><p>修改文档：</p><pre><code class="json">PUT /test2/_update/1&#123;  &quot;doc&quot;: &#123;    &quot;name&quot;: &quot;大数据梦想家1&quot;  &#125;&#125;</code></pre><p>修改文档也可以使用和新增同样的方式进行，但是会覆盖元来的数据，不推荐使用。</p><p>删除文档：</p><pre><code>DELETE /test2/_doc/1</code></pre><p>删除索引：</p><pre><code>DELETE /test2</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>先增加几条测试数据：</p><pre><code class="json">PUT /demo/_doc/1&#123;    &quot;name&quot;: &quot;爱丽丝&quot;,    &quot;age&quot;: 21,    &quot;desc&quot;: &quot;在最美的年华，做最好的自己&quot;,    &quot;tags&quot;: [&quot;技术宅&quot;, &quot;温暖&quot;, &quot;思维活跃&quot;]&#125;PUT /demo/_doc/2&#123;    &quot;name&quot;: &quot;鲍勃&quot;,    &quot;age&quot;: 25,    &quot;desc&quot;: &quot;逍遥自在&quot;,    &quot;tags&quot;: [&quot;交友&quot;, &quot;理性&quot;]&#125;PUT /demo/_doc/3&#123;    &quot;name&quot;: &quot;露西&quot;,    &quot;age&quot;: 30,    &quot;desc&quot;: &quot;人越讨厌明天，就睡得越晚&quot;,    &quot;tags&quot;: [&quot;社会&quot;, &quot;科学&quot;]&#125;PUT /demo/_doc/4&#123;    &quot;name&quot;: &quot;Alice爱学Python&quot;,    &quot;age&quot;: 21,    &quot;desc&quot;: &quot;人生苦短，我用Python&quot;,    &quot;tags&quot;: [&quot;好学&quot;, &quot;勤奋刻苦&quot;]&#125;PUT /demo/_doc/5&#123;    &quot;name&quot;: &quot;Alice爱学Java&quot;,    &quot;age&quot;: 18,    &quot;desc&quot;: &quot;技术成就自我&quot;,    &quot;tags&quot;: [&quot;思维敏捷&quot;, &quot;喜欢学习&quot;]&#125;</code></pre><p>按 name 查找，返回 name、age、desc 列，结果按 age 升序排序，从第二个结果开始返回1个结果：</p><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;name&quot;: &quot;爱丽丝&quot;    &#125;,    &quot;_source&quot;: [&quot;name&quot;, &quot;age&quot;, &quot;desc&quot;],    &quot;sort&quot;: [&#123;        &quot;age&quot;: &#123;          &quot;order&quot;: &quot;asc&quot;        &#125;      &#125;],    &quot;from&quot;: 1,    &quot;size&quot;: 1  &#125;&#125;</code></pre><p>OR：</p><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;should&quot;: [        &#123;          &quot;match&quot;: &#123;            &quot;name&quot;: &quot;爱丽丝&quot;          &#125;        &#125;,        &#123;          &quot;match&quot;: &#123;            &quot;age&quot;: 25          &#125;        &#125;      ]    &#125;  &#125;&#125;</code></pre><p>AND：</p><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123;          &quot;match&quot;: &#123;            &quot;name&quot;: &quot;爱丽丝&quot;          &#125;        &#125;      ],      &quot;filter&quot;: [        &#123;          &quot;range&quot;: &#123;            &quot;age&quot;: &#123;              &quot;lte&quot;: 18            &#125;          &#125;        &#125;      ]    &#125;  &#125;&#125;</code></pre><p>按多个值查找：</p><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;tags&quot;: &quot;男 学习&quot;    &#125;  &#125;&#125;</code></pre><p>text 字段在查找时会被先被分词然后再进行查找，keyword 类型的字段会进行精确查找，不会被分词。</p><p>对结果进行高亮显示：</p><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;name&quot;: &quot;鲍勃&quot;    &#125;  &#125;,  &quot;highlight&quot;: &#123;    &quot;pre_tags&quot;: &quot;&lt;b class=&#39;key&#39; style=&#39;color: red&#39;&gt;&quot;,    &quot;post_tags&quot;: &quot;&lt;/b&gt;&quot;,    &quot;fields&quot;: &#123;      &quot;name&quot;: &#123;&#125;    &#125;  &#125;&#125;</code></pre><p>关于分词：</p><ul><li>term：不经过分词，直接查询精确的值</li><li>match：会使用分词器解析</li></ul><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;term&quot;: &#123;      &quot;name&quot;: &quot;爱&quot;    &#125;  &#125;&#125;</code></pre><h3 id="查看健康信息"><a href="#查看健康信息" class="headerlink" title="查看健康信息"></a>查看健康信息</h3><pre><code class="json">GET _cat/health</code></pre><pre><code class="json">GET _cat/indicies?v</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;感谢知乎上大数据梦想家分享的入门教程，很实用。教程地址：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/358744225&quot;&gt;从 0 到 1 学习 elasticsearch ，这一篇就够了！(建议收藏)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://zhu.happy365.day/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="ElasticSearch" scheme="https://zhu.happy365.day/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>macOS提示无法验证APP是否包含恶意软件无法打开</title>
    <link href="https://zhu.happy365.day/2025/05/01/8d39054318ab/"/>
    <id>https://zhu.happy365.day/2025/05/01/8d39054318ab/</id>
    <published>2025-05-01T06:34:41.000Z</published>
    <updated>2025-11-02T01:35:33.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>下载了elasticsearch，运行 bin&#x2F;elasticsearch 启动时提示“macOS cannot verify that this app if free from Malware”，弹窗上只有“Move to trash”和“Cancel”两个选项，打开系统安全性设置页面，点击”Open Anyway“按钮也没有反应，然后再次运行时又重复上述现象。</p><span id="more"></span><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在知乎上找到的方法： <a href="https://www.zhihu.com/question/412633194">macOS无法验证此App不包含恶意软件，怎么解决？</a>，成功解决该问题。</p><p>两种方法：</p><ol><li>安装 Ctrl 键打开该软件，我这里不管用。</li><li>运行 <code>sudo xattr -r -d com.apple.quarantine 应用路径</code> 然后再打开软件，成功解决问题。</li></ol><p>总共有3个软件提示打不开，运行第二种方法中的命令之后，全部成功打开。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;下载了elasticsearch，运行 bin&amp;#x2F;elasticsearch 启动时提示“macOS cannot verify that this app if free from Malware”，弹窗上只有“Move to trash”和“Cancel”两个选项，打开系统安全性设置页面，点击”Open Anyway“按钮也没有反应，然后再次运行时又重复上述现象。&lt;/p&gt;</summary>
    
    
    
    <category term="解决方案" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="macOS" scheme="https://zhu.happy365.day/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Mac mini连接Wi-Fi网速慢的问题</title>
    <link href="https://zhu.happy365.day/2025/03/09/adc08664fe0f/"/>
    <id>https://zhu.happy365.day/2025/03/09/adc08664fe0f/</id>
    <published>2025-03-09T13:44:00.000Z</published>
    <updated>2025-11-02T01:35:33.188Z</updated>
    
    <content type="html"><![CDATA[<p>趁着有补贴新买了一个 M4 芯片的 Mac mini，第一次连接 Wi-Fi 使用就发现网速很慢，浏览器打开一个网页要花几十秒的时间，经常打开失败。</p><p>但是旁边的 2020 款 Macbook Pro 就很流畅，下载速度也很快。</p><p>怀疑是 Mac mini 的问题，于是在网上搜了一圈没找到什么有用的信息。</p><p>第二天晚上在 B 站上搜了一下这个问题，找到一个同样问题的视频，他提供了两个解决方案：</p><ul><li>将路由器的 Wi-Fi 频宽从 160MHz 改为 80MHz</li><li>不要将 Mac mini 放置在金属表面</li></ul><p>我才意识到我是将 Mac mini 放在显示器的支撑板上的，刚好是一块金属板。于是将其放到桌子上，果然网速就正常了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;趁着有补贴新买了一个 M4 芯片的 Mac mini，第一次连接 Wi-Fi 使用就发现网速很慢，浏览器打开一个网页要花几十秒的时间，经常打开失败。&lt;/p&gt;
&lt;p&gt;但是旁边的 2020 款 Macbook Pro 就很流畅，下载速度也很快。&lt;/p&gt;
&lt;p&gt;怀疑是 Mac m</summary>
      
    
    
    
    <category term="解决方案" scheme="https://zhu.happy365.day/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Mac mini" scheme="https://zhu.happy365.day/tags/Mac-mini/"/>
    
    <category term="Wi-Fi网速" scheme="https://zhu.happy365.day/tags/Wi-Fi%E7%BD%91%E9%80%9F/"/>
    
  </entry>
  
</feed>
