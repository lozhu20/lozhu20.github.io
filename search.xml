<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode58-最后一个单词的长度</title>
      <link href="/2025/11/02/1944a433fb0f/"/>
      <url>/2025/11/02/1944a433fb0f/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。<br><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p><strong>示例 1：</strong><br>输入：s &#x3D; “Hello World”<br>输出：5<br>解释：最后一个单词是“World”，长度为 5。</p><p><strong>示例 2：</strong><br>输入：s &#x3D; “   fly me   to   the moon  “<br>输出：4<br>解释：最后一个单词是“moon”，长度为 4。</p><p><strong>示例 3：</strong><br>输入：s &#x3D; “luffy is still joyboy”<br>输出：6<br>解释：最后一个单词是长度为 6 的“joyboy”。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 中至少存在一个单词</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>用一个变量记录单词的长度，遍历整个字符串，对每个字符有以下情况：</p><ul><li>当前字符是空白字符<ul><li>什么也不做</li></ul></li><li>当前字符不是空白字符<ul><li>如果前一个字符是空白字符<ul><li>将记录的单词长度重置为 1</li></ul></li><li>如果前一个字符不是空白字符<ul><li>将长度加 1</li></ul></li></ul></li></ul><p>代码如下：</p><pre><code class="python">class Solution:    def lengthOfLastWord(self, s: str) -&gt; int:        length = 0        for i in range(len(s)):            char = s[i]            if char != &quot; &quot;:                preChar = s[i - 1] if i &gt; 1 else 0                if preChar == &quot; &quot;:                    length = 1                else:                    length += 1        return length</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode20-有效的括号</title>
      <link href="/2025/11/01/3d6e49f8f384/"/>
      <url>/2025/11/01/3d6e49f8f384/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。<br>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong><br>输入：s &#x3D; “()”<br>输出：true</p><p><strong>示例 2：</strong><br>输入：s &#x3D; “()[]{}”<br>输出：true</p><p><strong>示例 3：</strong><br>输入：s &#x3D; “(]”<br>输出：false</p><p><strong>示例 4：</strong><br>输入：s &#x3D; “([])”<br>输出：true</p><p><strong>示例 5：</strong><br>输入：s &#x3D; “([)]”<br>输出：false</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>相比大家在学习数据结构中的栈时，都学过怎么利用栈来对逆波兰表达式求解了。遇到左侧括号先入栈，遇到右侧括号则弹出栈顶元素，判断是否匹配。如果匹配消去，如果不匹配直接返回匹配失败，最后再看栈中的元素是否清空，没有的话就表示不完全匹配。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Java 代码实现如下：</p><pre><code class="java">class Solution20 &#123;    public boolean isValid(String s) &#123;        Map&lt;Character, Character&gt; map = Map.of(&#39;(&#39;, &#39;)&#39;, &#39;[&#39;, &#39;]&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;);        char[] charArray = s.toCharArray();        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (char c : charArray) &#123;            if (map.containsKey(c)) &#123;                stack.push(c);            &#125; else if (map.containsValue(c)) &#123;                if (stack.isEmpty()) &#123;                    return false;                &#125;                Character pop = stack.peek();                if (c != map.get(pop)) &#123;                    return false;                &#125;            &#125;        &#125;        return stack.isEmpty();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode2-两数相加</title>
      <link href="/2025/11/01/a8f3178c226f/"/>
      <url>/2025/11/01/a8f3178c226f/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个非单空链表逆序的表示两个非负整数，链表中的每个节点存储数字中的一个数位，链表起始节点表示个位、第二个节点表示十位….，最后一个节点表示最高位。除了数字 0 之外，这两个数字都不会以 0 开头。<br>图示如下：<br>单链表1：2 -&gt; 4 -&gt; 3<br>单链表2：5 -&gt; 6 -&gt; 4<br>表示数字 342 和 465。<br>要求输入两个链表的头节点，以相同形式输出这两个数相加的结果。</p><p>示例：<br>输入：l1 &#x3D; [2, 4, 3] l2 &#x3D; [5, 6, 4]<br>输出：[7, 0, 8]<br>解释：342 + 465 &#x3D; 807</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>观察链表的表示可以发现这种表示方式中，链表头节点是最低位，尾节点是最高位。并且有前提“两个数字除了 0 之外，都不会以 0 开头“，这说明两个数的数位正好是对齐的。如果以两个指针从前往后同步遍历两个链表，则个位对个位，十位对十位。运算时，只要将对应指针指向的节点的数值相加，超过 10 的则用一个临时变量存储 1 表示进位，下一次循环中加上这个进位的 1。要注意，产生进位后，当前节点值的和应减去 10。<br>另外，有可能两个链表长度不一致，而且有可能最后一位的运算会产生进位，所以结束循环的条件应该是两个指针均指向空且上一次加法中没有产生进位，即存储进位的临时变量值 !&#x3D; 1。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Python3 代码实现如下：</p><pre><code class="python">class Solution:    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:        nodeIndex1 = l1        nodeIndex2 = l2        l3 = None        nodeIndex3 = None        tempVal = 0        while nodeIndex1 != None or nodeIndex2 != None or tempVal != 0:            tempNode = ListNode(0, None)            val1 = nodeIndex1.val if nodeIndex1 else 0            val2 = nodeIndex2.val if nodeIndex2 else 0            val3 = val1 + val2 + tempVal            if (val3 &gt;= 10):                tempVal = 1                val3 = val3 - 10            else:                tempVal = 0                        tempNode.val = val3            if l3 is None:                l3 = tempNode                nodeIndex3 = l3            else:                nodeIndex3.next = tempNode                nodeIndex3 = nodeIndex3.next            nodeIndex1 = nodeIndex1.next if nodeIndex1 else None            nodeIndex2 = nodeIndex2.next if nodeIndex2 else None                return l3</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode70-爬楼梯</title>
      <link href="/2025/10/30/acf5b521f80e/"/>
      <url>/2025/10/30/acf5b521f80e/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong><br>输入：*n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol><p><strong>示例 2：</strong><br>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><p><strong>提示</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先手动算出 n &#x3D; 4 时的结果，将 n &#x3D; 1…4 的结果列出来的时候，看着就像是 Fibonacci 数列，花了好长时间往这个数列上去理解，但是死活想不通。</p><p>最后去看了官方题解，就一句话“要上到 n 阶台阶只有两种方式：要么从 n - 1 阶台阶上跨 1 步上来，要么从 n - 2 阶台阶上跨 2 步上来，所以上 n 阶台阶的方式就是上 n - 1 阶台阶的方式加上 n - 2 阶台阶的方式“。</p><p>以为全部理解了，就写了递归求数列的代码拿去提交了。结果提交了好几次都在 44 这个测试用例上超时，所以递归是不行的，只能用递推的方式实现。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>递归很简单但是性能不佳，需采用递推的方式实现，也很简单。</p><pre><code class="python">class Solution:    def climbStairs(self, n: int) -&gt; int:        first = 0        second = 1        for i in range(n):            result = first + second            first = second            second = result        return result</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode7-整数反转</title>
      <link href="/2025/10/29/3a0d567614e2/"/>
      <url>/2025/10/29/3a0d567614e2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231,  231 − 1]</code> ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p><strong>示例 1：</strong><br>输入：x &#x3D; 123<br>输出：321</p><p><strong>示例 2：</strong><br>输入：x &#x3D; -123<br>输出：-321</p><p><strong>示例 3：</strong><br>输入：x &#x3D; 120<br>输出：21</p><p><strong>示例 4：</strong><br>输入：x &#x3D; 0<br>输出：0</p><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= x &lt;= 231 - 1</code></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>基于状态机的接发还没看懂，下面是自己的理解。<br>首先固定读取顺序为 空格 -&gt; 符号 -&gt; 字符，其中空格可能没有，也可能有多个，符号也是如此，但是符号最多只读取一次，如果读取到就从下一个字符开始读取数字部分，如果没有读取到则本次就要读取数字部分。<br>代码如下。</p><pre><code class="python"># !/usr/bin/python3# -*- coding: utf-8 -*-class Solution:    def reverse(self, x: int) -&gt; int:        num_str = str(x)        stack = []        sign = &quot;&quot;        for index in range(len(num_str)):            char = num_str[index]            if (char == &quot;-&quot;):                sign = char            else:                stack.append(num_str[index])        if (len(sign) &gt; 0):            stack.append(sign)        num_str = &quot;&quot;        for index in range(len(stack)):            char = stack.pop()            num_str += char        num = int(num_str)        if (num &gt; 2**31 - 1 or num &lt; -2**31):            return 0        else:            return num</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客调整</title>
      <link href="/2025/10/26/a4d3c56821b7/"/>
      <url>/2025/10/26/a4d3c56821b7/</url>
      
        <content type="html"><![CDATA[<p>距离更换博客主题为 hexo-theme-cactus 已经一年半了，最近有点时间进行了一些调整和优化，记录一下调整的地方。</p><p>主要有：<br>域名：精简域名为 zhu.happy365.day。</p><p>页面布局：</p><ul><li>将导航中的“开往”移到页面底部中间位置，同时增加“十年之约”入口。</li><li>删除首页中间位置的社交元素，更改为欢迎语。</li><li>友链页面将友链列表放在页面顶部，站点信息下移</li></ul><p>样式：</p><ul><li>主题色调整为绿色。</li><li>删除萌国备案信息中的空格以节省空间。</li></ul><p>其他：</p><ul><li>更新“关于”页面。</li><li>移除部分无法访问的友链，新增 2 个友链。</li><li>部分元素国际化调整。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客维护 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2025/10/24/99677b39ea2d/"/>
      <url>/2025/10/24/99677b39ea2d/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-KMP-算法"><a href="#什么是-KMP-算法" class="headerlink" title="什么是 KMP 算法"></a>什么是 KMP 算法</h2><p>KMP 算法是一种用于字符串模式匹配的高效算法，由 Knuth、Morris、Pratt 三位大佬于 1977 年提出，算法名称来源于这几个人的名字首字母。可以将时间复杂度从傻瓜式的暴力匹配的 O(m x n) 降低到 O(m + n) 级别，效率提升非常大。</p><h2 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h2><p>傻瓜式的暴力匹配原理很简单，对于 text 的第 i 个字符，分别用 p、t 指针分别指向 text 的第 i 个字符、pattern 的起始字符，然后判断两个下标指针位置的字符是否相等；如果相等，则两个下标指针后移一位；如果不相等，则对 text 字符串的第 （i + 1)  个字符循环上述过程，直到 pattern 中的字符全部匹配成功或者到达 text 的最后一个字符。</p><p>第一轮：</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_11.51.33.png"></p><p>第二轮：</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_11.55.49.png"></p><p>第三轮：</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_11.56.57.png"></p><p>代码实现如下。</p><pre><code class="python">def match(text, pattern):    text_list = list(text)    pattern_list = list(pattern)    i = 0    while i &lt; len(text_list):        t = i        p = 0        while t &lt; len(pattern_list):            if (text_list[t] == pattern_list[p]):                t += 1                p += 1            else:                break                if p == len(pattern_list):            return i        elif t == len(text_list):            return -1        i += 1    return -1</code></pre><p>这种匹配方式实现起来非常简单，时间复杂度为 O(m x n)。 但是这样的匹配方式存在回溯问题，每次遇到不匹配的字符时需要回退到 text 的第 i + 1 个字符。</p><h2 id="KMP-算法的匹配过程"><a href="#KMP-算法的匹配过程" class="headerlink" title="KMP 算法的匹配过程"></a>KMP 算法的匹配过程</h2><p>KMP 算法消除了暴力匹配的回溯问题。</p><p>观察匹配过程：</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_11.51.33.png"></p><p>直到第 5 个字符： A、C 不匹配时，前面的 4 个字符都是匹配的，并且观察可以发现前 4 个字符中存在重复的序列 AB，因为前 4 个字符是匹配的，所有同样重复的序列在 pattern 中同样存在。于是可以想有没有可能不回溯 text，而是将 pattern 向右移动，移动时跳过重复的 AB 字符？如下图，这样就能保证在当前匹配到的第 5 个位置之前的字符都是匹配的，然后就可以继续往后匹配了，从而节省回溯 text 之后的几次重复无用匹配。</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_12.28.49.png"></p><p>这就是 KMP 算法的思想，利用 pattern 中子串重复的信息来指示当遇到不匹配字符时 pattern 串应该跳过多少次匹配（也就是跳过多少个存在重复的最长子串），确保 text 不回溯，从而提高匹配的效率。</p><p>next 数组就是用来保存 pattern 串中截止到每个字符最长的重复子串信息的。</p><h2 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a>next 数组</h2><p>上面提到，next 数组是用来保存 pattern 串中截止到当前字符最长重复子串长度信息的。</p><p>要计算 next 数组，需要几个概念：最长前缀、最长后缀和最长公共前后缀。</p><p><strong>最长前缀</strong></p><p>前缀是指所有以第二个字符开始的连续子串，最长前缀就是这些连续子串中最长的一个。</p><p>比如 ABAB ，前缀有：A、AB、ABA，最长前缀为 ABA。</p><p><strong>最长后缀</strong></p><p>后缀是指所有以倒数第二个字符结尾的连续子串，最长后缀就是这些连续子串中最长的一个。</p><p>比如 ABAB 中，后缀有：A、BA、ABA。</p><p><strong>最长公共前后缀</strong></p><p>就是字符串对应的最长前缀和最长后缀的交集中长度最长的一个。</p><p>比如 ABAB 中，公共前缀和后缀有：A、ABA，最长的公共前后缀就是 ABA。</p><p><strong>next 数组</strong></p><p>next 数组是指字符串中以第一个字符开始，以每个字符结尾的子串对应的最长公共前缀的长度为元素的数组。</p><p>比如 ABABC 中：</p><p>A：不存在公共前后缀，所以长度为 0。</p><p>B：子串为 AB，不存在公共前后缀，所以长度为 0。</p><p>A：子串为 ABA，最长公共前后缀为 B，长度为 1。</p><p>B：子串为 ABAB，最长公共前后缀为 BA，长度为 2。</p><p>C：字串为 ABABC，不存在公共前后缀，所以长度为 0。</p><p>于是得到 ABABC 的 next 数组如下。</p><p><img src="https://images.happy365.day/25/10/iShot_2025-10-25_12.54.12.png"></p><h2 id="代码实现-next-数组的计算"><a href="#代码实现-next-数组的计算" class="headerlink" title="代码实现 next 数组的计算"></a>代码实现 next 数组的计算</h2><p>可以使用暴力求解，遍历 pattern 字符串，对于每个字符，向前找出所有的前缀、向后找出所有的后缀，求两个集合的交集，如果交集为空，则返回 0，否则取出交集中最长的子串的长度即为结果。</p><p>在网上看到有效率更高的方法，采用动态规划，从左到右来求最长公共前后缀。大致过程如下：</p><ol><li>用 next 数组记录结果，用 i 记录当前字符的下标位置，用 lenth 来记录两个指针已经连续匹配上多少个字符，即 text 中对应字符的 next 值。</li><li>初始化时，next[0] &#x3D; 0 且 i &#x3D; 1（即默认第一个字符 next 值为 0，从第 2 个字符开始进行计算），length &#x3D; 0，lenth 用来记录前一个字符的 next 值，并且可以用作第 2 个指针。</li><li>对于 text 中的每个字符：<ol><li>如果 text[i] &#x3D;&#x3D; text[len]，说明当前字符在前面出现过，于是 length + 1，并且两个指针都往后移动一位，即 i + 1，lenth 已经也加过 1。</li><li>如果 text[i] !&#x3D; text[length]，说明重复序列结束了，即 text[0] 至 text[length - 1] 这个子串和 text[i - length] 至 text[i - 1] 这个字串相同，但是 text[0] 至 text[length] 这个子串和 text[i - length] 至 text[i] 这个子串最后一位不相同，相同序列结束了，让 length 指针退回到重复序列之前，即 lenth &#x3D; next[length - 1]，再重复上面的步骤，如果 length 退回到了起始位置，说明当前字符对应的最长公共子串为 0。</li></ol></li></ol><p>代码实现如下。</p><pre><code class="python">def next(pattern):    pattern_list = list(pattern)    next = []    next.append(0)    i = 1    lenth = 0    while i &lt; len(pattern_list):        if pattern_list[i] == pattern_list[lenth]:            lenth += 1            next.insert(i, lenth)            i += 1        else:            if lenth == 0:                next.insert(i, 0)                i += 1            else:                lenth = next[lenth - 1]    return next</code></pre><h2 id="代码实现-KMP-算法"><a href="#代码实现-KMP-算法" class="headerlink" title="代码实现 KMP 算法"></a>代码实现 KMP 算法</h2><p>求出 next 数组之后，text 中的指针只管往后走，每当遇到不匹配的字符时，只需要将 pattern 中的 p 指针移动到 p - next[p - 1] 的位置处，跳过 next[p - 1] 次比较即可。循环上面的过程，如果 p 指针走到了最后，说明匹配到结果；如果 i 指针走到了最后并且 p 指针没走到最后，则匹配失败。</p><p>Python 代码如下。</p><pre><code class="python">def kmp_match(self, text, pattern):    next = self.next(pattern)    text_list = list(text)    pattern_list = list(pattern)    i = 0    p = 0    while i &lt; len(text_list) and p &lt; len(pattern_list):        if text_list[i] == pattern_list[p]:            i += 1            p += 1        else:            p = p - next[p - 1]            if p == len(pattern_list):            return i - p    return -1 </code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>这个算法比较难理解，这次花了很长时间才算是勉强搞明白其中的原理。</p><p>可以参考一下这些讲得很不错资料：</p><ul><li><a href="https://www.cnblogs.com/Higurashi-kagome/p/18013626">图文详解 KMP 算法</a></li><li><a href="https://blog.csdn.net/qq_62982856/article/details/128003067">KMP算法——通俗易懂讲好KMP算法</a></li></ul><p>B 站上也有一些视频，结合视频动画理解匹配过程会更容易理解。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel中隔N行取一行</title>
      <link href="/2025/10/24/ad37b84c4d4b/"/>
      <url>/2025/10/24/ad37b84c4d4b/</url>
      
        <content type="html"><![CDATA[<p>先上每两行中取出一行的公式</p><p><code>INDEX(A$2:A$10, ROW(A2) * 2 - 2, 1)</code> </p><p>从 A2:A10 的区域中，获取 A2、A4、A6、A8… 的值。</p><p>事情是这样的，之前做了一个批量提交审批的功能，没有做防重复提交处理，而且每个提交人每次需要处理的数据量还挺大。这周有个人提交数据之后刷新页面发现还有未提交状态的数据加载出来，于是又全部勾选再次进行了提交。就这样，申请表中就出现了部分重复的数据。</p><p>这些重复的数据需要清理掉其中的一条，重复数据除了 id 之外，其他字段都一样，需要先找出要删除的数据 id。</p><p>先用 SQL 按业务字段 group by 出来重复的数据，导出到 Excel 中，然后按业务字段进行排序，将重复数据排到一起。</p><p>然后每两行中取出一行的 id，拿到这些 id 就去进行删除就行了。怎么每两行取取出其中的一行呢？</p><p>需要用到两个函数：INDEX(array, row_num, [column_num]) 和 ROW()。</p><p><strong>INDEX(array, row_num, [column_num])</strong></p><p>从 array 区域中获取 row_num 行 column 列 的值。</p><p><strong>ROW()</strong></p><p>获取某个单元格的行号，比如 ROW(A1) 结果就是 1。</p><p>技巧就在于怎么得到目标行号，然后放到 INDEX() 函数中。</p><table><thead><tr><th>单元格行</th><th>要获取的目标行的行号（隔1行）</th><th>对应的公式计算公式</th><th>对应的 Excel 公式</th></tr></thead><tbody><tr><td>A1</td><td>1</td><td>2 x ROW(A1) - 1</td><td>INDEX(A$1:A$10, 2 * ROW(A1) - 1, 1)</td></tr><tr><td>A2</td><td>3</td><td>2 x ROW(A2) - 1</td><td></td></tr><tr><td>A3</td><td>5</td><td>2 x ROW(A3) - 1</td><td></td></tr><tr><td>A4</td><td>7</td><td>2 x ROW(A4) - 1</td><td></td></tr><tr><td>A5</td><td>9</td><td>2 x ROW(A5) - 1</td><td></td></tr><tr><td>A6</td><td></td><td></td><td></td></tr><tr><td>A7</td><td></td><td></td><td></td></tr><tr><td>A8</td><td></td><td></td><td></td></tr><tr><td>A9</td><td></td><td></td><td></td></tr><tr><td>A10</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>单元格行</th><th>要获取的目标行的行号（隔2行）</th><th>对应的公式计算公式</th><th>对应的 Excel 公式</th></tr></thead><tbody><tr><td>A1</td><td>1</td><td>3 x ROW(A1) - 2</td><td>INDEX(A$1:A$10, 3 * ROW(A1) - 2, 1)</td></tr><tr><td>A2</td><td>4</td><td>3 x ROW(A2) - 2</td><td></td></tr><tr><td>A3</td><td>7</td><td></td><td></td></tr><tr><td>A4</td><td>10</td><td></td><td></td></tr><tr><td>A5</td><td></td><td></td><td></td></tr><tr><td>A6</td><td></td><td></td><td></td></tr><tr><td>A7</td><td></td><td></td><td></td></tr><tr><td>A8</td><td></td><td></td><td></td></tr><tr><td>A9</td><td></td><td></td><td></td></tr><tr><td>A10</td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在macOS上编译OpenJDK8</title>
      <link href="/2025/08/02/1e117267d714/"/>
      <url>/2025/08/02/1e117267d714/</url>
      
        <content type="html"><![CDATA[<p>在 MacOS 系统上编译 OpenJDK 遇到的一些问题及对应的解决方案的记录。因为 Java8 发布时间已经比较久，到现在各个操作系统很多地方都已经发生很大变化，所以小问题比较多，建议编译更好版本的 JDK，坑应该会少一些。</p><span id="more"></span><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>1、Mac 上安装 Mercurial 总是报错，没找到什么原因，所以用不了 <code>hg clone <a href="http://hg.openjdk.java.net/jdk8">http://hg.openjdk.java.net/jdk8</a></code> 这种方式。</p><p>jdk8 源码地址：<a href="http://jdk.java.net/java-se-ri/8-MR3">jdk8u41源码下载</a>  <a href="https://download.java.net/openjdk/openjdk/jdk8/promoted/b132/openjdk-8-src-b132-03_mar_2014.zip">zip文件下载</a></p><p>2、安装 freetype 和 ccache：</p><p><code>brew install freetype</code></p><p><code>brew install ccache</code></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>运行 configure：</p><pre><code class="bash">./configure --with-freetype-include=/usr/local/include/freetype2 --with-freetype-lib=/usr/local/lib/ --disable-warnings-as-errors --with-debug-level=slowdebug --with-jvm-variants=server --enable-ccache</code></pre><p><em>遇到的报错及解决方案</em></p><p>1、The C compiler (located as &#x2F;usr&#x2F;bin&#x2F;gcc) does not seem to be the required GCC compiler.</p><pre><code>打开文件common/autoconf/generated-configure.sh，搜索compiler is required注释或把报错命令改为echo即可。</code></pre><br><p>比较顺利，只遇到上面一个错误。</p><p>成功输出：</p><pre><code>........config.status: creating /Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-release/spec.shconfig.status: creating /Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-release/Makefileconfig.status: creating /Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-release/config.h====================================================A new configuration has been successfully created in/Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-releaseusing configure arguments &#39;--with-freetype-include=/usr/local/include/freetype2 --with-freetype-lib=/usr/local/lib/&#39;.Configuration summary:* Debug level:    release* JDK variant:    normal* JVM variants:   server* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64Tools summary:* Boot JDK:       openjdk version &quot;1.8.0_292&quot; OpenJDK Runtime Environment (Zulu 8.54.0.21-CA-macosx) (build 1.8.0_292-b10) OpenJDK 64-Bit Server VM (Zulu 8.54.0.21-CA-macosx) (build 25.292-b10, mixed mode)  (at /opt/java/zulu8.54.0.21-ca-jdk8.0.292-macosx_x64)* C Compiler:      version  (at /usr/bin/gcc)* C++ Compiler:    version  (at /usr/bin/g++)Build performance summary:* Cores to use:   4* Memory limit:   16384 MB* ccache status:  installed, but disabled (version older than 3.1.4)Build performance tip: ccache gives a tremendous speedup for C++ recompilations.You have ccache installed, but it is a version prior to 3.1.4. Try upgrading.</code></pre><br><p>运行 <code>make all</code></p><p>报错及解决：</p><p>1、clang: error: include path for libstdc++ headers not found; pass ‘-stdlib&#x3D;libc++’ on the command line to use the libc++ standard library instead [-Werror,-Wstdlibcxx-not-found]</p><p><a href="https://blog.csdn.net/quantum7/article/details/108466760">MAC编译OpenJDK8：clang: error: include path for libstdc++ headers not found</a></p><p><a href="https://github.com/quantum6/xcode-missing-libstdcpp.git">The missing libstdc++ headers and libraries for Xcode 10 or above.</a></p><p>2、</p><pre><code>l-op-parentheses]    if ( instr-&gt;is_ideal_branch() &amp;&amp; instr-&gt;label_position() == -1 ||         ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~/Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/hotspot/src/share/vm/adlc/archDesc.cpp:336:35: note: place parentheses around the &#39;&amp;&amp;&#39; expression to silence this warning    if ( instr-&gt;is_ideal_branch() &amp;&amp; instr-&gt;label_position() == -1 ||                                  ^         (                                                        )</code></pre><h1 id="其他可能遇到的错误"><a href="#其他可能遇到的错误" class="headerlink" title="其他可能遇到的错误"></a>其他可能遇到的错误</h1><p>&#x2F;Users&#x2F;lozhu&#x2F;Documents&#x2F;projects&#x2F;jdk12-06222165c35f&#x2F;src&#x2F;java.base&#x2F;macosx&#x2F;native&#x2F;libosxsecurity&#x2F;KeystoreImpl.m note: did not find header ‘JavaNativeFoundation.h’ in framework ‘JavaNativeFoundation’ (loaded from ‘&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX14.0.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks’)</p><p>现在的位置：&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX14.sdk</p><p>编辑 .&#x2F;make&#x2F;test&#x2F;JtregNativeJdk.gmk</p><p>BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestMainKeyWindow :&#x3D; -framework JavaVM <br>      -framework Cocoa -framework JavaNativeFoundation</p><p>修改为</p><p>BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestMainKeyWindow :&#x3D; -framework Cocoa -framework JavaNativeFoundation</p><p>编辑 .&#x2F;build&#x2F;macosx-x86_64-server-slowdebug&#x2F;spec.gmk</p><p>删除 -F &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX11.1.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Frameworks</p><p>编辑 .&#x2F;build&#x2F;macosx-x86_64-server-slowdebug&#x2F;buildjdk-spec.gmk</p><p>参考: <a href="https://www.jianshu.com/p/885c718df9de">macOS Catalina + Xcode 12 编译OpenJDK 14 错误解决</a></p><hr><p>.&#x2F;configure –with-freetype-include&#x3D;&#x2F;usr&#x2F;local&#x2F;include&#x2F;freetype2 –with-freetype-lib&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;</p><p>报错：The C compiler (located as &#x2F;usr&#x2F;bin&#x2F;gcc) does not seem to be the required GCC compiler.<br>打开文件common&#x2F;autoconf&#x2F;generated-configure.sh，搜索compiler is required<br>注释或把报错命令改为echo即可。</p><hr><p>(base) ➜  jdk8 make<br>Building OpenJDK for target ‘default’ in configuration ‘macosx-x86_64-normal-server-release’</p><p>Starting langtools</p><p>&#x2F;bin&#x2F;sh: line 0: cd: &#x2F;Users&#x2F;chenxii&#x2F;Documents&#x2F;Java&#x2F;jdk8&#x2F;jdk8&#x2F;langtools&#x2F;make: No such file or directory<br>make: *** [langtools-only] Error 1</p><p>解决方案参考：<a href="https://stackoverflow.com/questions/34703703/jdk8-build-error-langtools">https://stackoverflow.com/questions/34703703/jdk8-build-error-langtools</a></p><hr><p>执行：.&#x2F;get_source.sh</p><p>(base) ➜  jdk8 .&#x2F;get_source.sh</p><p>Repositories:  corba jaxp jaxws langtools jdk hotspot nashorn</p><pre><code>            corba:   hg clone http://hg.openjdk.java.net/jdk8/jdk8/corba corba             jaxp:   hg clone http://hg.openjdk.java.net/jdk8/jdk8/jaxp jaxp            corba:   requesting all changes</code></pre><p>Waiting 5 secs before spawning next background command.</p><p>lcm.cpp:52:35: error: ordered comparison between pointer and zero (‘address’ (aka ‘unsigned char *’) and ‘int’) </p><p>解决：编辑&#x2F;hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;opto&#x2F;lcm.cpp:52 原：if (Universe::narrow_oop_base() &gt; 0) 修改后： if (Universe::narrow_oop_base()!&#x3D; NULL) { &#x2F;&#x2F; Implies UseCompressedOops.</p><hr><p>error: ordered comparison between pointer and zero</p><p>修改openjdk&#x2F;hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;virtualspace.cpp<br>　　修改331行为<br>　　if (base() !&#x3D; 0) {</p><hr><p>fatal error: ‘JavaNativeFoundation&#x2F;JavaNativeFoundation.h’ file not found<br>#import &lt;JavaNativeFoundation&#x2F;JavaNativeFoundation.h&gt;</p><p>(base) ➜  openjdk  sudo find &#x2F; -name “<em>JavaNativeFoundation.h</em>“<br>Password:<br>find: &#x2F;Library&#x2F;Application Support&#x2F;com.apple.TCC: Operation not permitted<br>&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX11.1.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaNativeFoundation.framework&#x2F;Versions&#x2F;A&#x2F;Headers&#x2F;JavaNativeFoundation.h<br>&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX10.15.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Versions&#x2F;A&#x2F;Frameworks&#x2F;JavaNativeFoundation.framework&#x2F;Versions&#x2F;A&#x2F;Headers&#x2F;JavaNativeFoundation.h</p><p>编辑：<br>vim hotspot&#x2F;make&#x2F;bsd&#x2F;makefiles&#x2F;saproc.make 61行：<br>SALIBS &#x3D; -g -framework Foundation -F&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX10.15.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Frameworks -framework JavaNativeFoundation -framework Security -framework CoreFoundation</p><p>105行：<br>-I&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX10.15.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Headers</p><hr><p>执行：make CONF&#x3D;macosx-x86_64-normal-server-release clean<br>make CONF&#x3D;macosx-x86_64-normal-server-release install</p><p>—– Build times ——-<br>Start 2021-07-11 10:50:45<br>End   2021-07-11 10:59:52<br>00:00:16 corba<br>00:00:50 demos<br>00:01:24 docs<br>00:02:10 hotspot<br>00:01:01 images<br>00:00:09 jaxp<br>00:00:14 jaxws<br>00:02:35 jdk<br>00:00:18 langtools<br>00:00:08 nashorn</p><p>00:09:07 TOTAL</p><p>Finished building OpenJDK for target ‘all’</p><p>WARNING: You have the following ALT_ variables set:<br>ALT_PARALLEL_COMPILE_JOBS&#x3D;2<br>ALT_ variables are deprecated and will be ignored. Please clean your environment.</p><p>[1]    90140 bus error  build&#x2F;macosx-x86_64-normal-server-release&#x2F;jdk&#x2F;bin&#x2F;java -version</p><p>&#x2F;Users&#x2F;chenxii&#x2F;Documents&#x2F;Java&#x2F;jdk8&#x2F;openjdk&#x2F;build&#x2F;macosx-x86_64-normal-server-release&#x2F;jdk&#x2F;bin</p><p>？</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debian12主机无法被ping通的问题</title>
      <link href="/2025/07/28/174112c250b1/"/>
      <url>/2025/07/28/174112c250b1/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给 mini 主机安装了 Debian12 做为服务器使用，配置好 ssh 之后从 Mac 上进行远程登录，虽然连接的都是同一个Wi-Fi，但是一直连接失败。<br>ping 了一下延迟非常高，接近 100% 的丢包率。从 debian 系统 ping Mac 又是正常的，平均延迟在 10 秒左右，非常奇怪。</p><p>参考了网上很多资料这个问题都没有解决，前后浪费了好几个小时的时间。最后还是看到网上提到了 Docker，Docker 网络可能会对宿主机的网络产生影响，然后去问了 AI，根据 AI 的提示 <strong>修改 nftables 配置</strong> 解决了这个问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>允许 ICMP（ping）通过 nftables</p><pre><code class="bash"># 临时允许ICMP（立即生效，重启nftables后失效）sudo nft add rule inet filter input meta l4proto icmp accept# 若需永久生效，需写入nft配置文件sudo vim /etc/nftables.conf# 在&quot;input&quot;链中添加（确保在&quot;drop&quot;规则之前）：# chain input &#123;#   ...#   meta l4proto icmp accept  # 允许ICMP#   ...# &#125;# 重启nftables生效sudo systemctl restart nftables</code></pre><p>修改 &#x2F;etc&#x2F;nftables.conf，在 input 部分添加 <code>meta l4proto icmp accept</code>，然后重启 nftables，就能正常 ping 通了。</p><p>更早之前看到一篇博客说在 &#x2F;etc&#x2F;sysctl.conf 配置最下面新增配置 <code>net.ipv4.icmp_echo_ignore_all = 0</code>，但是在我这里没有效果。</p><h2 id="其他可能的原因"><a href="#其他可能的原因" class="headerlink" title="其他可能的原因"></a>其他可能的原因</h2><p>其他可能导致此类的问题的原因及排查方向：</p><ul><li>服务端和客户端没有连接同一个网络</li><li>服务端配置了防火墙</li><li>服务端配置忽略 ICMP 请求，就是我这种情况</li><li>服务端配置了静态 IP，IP 的网段、子网掩码长度、网关地址配置可能有误</li><li>服务端安装了 docker，服务端宿主机 IP 网段和 docker 默认配置的网络的网段有冲突，类似 172.12.0.1&#x2F;16</li><li>客户端路由表可能指向了错误的地址或者存在缓存，使用 <code>arp -a</code>查看本机路由表</li><li>客户端 DNS 配置可能有误，检查下是否可以访问百度等网站</li></ul>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debian </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debian12配置Clash代理拉取docker镜像</title>
      <link href="/2025/07/28/3bf22fba5636/"/>
      <url>/2025/07/28/3bf22fba5636/</url>
      
        <content type="html"><![CDATA[<p>debian12 中安装了 docker，由于一些为你好的原因，死活拉取不了镜像，一直超时。第一次在 Linux 环境下配置 clash，踩了一些坑，记录一下，供遇到相同问题的参考。</p><p>项目地址：<a href="https://github.com/wnlen/clash-for-linux">wnlen&#x2F;clash-for-linux</a></p><p>拉取项目</p><pre><code class="bash">git clone https://github.com/wnlen/clash-for-linux.git clash-for-linux</code></pre><p>编辑 .env 文件，将 CLASH_URL 变量替换为订阅链接，将 CLASH_SECRET 替换为自定义的密码。</p><p>运行启动脚本</p><pre><code class="bash">chmod +x start.sh./start.sh</code></pre><p>开启代理</p><pre><code class="bash">source /etc/profile.d/clash.shproxy_on</code></pre><p>检查环境变量</p><pre><code class="bash">env | grep -E &#39;http_proxy|https_proxy&#39;http_proxy=http://127.0.0.1:7890https_proxy=http://127.0.0.1:7890</code></pre><p>以上步鄹如果正常，说明服务clash程序启动成功。</p><p>重启程序</p><p>如果需要对Clash配置进行修改，请修改 <code>conf/config.yaml</code> 文件。然后运行 <code>restart.sh</code> 脚本进行重启。</p><p><strong>注意：</strong> 重启脚本 <code>restart.sh</code> 不会更新订阅信息。</p><p>关闭服务</p><pre><code class="bash">sudo bash shutdown.sh</code></pre><p>关闭代理</p><pre><code class="bash">proxy_off</code></pre><p>访问 <a href="http://ip:9090/ui">http://ip:9090/ui</a> 登录管理界面，可以选择节点等。</p><p>配置好代理之后，发现还是连不上 docker hub，拉取镜像还是超时。虽然在 clash 管理界面中配置了全局代理，但是还需要在 docker 中单独配置一下。</p><p>配置 docker 优先使用 ipv4，修改 &#x2F;etc&#x2F;daemon.json 如下：</p><pre><code class="json">&#123;  &quot;ipv6&quot;: false,  &quot;fixed-cidr-v6&quot;: &quot;2001:db8:1::/64&quot;,  # 值不影响  &quot;experimental&quot;: false&#125;</code></pre><p>然后配置 systemd：</p><pre><code class="bash">sudo mkdir -p /etc/systemd/system/docker.service.dsudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</code></pre><p>文件内容如下：</p><pre><code>[Service]Environment=&quot;HTTP_PROXY=http://127.0.0.1:7890&quot;Environment=&quot;HTTPS_PROXY=http://127.0.0.1:7890&quot;</code></pre><p>重启服务</p><pre><code class="bash">sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p>执行 <code>docker search hello-world</code> 测试一下吧！</p><p>参考：</p><ul><li><a href="https://neucrack.com/p/286">docker 设置代理，以及国内加速镜像设置</a></li><li><a href="https://github.com/wnlen/clash-for-linux">wnlen&#x2F;clash-for-linux</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debian </tag>
            
            <tag> clash </tag>
            
            <tag> 网络代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debian12中SSH免密登录不生效问题</title>
      <link href="/2025/07/24/ea31e94b21c0/"/>
      <url>/2025/07/24/ea31e94b21c0/</url>
      
        <content type="html"><![CDATA[<h2 id="问题和原因"><a href="#问题和原因" class="headerlink" title="问题和原因"></a>问题和原因</h2><p>最近有碎片化笔记的需求，比较了 Flomo 和 Memos，flomo 的免费图片存储空间只有 500M，不适合长期使用，最后选择自己部署 Memos。据说 Memos 功能增删很随意，打算部署网上比较推荐的 0.24.0。正好可以将去年买的迷你主机利用起来。</p><p>安装了 Debian12（Debian13 8 月9 日发布，必定是要第一时间升级的），配置免密登录的时候一直不成功，复制了 ssh id 还是需要输入密码，网上看到的可能的原因：.ssh 目录、authorized_keys 文件的权限等等都确认无误，在这里卡了一个小时，记录一下。</p><p>网上看到的可能的原因都确认了一遍之后，我突然想着把服务端复制过去的 ssh id 输出来对比一下，果然问题就出在这里。服务端的 authorized_keys 文件中的内容最后的邮箱地址和我现在用的邮箱地址不一致，然后查看我本机的 .ssh 目录，里面有两份 ssh key，貌似是很久之前连接 GitHub 有问题所以生成了两个 key 分开用。我用 ssh-copy-id 复制到服务端的密钥不是我本机默认的 id_rsa.pub。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>搞明白问题出在哪里之后就很简单了，先删除服务端之前传过去的 key，复制 ssh id 的时候指定密钥文件就好了：<code>ssh-copy-id -i ~/.ssh/id_rsa.pub</code> 。复制完之后再尝试登录，就直接进入系统了。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuphy AIR 60 机械键盘 F 功能键问题</title>
      <link href="/2025/07/20/2e53ac6e1a64/"/>
      <url>/2025/07/20/2e53ac6e1a64/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>目前给 Mac mini 配的是 Nuphy AIR 60 二代矮轴机械键盘，这个键盘只有 60 个键位，当初就是看中了它小巧精致的外观才选的这个键盘。最近调试程序的频率比较高，需要使用到 F 功能键，这个键盘 F1 到 F12 默认是媒体功能。认为 FN 组合对应的 F 功能键就能使用 F 功能本来是一件自然而然的事情，没想到我还是高估了这个键盘的易用性。</p><h2 id="可尝试的方法"><a href="#可尝试的方法" class="headerlink" title="可尝试的方法"></a>可尝试的方法</h2><p>在 Reddit 上看到 3 年前一位老哥也遇到了同样的问题：<a href="https://www.reddit.com/r/NuPhy/comments/w58nmi/function_keys_on_mac/">Function keys on mac</a> ，下面有好几个回答，大概有下面这几种方案。</p><h3 id="FN-Tab-F-功能键"><a href="#FN-Tab-F-功能键" class="headerlink" title="FN + Tab + F 功能键"></a>FN + Tab + F 功能键</h3><p>用 FN + Tab + F 功能键组合来实现 F 功能键（开始我还以为是 FN + Tab + F 键可以在功能键和媒体功能之间切换），但是我试了几次，没有生效，FN + Tab + F12 还是增加音量。</p><h3 id="FN-X-F-功能键"><a href="#FN-X-F-功能键" class="headerlink" title="FN + X + F 功能键"></a>FN + X + F 功能键</h3><p>这个组合键需要先在 系统设置 &gt; 键盘 &gt; 快捷键 &gt; 功能键 中开启选项“使用 F1… 功能键“选项。不过我试了这个组合键在我这里也不生效。</p><h3 id="FN-Shift-F-功能键"><a href="#FN-Shift-F-功能键" class="headerlink" title="FN + Shift + F 功能键"></a>FN + Shift + F 功能键</h3><p>这个组合键终于能用了，不过测试了几下感觉键位太多了，使用起来比较累，还是没有直接 FN + F 使用起来方便。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Reddit 上的方案都尝试了一遍，没找到理想的解决方案。</p><p>在 V2EX 上看到几个月前的一个帖子：<a href="https://www.v2ex.com/t/1094555">macOS 如何使用 标准 F1~F12 的功能</a> ，很多号称支持 Mac 的键盘，FN 功能键是残废的。不过帖子里有人提供了一个简单的方法：将键盘改回 win 模式，然后在 系统设置 &gt; 键盘 &gt; 键盘快捷键 &gt; 修饰键 中，将 Command 键映射成 Option 键，将 Option 键映射为 Command 键，至此这个问题完美解决。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="关闭显示桌面快捷键"><a href="#关闭显示桌面快捷键" class="headerlink" title="关闭显示桌面快捷键"></a>关闭显示桌面快捷键</h3><p>系统设置中默认 F11 是显示桌面的快捷键，在这里关闭：系统设置 &gt; 键盘 &gt; 快捷键 &gt; 调度中心，取消勾选显示桌面。</p><h3 id="工具网站推荐"><a href="#工具网站推荐" class="headerlink" title="工具网站推荐"></a>工具网站推荐</h3><p>在线键盘测试网站：因为尝试各种方案的时候，不知道 FN 键生效没生效，在 <a href="https://www.zfrontier.com/lab/keyboardTester">在线键盘测试</a> 这个网站中，可以实时看到自己按下了哪个键，很实用。</p><p>快捷键网：这个机械键盘的灯效、亮度、设备切换等功能需要使用 FN 加上某些快捷键来实现，又不常用，常常用到的时候需要临时翻下说明书，很麻烦。终于发现个网站：<a href="http://www.kjjw.cc/nuphy-air60/">快捷键网</a> ，这里可以查到常见厂家的机械键盘的快捷键，很实用。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械键盘 </tag>
            
            <tag> F功能键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl 学习笔记</title>
      <link href="/2025/07/19/b0a04d6723ef/"/>
      <url>/2025/07/19/b0a04d6723ef/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时接口调试都是 postman 用得比较多，图形界面，操作简单，缺点就是要多开一个软件，切换窗口。于是就想着学习一下 curl 的使用，直接在终端里调试接口。记录一下常用的请求方式及相关参数。</p><h2 id="常用的参数"><a href="#常用的参数" class="headerlink" title="常用的参数"></a>常用的参数</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET 比较简单，不需要额外的参数。</p><pre><code class="sh">curl http://localhost:8000/api/mall/users?userId=1752938209629</code></pre><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><ul><li>-X 指定请求方式</li><li>-d 指定 POST 数据，默认 Content-Type 为 application&#x2F;x-www-form-urlencoded</li><li>– json 发送 json 数据，自动设置 Content-Type 为 application&#x2F;json</li></ul><pre><code class="sh">curl -X POST --json &#39;&#123;    &quot;username&quot;: &quot;比六&quot;,    &quot;gender&quot;: &quot;F&quot;&#125;&#39; http://localhost:8000/api/mall/users</code></pre><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>PUT 请求和 POST 请求类似</p><pre><code class="sh">curl -X PUT --json &#39;&#123;    &quot;userId&quot;: 1752938209629,    &quot;username&quot;: &quot;比六1&quot;&#125;&#39; http://localhost:8000/api/mall/users</code></pre><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE 请求和 GET 请求类似</p><pre><code class="sh">curl -X DELETE http://localhost:8000/api/mall/users?userId=1752938209629</code></pre><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><ul><li>-F 发送表单，可用来上传文件</li></ul><pre><code class="sh">curl -F &quot;file=@/file&quot; http://localhost:8000/api/mall/upload</code></pre><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><ul><li>-O 使用远程文件名保存文件到本地</li><li>-o 下载文件并重命名</li></ul><pre><code class="sh">curl -O http://localhost:8000/api/mall/downloadcurl -o myfile.zip http://localhost:8000/api/mall/download</code></pre><h3 id="其他常用参数"><a href="#其他常用参数" class="headerlink" title="其他常用参数"></a>其他常用参数</h3><ul><li>-v 输出详细信息</li><li>-H 指定请求头，如 <code>-H &quot;Content-Type: application/json&quot;</code></li><li>-i 输出响应头信息</li></ul><h2 id="终端-JSON-格式化"><a href="#终端-JSON-格式化" class="headerlink" title="终端 JSON 格式化"></a>终端 JSON 格式化</h2><p>请求之后调用 python json 进行格式化：</p><pre><code class="sh">curl http://localhost:8000/api/mall/users | python3 -m json.tool</code></pre><p>如果遇到中文乱码问题，需要修改 python&#x2F;tool.py 文件： <code>/Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/json/tool.py</code></p><p>将 <code>dump_args</code> 修改如下：</p><pre><code class="python">dump_args = &#123;  &#39;sort_keys&#39;: options.sort_keys,  &#39;indent&#39;: options.indent,  # &#39;ensure_ascii&#39;: options.ensure_ascii,  &#39;ensure_ascii&#39;: False  # 修改后的配置项&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> curl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用STMP协议发送邮件</title>
      <link href="/2025/07/02/5e4bf064e5ad/"/>
      <url>/2025/07/02/5e4bf064e5ad/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近拿到一个需求，需要给一个基于jdk1.6开发的系统增加登录验证码，这个过程中需要调用第三方接口，如果第三方接口调用失败，则需发送告警邮件到指定邮箱。比较坑的是，因为系统比较老，加了 jar 包之后一直不生效，所以不能引入其他依赖，比如 mail-api 之类的。</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>只基于一些工具包做过邮件发送，趁此机会了解了一下 SMTP 协议。<br>使用 SMTP 协议发送邮件分为几个步骤：</p><ul><li>与 SMTP 服务器建立连接</li><li>身份认证（用户名和密码需通过 base64 进行编码，一般不是邮箱密码，而是一个一次性密码）</li><li>指定收件人（没有抄送人选项，抄送通过多次指定收件人实现）</li><li>邮件内容</li><li>退出</li></ul><h2 id="基于命令行"><a href="#基于命令行" class="headerlink" title="基于命令行"></a>基于命令行</h2><pre><code class="shell"># 使用 telnet 连接到 smtp 服务器&gt; telnet smtp.163.com 25Trying 240e:938:a07:6:0:14:203:45...Connected to smtp163.mail.ntes53.netease.com.Escape character is &#39;^]&#39;.220 163.com Anti-spam GT for Coremail System (163com[20141201])</code></pre><pre><code class="shell"># HELO 命令&gt; HELO stmp.163.com250 OK</code></pre><pre><code class="shell"># 认证 （dXNlcm5hbWU6 即为 username:、UGFzc3dvcmQ6 即为 password:）&gt; AUTH LOGIN334 dXNlcm5hbWU6# 输入 base64 编码后的用户名&gt; emh1bG9uZ2t1bjIwQDE2My5jb334 UGFzc3dvcmQ6# 输入 base64 编码的密码&gt; WU54UktjYVJLZFhLWmV235 Authentication successful</code></pre><p>到这里已经成功登录到服务器了。</p><pre><code class="shell"># 发件人&gt; MAIL FROM:&lt;wuyifan2@163.com&gt;250 Mail OK# 收件人&gt; RCPT TO:&lt;liyifeng29@163.com&gt;250 Mail OK# 抄送人&gt; RCPT TO:&lt;76612151@qq.com&gt;250 Mail OK</code></pre><p>邮件内容命令为 DATA，然后以 . 作为结束。</p><pre><code class="shell">&gt; DATA354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;&gt; Subject: Greet Email&gt; This is a greet email from 163!&gt; .250 Mail OK queued as gzsmtp2,PSgvCgBnBIxyor+sPBA--.4614S2 1751466502 # 已经进入发送队列# 使用 QUIT 命令退出&gt; QUIT221 ByeConnection closed by foreign host.</code></pre><p>以上就是使用命令行发送邮件的全过程，其中要注意，短时间内发送多封邮件，可能会被反垃圾邮件程序拦截掉，邮件标题、内容最好不要太随意。</p><h2 id="纯-Java-实现"><a href="#纯-Java-实现" class="headerlink" title="纯 Java 实现"></a>纯 Java 实现</h2><p>基于 socket 和 IO 流实现邮件发送，代码如下：</p><pre><code class="java">import java.io.*;  import java.net.InetSocketAddress;  import java.net.Socket;  import java.nio.charset.StandardCharsets;  import java.util.Base64;    public class MyMail &#123;      public static void sendMail(String host, int port, String username, String password,                                  String receiver, String ccReceiver, String subject, String body) throws IOException &#123;          Socket socket = new Socket();          InetSocketAddress inetSocketAddress = new InetSocketAddress(host, port);          socket.connect(inetSocketAddress);          OutputStream outputStream = socket.getOutputStream();          InputStream inputStream = socket.getInputStream();          readInputStream(inputStream);            // 发送 HELO 命令          sendCommand(outputStream, &quot;HELO &quot; + host);          readInputStream(inputStream);            // 发送 AUTH LOGIN 命令          sendCommand(outputStream, &quot;AUTH LOGIN&quot;);          readInputStream(inputStream);            sendCommand(outputStream, base64Encode(username));          readInputStream(inputStream);            sendCommand(outputStream, base64Encode(password));          readInputStream(inputStream);            sendCommand(outputStream, &quot;MAIL FROM:&lt;&quot; + username + &quot;&gt;&quot;);          readInputStream(inputStream);            sendCommand(outputStream, &quot;RCPT TO:&lt;&quot; + receiver + &quot;&gt;&quot;);          readInputStream(inputStream);            sendCommand(outputStream, &quot;RCPT TO:&lt;&quot; + ccReceiver + &quot;&gt;&quot;);          readInputStream(inputStream);            sendCommand(outputStream, &quot;DATA&quot;);          readInputStream(inputStream);            sendCommand(outputStream, &quot;Subject: &quot; + subject);          sendCommand(outputStream, body);          sendCommand(outputStream, &quot;.&quot;);          readInputStream(inputStream);            sendCommand(outputStream, &quot;QUIT&quot;);          readInputStream(inputStream);      &#125;        public static String base64Encode(String text) &#123;          return Base64.getEncoder().encodeToString(text.getBytes());      &#125;        private static void readInputStream(InputStream inputStream) throws IOException &#123;          BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));          StringBuilder response = new StringBuilder();          String line;          while ((line = bufferedReader.readLine()) != null) &#123;              response.append(line).append(&quot;\n&quot;);              if (line.length() &gt;= 3 &amp;&amp; line.charAt(3) == &#39; &#39;) &#123;                  break;              &#125;          &#125;          System.out.println(response.toString().trim());      &#125;        private static void sendCommand(OutputStream outputStream, String command) throws IOException &#123;          BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));          bufferedWriter.write(command + &quot;\r\n&quot;);          bufferedWriter.flush();      &#125;        public static void main(String[] args) &#123;          try &#123;              sendMail(&quot;smtp.163.com&quot;, 25,                      &quot;wuyifan2@163.com&quot;, &quot;YNxRKcadfsdXsdfa&quot;,                      &quot;liyifeng@163.com&quot;, &quot;123766119@qq.com&quot;,                      &quot;Greet day&quot;, &quot;Today is a great day!&quot;);          &#125; catch (Exception e) &#123;              e.printStackTrace();              System.out.println(&quot;邮件发送失败&quot;);          &#125;    &#125;  &#125;</code></pre><p>注意，认证的密码不是邮箱的密码，而是一次性授权码，在邮箱设置里开启“POP3&#x2F;SMTP服务”可以获取到。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SMTP </tag>
            
            <tag> 邮件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在idea2024中编译jdk6项目</title>
      <link href="/2025/06/23/b5802d61aac8/"/>
      <url>/2025/06/23/b5802d61aac8/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近接手一个基于 jdk6 的 jsp 老项目，需要给这个项目加点功能。在 idea2024 版中修改完代码，使用 jdk8 编译好 class 文件后替换到 tomcat 中项目跑不起来，查看日志发现有错误提示：</p><pre><code>Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: org/catalina/startup/Bootstrap : Unsupported major.minor version 52.0</code></pre><p>查看 tomcat 中配置文件后发现使用的 jdk6，之前看到 WEB-INF 下的 lib 包里有 spring-aop-3.2.2 之类的依赖，看错了看成 spring-boot-3.2.2 了还疑惑了一下老系统都升级到 Springboot3 了吗，还打算使用 jdk17 来编译，原来是看错了。</p><p>然后去查了一下，Spring3 支持 jdk6 和 jdk7，于是在 idea 上将项目的 jdk 版本切换为 jdk6 来编译，但是编译的时候 idea2024 提示最低支持的 jdk 版本是 jdk7。本来将项目使用的 jdk 版本切换成 jdk7 去编译就可以了，可是这个老项目是在云桌面里开发的，里面有 jdk6、jdk8，偏偏没有 jdk7 文件，还无法下载也无法上传。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>先是根据 AI 的提示修改了 idea 的相关配置，但还是报错，无法成功编译。</p><p>最后在 segmentfault 里看到一个同样的问题，按回复中的方法试了一下成功编译出来了，替换到 tomcat 中后功能正常。<br><a href="https://segmentfault.com/q/1010000045021590">IDEA环境配置失败，Java项目需要JDK 1.6如何解决？</a></p><p>具体的配置：</p><ol><li>打开 File - Project Structure，设置 Project SDK 为 jdk8，Project Language Level 设置为 7（保持兼容性）</li><li>将 Module 中的 jdk 版本设置成 jdk6</li><li>在 File &gt; Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Java Compiler 中，在 Additional command-line parameters 中添加：<code>-source 1.7 -target 1.7</code>，强制用高版本 jdk 编译出兼容低版本 jdk 的字节码，设置完之后就可以进行编译了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea2024 </tag>
            
            <tag> jdk6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iCloud Drive中无法创建Documents文件夹</title>
      <link href="/2025/05/03/6dedb1702b09/"/>
      <url>/2025/05/03/6dedb1702b09/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有跨设备同步文件的需求，分别试用了 OneDrive 和谷歌硬盘，还了解了 Dropbox。</p><p>OneDrive 在国内不需要 VPN 就直接能用，这点比较方便，而且手机、平板、PC 都有对应的客户端，用起来很方便。缺点就是免费容量只有 5G，随便存几个 PDF 就已经占用了大半，免费额度无法长期使用。付费的话最低 1.99 美元每个月，容量是 100G，我用不上这么多空间，一个月 15 块钱还是有点贵。</p><p>谷歌硬盘有 15G 免费空间，足够我同步常用的文件使用了，但是需要 VPN 才能使用，而且 PC 端是没有客户端的，只能用网页版，不是特别的方便，但是用来存放一些使用频率不高的文件还是挺好的。</p><p>Dropbox 免费空间只有 2G，不付费基本不能用，而且月费特别贵，根本不用考虑。</p><p>最终选择了苹果的 50G 的套餐，一个月 6 块钱，不需要第三方客户端，体验更好。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在 iCloud Drive 中想创建一个 Documents 文件夹，发现过了两秒钟，文件夹名称会自动变成“untitled folder“，先命名成”Document“，再改为”Documents“也是一样，会自动变成之前的名称“Document“。</p><p>于是想着是不是苹果把这个文件夹名称占用了，网上搜了一下，发现确实如此，准确来说是被保留了。</p><p><a href="https://www.reddit.com/r/MacOS/comments/z41468/why_cant_i_rename_or_delete_this_folder/?rdt=37650">Why can’t I rename or delete this folder?</a></p><p><a href="https://support.apple.com/en-us/109344">Add your Desktop and Documents files to iCloud Drive</a></p><p>因为在系统设置里面可以设置是否开启将 Desktop &#x2F; Documents 文件夹同步到 iCloud Drive，所以自己创建的文件夹就不能叫这个名字了。这个功能虽说很方便实用，我的 Documents 下的文件很多不需要同步，貌似也不能排除不需要同步的文件。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>两种方式：</p><ul><li>在设置里将同步 Desktop &#x2F; Documents 目录打开</li><li>选择其他名称</li></ul>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iCloud </tag>
            
            <tag> 文件夹名称占用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch入门</title>
      <link href="/2025/05/01/cf9622d9262a/"/>
      <url>/2025/05/01/cf9622d9262a/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>感谢知乎上大数据梦想家分享的入门教程，很实用。教程地址：<a href="https://zhuanlan.zhihu.com/p/358744225">从 0 到 1 学习 elasticsearch ，这一篇就够了！(建议收藏)</a></p><span id="more"></span><h2 id="Elasticsearch-是什么"><a href="#Elasticsearch-是什么" class="headerlink" title="Elasticsearch 是什么"></a>Elasticsearch 是什么</h2><p>Elasticsearch 简称 ES，是一个开源的高扩展的分布式全文检索引擎，可以近实时的存储、检索数据。ES 使用 Lucene 作为其核心来实现所有索引及搜索的功能，使用 RESTful API来隐藏 Lucene 的复杂性，从而使全文检索变得简单易用。</p><h2 id="Elasticsearch-与-Solr-的比较"><a href="#Elasticsearch-与-Solr-的比较" class="headerlink" title="Elasticsearch 与 Solr 的比较"></a>Elasticsearch 与 Solr 的比较</h2><ul><li>ES 和 Solr 都基于 Lucene。</li><li>ES 自带分布式协调管理功能，Solr 依赖 Zookeeper 进行分布式管理。</li><li>ES 只支持 json 格式，Solr 支持 json、XML、CSV 等格式。</li><li>ES 很多功能需要第三方插件支持，Solr 本身功能较为丰富。</li><li>ES 建立索引快，适用于实时性较强的场景；Solr 查询较快，但是索引更新慢，适用于电商等查询较多的场景。</li></ul><h2 id="Elastisearch-安装及启动"><a href="#Elastisearch-安装及启动" class="headerlink" title="Elastisearch 安装及启动"></a>Elastisearch 安装及启动</h2><p>从官网 <a href="https://www.elastic.co/downloads/elasticsearch">Download Elasticsearch</a> 根据平台选择对应的版本进行下载。下载完成后将下载压缩包文件拷贝到安装路径（~&#x2F;.opt&#x2F;elasticsearch）并解压，在该目录下新建 data 目录用于存储索引。</p><p>修改配置文件 $ES_HOME&#x2F;config&#x2F;elasticsearch.yml 文件：</p><pre><code class="yaml">cluster.name: demo-elasticsearchnode.name: node01path.data: ~/.opt/elasticsearch/datapath.logs: ~/.opt/elasticsearch/logsnetwork.host: 0.0.0.0host.port: 9200cluster.initial_master_nodes: [&quot;node01&quot;]xpack.security.enabled: falsexpack.security.enrollment.enabled: falsexpack.security.http.ssl:    enabled: false    keystore.path: certs/http.p12</code></pre><p>修改 jvm.options 文件中的配置：</p><pre><code>-Xms1g-Xmx1g</code></pre><p>据说 Elasticsearch 不允许使用 root 用户操作，需要新建 elsearch 用户组及 elsearch 用户进行集群的操作，但是我在 macOS 上直接使用 admin 账号操作没遇到什么问题，并且在 macOS 上新建用户组和用户和 Linux 上的命令不通用，所以跳过新建用户这一步。</p><p>启动 es：</p><pre><code class="sh">bin/elasticsearch</code></pre><p>启动之后，可以访问 <a href="http://localhost:9200/">http://localhost:9200</a> 查看。如果没有关闭 xpack.security.http.ssl 配置的话，需要访问 <a href="https://localhost:9200。">https://localhost:9200。</a></p><p>这个页面会返回一些集群相关的信息：</p><pre><code class="json">&#123;  &quot;name&quot; : &quot;node01&quot;,  &quot;cluster_name&quot; : &quot;demo-elasticsearch&quot;,  &quot;cluster_uuid&quot; : &quot;2pFl_UiuQFSwsGD-6CTtMQ&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;9.0.0&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;tar&quot;,    &quot;build_hash&quot; : &quot;112859b85d50de2a7e63f73c8fc70b99eea24291&quot;,    &quot;build_date&quot; : &quot;2025-04-08T15:13:46.049795831Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;10.1.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;8.18.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;8.0.0&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;</code></pre><h2 id="Elasticsearch-head-安装"><a href="#Elasticsearch-head-安装" class="headerlink" title="Elasticsearch-head 安装"></a>Elasticsearch-head 安装</h2><p>Elasticsearch-head 是 Elasticsearch 的一个开源的图形化界面，在 GitHub 上可以获取：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a>。将源码克隆到本地，然后通过 npm 启动。</p><pre><code class="sh">cd elasticsearch-headnpm install npm start</code></pre><p>因为跨域的原因，需要在 elasticsearch.yml 中增加相关的配置：</p><pre><code class="yaml">http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;</code></pre><p>修改配置后，重启 es，访问 <a href="http://localhost:9100，就能看到">http://localhost:9100，就能看到</a> es-head 页面了，可以查看索引和查询之类的功能。</p><h2 id="kibana-安装"><a href="#kibana-安装" class="headerlink" title="kibana 安装"></a>kibana 安装</h2><h3 id="kibana-安装-1"><a href="#kibana-安装-1" class="headerlink" title="kibana 安装"></a>kibana 安装</h3><p>kibana 可以将更友好的展示和分析 es 的数据。在 es 官网可以进行下载：<a href="https://www.elastic.co/cn/downloads/kibana%EF%BC%8C%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8Ckibana">https://www.elastic.co/cn/downloads/kibana，要注意的是，kibana</a> 的版本需要和 es 的版本保持一致。</p><p>下载后放到指定路径 ~&#x2F;.opt&#x2F;kibana 并解压。</p><p>修改配置文件：~&#x2F;.opt&#x2F;kibana&#x2F;config&#x2F;kibana.yml：</p><pre><code class="yaml">server.port: 5601server.host: 0.0.0.0elasticsearch.hosts: [&quot;http://localhost:9200&quot;]elasticsearch.username: &quot;elsearch&quot;elasticsearch.password: &quot;elsearch&quot;</code></pre><p>通过 <code>bin/kibana</code> 启动 kibana。</p><p>访问 <a href="http://localhost:5601/">http://localhost:5601</a> 访问 kibana 页面。</p><h3 id="ik-分词器安装"><a href="#ik-分词器安装" class="headerlink" title="ik 分词器安装"></a>ik 分词器安装</h3><p>原下载地址：<a href="https://github.com/infinilabs/analysis-ik/releases%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%B7%B2%E4%B8%8D%E5%9C%A8">https://github.com/infinilabs/analysis-ik/releases，但是最新版本已不在</a> GitHub 更新，需要到 <a href="https://release.infinilabs.com/analysis-ik/stable/">https://release.infinilabs.com/analysis-ik/stable/</a> 进行下载。</p><p>下载后拷贝到 $ES_HOME&#x2F;plugins&#x2F;ik 路径下，重启 kibana。</p><p>测试分词器（最少切分）：梦想家</p><pre><code>GET _analyze&#123;    &quot;analyzer&quot;: &quot;ik_smart&quot;,    &quot;text&quot;: &quot;梦想家&quot;&#125;</code></pre><p>最细粒度切分：梦想家、梦想、想家</p><pre><code>GET _analyze&#123;    &quot;analyzer&quot;: &quot;ik_max_word&quot;,    &quot;text&quot;: &quot;梦想家&quot;&#125;</code></pre><p>分词器自定义词典：</p><p>在 $ES_HOME&#x2F;plugins&#x2F;ik&#x2F;config 路径下新建文件 my.dic，写入需要被识别成一个词的词。</p><p>修改 IKAnalyzer.cfg.xml 文件：</p><pre><code class="xml">&lt;properties&gt;   &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!-- 用户可以在这里配置自己的扩展字典 --&gt;   &lt;entry key=&quot;ext_dict&quot;&gt;my.dic&lt;/entry&gt; &lt;!-- 用户可以在这里配置自己的扩展停止词字典 --&gt;   &lt;entry key=&quot;ext_stopwords&quot;&gt;&lt;/entry&gt;&lt;/properties&gt;</code></pre><p>修改完成保存并重启 es，此时 my.dic 中的词就不会再被切分。</p><h2 id="Elasticsearch-基本操作"><a href="#Elasticsearch-基本操作" class="headerlink" title="Elasticsearch 基本操作"></a>Elasticsearch 基本操作</h2><p>创建文档：</p><pre><code class="json">PUT /test1/_doc/1&#123;  &quot;name&quot;: &quot;大数据梦想家&quot;,  &quot;age&quot;: 24&#125;</code></pre><p>创建成功后可在 es-head 页面浏览数据标签页中看到对应的索引 test1。</p><p>创建索引并指定字段类型：</p><pre><code class="json">PUT /test2&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;name&quot;: &#123;        &quot;type&quot;: &quot;text&quot;      &#125;,      &quot;age&quot;: &#123;        &quot;type&quot;: &quot;long&quot;      &#125;,      &quot;birthday&quot;: &#123;        &quot;type&quot;: &quot;date&quot;      &#125;    &#125;  &#125;&#125;</code></pre><p>查看刚才创建的索引：</p><p><code>GET /test2</code></p><p>向该索引增加数据：</p><pre><code class="json">PUT /test2/_doc/1&#123;  &quot;name&quot;: &quot;大数据梦想家&quot;,  &quot;age&quot;: 21,  &quot;birthday&quot;: &quot;2020-01-01&quot;&#125;</code></pre><p>查看文档信息：</p><pre><code class="json">GET /test2/_doc/1</code></pre><p>修改文档：</p><pre><code class="json">PUT /test2/_update/1&#123;  &quot;doc&quot;: &#123;    &quot;name&quot;: &quot;大数据梦想家1&quot;  &#125;&#125;</code></pre><p>修改文档也可以使用和新增同样的方式进行，但是会覆盖元来的数据，不推荐使用。</p><p>删除文档：</p><pre><code>DELETE /test2/_doc/1</code></pre><p>删除索引：</p><pre><code>DELETE /test2</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>先增加几条测试数据：</p><pre><code class="json">PUT /demo/_doc/1&#123;    &quot;name&quot;: &quot;爱丽丝&quot;,    &quot;age&quot;: 21,    &quot;desc&quot;: &quot;在最美的年华，做最好的自己&quot;,    &quot;tags&quot;: [&quot;技术宅&quot;, &quot;温暖&quot;, &quot;思维活跃&quot;]&#125;PUT /demo/_doc/2&#123;    &quot;name&quot;: &quot;鲍勃&quot;,    &quot;age&quot;: 25,    &quot;desc&quot;: &quot;逍遥自在&quot;,    &quot;tags&quot;: [&quot;交友&quot;, &quot;理性&quot;]&#125;PUT /demo/_doc/3&#123;    &quot;name&quot;: &quot;露西&quot;,    &quot;age&quot;: 30,    &quot;desc&quot;: &quot;人越讨厌明天，就睡得越晚&quot;,    &quot;tags&quot;: [&quot;社会&quot;, &quot;科学&quot;]&#125;PUT /demo/_doc/4&#123;    &quot;name&quot;: &quot;Alice爱学Python&quot;,    &quot;age&quot;: 21,    &quot;desc&quot;: &quot;人生苦短，我用Python&quot;,    &quot;tags&quot;: [&quot;好学&quot;, &quot;勤奋刻苦&quot;]&#125;PUT /demo/_doc/5&#123;    &quot;name&quot;: &quot;Alice爱学Java&quot;,    &quot;age&quot;: 18,    &quot;desc&quot;: &quot;技术成就自我&quot;,    &quot;tags&quot;: [&quot;思维敏捷&quot;, &quot;喜欢学习&quot;]&#125;</code></pre><p>按 name 查找，返回 name、age、desc 列，结果按 age 升序排序，从第二个结果开始返回1个结果：</p><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;name&quot;: &quot;爱丽丝&quot;    &#125;,    &quot;_source&quot;: [&quot;name&quot;, &quot;age&quot;, &quot;desc&quot;],    &quot;sort&quot;: [&#123;        &quot;age&quot;: &#123;          &quot;order&quot;: &quot;asc&quot;        &#125;      &#125;],    &quot;from&quot;: 1,    &quot;size&quot;: 1  &#125;&#125;</code></pre><p>OR：</p><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;should&quot;: [        &#123;          &quot;match&quot;: &#123;            &quot;name&quot;: &quot;爱丽丝&quot;          &#125;        &#125;,        &#123;          &quot;match&quot;: &#123;            &quot;age&quot;: 25          &#125;        &#125;      ]    &#125;  &#125;&#125;</code></pre><p>AND：</p><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123;          &quot;match&quot;: &#123;            &quot;name&quot;: &quot;爱丽丝&quot;          &#125;        &#125;      ],      &quot;filter&quot;: [        &#123;          &quot;range&quot;: &#123;            &quot;age&quot;: &#123;              &quot;lte&quot;: 18            &#125;          &#125;        &#125;      ]    &#125;  &#125;&#125;</code></pre><p>按多个值查找：</p><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;tags&quot;: &quot;男 学习&quot;    &#125;  &#125;&#125;</code></pre><p>text 字段在查找时会被先被分词然后再进行查找，keyword 类型的字段会进行精确查找，不会被分词。</p><p>对结果进行高亮显示：</p><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;name&quot;: &quot;鲍勃&quot;    &#125;  &#125;,  &quot;highlight&quot;: &#123;    &quot;pre_tags&quot;: &quot;&lt;b class=&#39;key&#39; style=&#39;color: red&#39;&gt;&quot;,    &quot;post_tags&quot;: &quot;&lt;/b&gt;&quot;,    &quot;fields&quot;: &#123;      &quot;name&quot;: &#123;&#125;    &#125;  &#125;&#125;</code></pre><p>关于分词：</p><ul><li>term：不经过分词，直接查询精确的值</li><li>match：会使用分词器解析</li></ul><pre><code class="json">GET /demo/_search&#123;  &quot;query&quot;: &#123;    &quot;term&quot;: &#123;      &quot;name&quot;: &quot;爱&quot;    &#125;  &#125;&#125;</code></pre><h3 id="查看健康信息"><a href="#查看健康信息" class="headerlink" title="查看健康信息"></a>查看健康信息</h3><pre><code class="json">GET _cat/health</code></pre><pre><code class="json">GET _cat/indicies?v</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS提示无法验证APP是否包含恶意软件无法打开</title>
      <link href="/2025/05/01/8d39054318ab/"/>
      <url>/2025/05/01/8d39054318ab/</url>
      
        <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>下载了elasticsearch，运行 bin&#x2F;elasticsearch 启动时提示“macOS cannot verify that this app if free from Malware”，弹窗上只有“Move to trash”和“Cancel”两个选项，打开系统安全性设置页面，点击”Open Anyway“按钮也没有反应，然后再次运行时又重复上述现象。</p><span id="more"></span><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在知乎上找到的方法： <a href="https://www.zhihu.com/question/412633194">macOS无法验证此App不包含恶意软件，怎么解决？</a>，成功解决该问题。</p><p>两种方法：</p><ol><li>安装 Ctrl 键打开该软件，我这里不管用。</li><li>运行 <code>sudo xattr -r -d com.apple.quarantine 应用路径</code> 然后再打开软件，成功解决问题。</li></ol><p>总共有3个软件提示打不开，运行第二种方法中的命令之后，全部成功打开。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac mini连接Wi-Fi网速慢的问题</title>
      <link href="/2025/03/09/adc08664fe0f/"/>
      <url>/2025/03/09/adc08664fe0f/</url>
      
        <content type="html"><![CDATA[<p>趁着有补贴新买了一个 M4 芯片的 Mac mini，第一次连接 Wi-Fi 使用就发现网速很慢，浏览器打开一个网页要花几十秒的时间，经常打开失败。</p><p>但是旁边的 2020 款 Macbook Pro 就很流畅，下载速度也很快。</p><p>怀疑是 Mac mini 的问题，于是在网上搜了一圈没找到什么有用的信息。</p><p>第二天晚上在 B 站上搜了一下这个问题，找到一个同样问题的视频，他提供了两个解决方案：</p><ul><li>将路由器的 Wi-Fi 频宽从 160MHz 改为 80MHz</li><li>不要将 Mac mini 放置在金属表面</li></ul><p>我才意识到我是将 Mac mini 放在显示器的支撑板上的，刚好是一块金属板。于是将其放到桌子上，果然网速就正常了！</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac mini </tag>
            
            <tag> Wi-Fi网速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10远程桌面无法连接</title>
      <link href="/2024/12/08/9028c7deaa0a/"/>
      <url>/2024/12/08/9028c7deaa0a/</url>
      
        <content type="html"><![CDATA[<p>八九月份的时候买了一个大唐 AMD R7 5800H 的 mini 主机，装的是 Win10 专业版系统。平时 mini 主机只是辅助跑一些软件，所以主要是通过 Mac 上安装 Windows APP Preview 这个微软官方的远程连接软件连接远程桌面使用，不用连接键盘、鼠标、显示器，省事的同时还不占地方。</p><p>不过远程桌面频繁连接失败，一直提示找不到主机请检查IP地址和主机名是否正确，只有偶尔几次能连上。中间有几次提示连接失败，通过更新了 Windows APP Preview 这个连接软件后就连接成功了。</p><span id="more"></span><p>之前还有显示器，连不上就接上显示器、键盘鼠标可以操作一下，上个月搬家显示器也没了，就一个月没开过机。最近网上查了一些资料了解到视频采集卡这个东西，买了一个回来，通过采集卡将笔记本做为主机的显示器确实可行，于是想彻底解决一下远程桌面经常连不上的问题。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>Mac 上通过 Windows APP Preview 连接 Win10 主机时提示找不到对应的机器，无法连接。更奇怪的是，连接成功之后，断开，然后紧接着再重连就会提示找不到机器。</p><h2 id="排除可能的原因"><a href="#排除可能的原因" class="headerlink" title="排除可能的原因"></a>排除可能的原因</h2><p>根据网上类似问题的帖子，仔细检查了下面这个可能的原因：</p><ol><li>Windows 机器上远程桌面服务没在运行（Win + R 输入 services.msc 打开服务列表，确认 Remote Desktop Service 正在运行，并将启动方式改成了自动，在 cmd 中通过 <code>netstat -ano</code> 确认 3389 端口在监听状态）</li><li>Windows 防火墙的问题（确认公有、专用网络防火墙都是关闭状态，且防火墙中“允许应用程序通过防火墙”的配置中远程桌面选项已经勾选）</li><li>目标主机的 IP 地址错误（确认 IP 地址无误且已设置静态 IP，IP 地址与当前机器在一个网段，且两台机器的网关地址和 DNS 都设置成路由器的网关地址）</li><li>远程登陆用户不在允许远程登陆用户列表中（确认当前登陆已设置允许远程登陆）</li><li>组策略</li></ol><p>上面的可能原因都确排查了一遍，问题依然存在。</p><p>然后发现两台机器可以 ping 通，但是 telnet 连接 3389 端口连接不上，提示：No route to host，又跟着某篇帖子的提示检查了两台机器的 hosts 文件，在 hosts 文件中设置好了本机 IP 地址，但是问题依然存在。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在几次重启的过程中发现一个规律，<strong>每次连接远程桌面之前，在 Mac 上先断开 WiFi 再重连 WiFi，就能连上远程桌面</strong>。怀疑是加入网络的顺序影响连接结果，于是我又验证了一下机器启动顺序对连接结果的影响，发现无论是先启动主机，再启动 Mac还先启动 Mac，再启动主机，连接前都要重连一下网络才能连上，很奇怪的现象，原因不明。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows远程桌面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2.0 授权</title>
      <link href="/2024/12/05/7ee81ff978a5/"/>
      <url>/2024/12/05/7ee81ff978a5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OAuth2.0 是目前互联网上比较流行的授权方式，GitHub、掘金等大部分网站都采用 OAuth 的方式支持第三方账号登陆。之前工作中有接触到但是没有深入的去了解其中的机制，这里根据原理做了一个小的 demo，源码地址：<a href="https://github.com/lozhu20/oauth2-demo">OAuth2-demo</a></p><span id="more"></span><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>OAuth2.0 标准出自 RFC6749 <a href="https://www.rfc-editor.org/rfc/rfc6749">The OAuth 2.0 Authorization Framework</a>，英文文档，有兴趣的可以研读一下。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>比如我们遇到了一个错误，在 <a href="https://cn.bing.com/">必应</a> 上搜索了一下，出现的第一个结果来自 CSDN，点进去读了几行网站弹出登陆页面，登陆框底部就有“其他登陆方式”的选项，可以使用 QQ、微博、百度、GitHub、开放原子开源基金会等账号登陆，这样可以不用在将密码提供给 CSDN 的情况下，授权 CSDN 访问第三方网站上的用户名等一些受密码保护的信息。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>授权流程中几个角色：</p><ul><li>资源所有者：就是用户自己</li><li>客户端：即当前使用的网站和程序</li><li>认证服务器：存放受保护的数据的网站提供的身份认证</li><li>资源服务器：存放受保护的数据的网站</li></ul><h2 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h2><p>OAuth2.0 定义了 4 种授权方式，各种方式之间部分流程略有不同。</p><ol><li>授权码模式</li><li>简化模式（相较于授权模式少了一步获取授权码的流程）</li><li>密码模式（直接将密码提供给客户端，一般不用）</li><li>客户端模式</li></ol><p>授权码模式是最流程最严密的模式，用得应该是最多的。</p><h2 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h2><p>以授权码模式为例：</p><pre><code class="mermaid">sequenceDiagram    客户端-&gt;&gt;资源所有者: 请求授权    资源所有者--&gt;客户端: 同意授权    客户端-&gt;&gt;认证服务器: 1️⃣ 请求授权码    认证服务器--&gt;客户端: 2️⃣ 授权码    客户端-&gt;&gt;认证服务器: 3️⃣ 使用授权码请求 token    认证服务器--&gt;客户端: 4️⃣ token    客户端-&gt;&gt;资源服务器: 5️⃣ 访问被保护的资源    资源服务器--&gt;客户端: 6️⃣ 被保护的资源</code></pre><p>为了简化流程，demo 中省略了一个资源服务器。假设客户端运行在 <a href="http://localhost:8001/client%EF%BC%8C%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%90%E8%A1%8C%E5%9C%A8">http://localhost:8001/client，认证服务端运行在</a> <a href="http://localhost:8000/auth-server%EF%BC%8C%E6%AF%8F%E4%B8%80%E6%AD%A5%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8000/auth-server，每一步具体操作如下：</a></p><h3 id="请求授权码"><a href="#请求授权码" class="headerlink" title="请求授权码"></a>请求授权码</h3><p><strong>请求地址</strong></p><p><a href="http://localhost:8000/auth-server/authorize?response_type=code&client_id=oauth2demo-client&redirect_uri=http://localhost:8001/client/index&scope=username&state=oauth2demo-client-state">http://localhost:8000/auth-server/authorize?response_type=code&amp;client_id=oauth2demo-client&amp;redirect_uri=http://localhost:8001/client/index&amp;scope=username&amp;state=oauth2demo-client-state</a></p><p><strong>参数解释</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>response_type</td><td>授权类型为授权码模式</td></tr><tr><td>client_id</td><td>客户端 id</td></tr><tr><td>redirect_uri</td><td>服务端返回授权码时的重定向地址</td></tr><tr><td>scope</td><td>授权范围</td></tr><tr><td>state</td><td>客户端状态，自定义值</td></tr></tbody></table><h3 id="认证服务器重定向至登陆"><a href="#认证服务器重定向至登陆" class="headerlink" title="认证服务器重定向至登陆"></a>认证服务器重定向至登陆</h3><p>认证服务器重定向至本站登陆页面使用账号密码进行认证。</p><h3 id="认证服务器返回授权码"><a href="#认证服务器返回授权码" class="headerlink" title="认证服务器返回授权码"></a>认证服务器返回授权码</h3><p>认证服务器登陆成功后给客户端返回授权码。</p><p><strong>请求地址</strong></p><p><a href="http://localhost:8001/client/index?code=XXX&state=YYYY">http://localhost:8001/client/index?code=XXX&amp;state=YYYY</a></p><p><strong>参数解释</strong></p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>code</td><td>认证服务器生成的授权码</td></tr><tr><td>state</td><td>客户端请求授权码时发过去的客户端状态，原值返回，作用不明</td></tr></tbody></table><h3 id="客户端使用授权码请求-token"><a href="#客户端使用授权码请求-token" class="headerlink" title="客户端使用授权码请求 token"></a>客户端使用授权码请求 token</h3><p><strong>请求地址</strong></p><p><a href="http://localhost:8000/auth-server/token?grant_type=authorization_code&code=XXX&redirect_uri=http://localhost:8001/client/index&client_id=oauth2demo-client&client_secret=oauth2demo-client-secret">http://localhost:8000/auth-server/token?grant_type=authorization_code&amp;code=XXX&amp;redirect_uri=http://localhost:8001/client/index&amp;client_id=oauth2demo-client&amp;client_secret=oauth2demo-client-secret</a></p><p><strong>参数解释</strong></p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>code</td><td>认证服务器返回的授权码，只能使用一次</td></tr></tbody></table><h3 id="认证服务器返回-token"><a href="#认证服务器返回-token" class="headerlink" title="认证服务器返回 token"></a>认证服务器返回 token</h3><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>access_token</td><td>token</td></tr><tr><td>token_type</td><td>token 类型</td></tr><tr><td>expires_in</td><td>多久后过期，秒为单位</td></tr><tr><td>refresh_token</td><td>刷新令牌</td></tr><tr><td>scope</td><td>授权范围</td></tr></tbody></table><h3 id="客户端使用-token-请求资源"><a href="#客户端使用-token-请求资源" class="headerlink" title="客户端使用 token 请求资源"></a>客户端使用 token 请求资源</h3><p>客户端获取到 token 之后就拿着 token 向资源服务器访问对应的资源了。</p><p><strong>请求地址</strong></p><p><a href="http://localhost:8000/auth-server/userInfo?accessToken=XXX">http://localhost:8000/auth-server/userInfo?accessToken=XXX</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx index转发导致首页无法访问</title>
      <link href="/2024/08/21/f19dd61c13b1/"/>
      <url>/2024/08/21/f19dd61c13b1/</url>
      
        <content type="html"><![CDATA[<p>这两天在部署短链接服务，配置 nginx 规则卡了一晚上，特此记录一下。</p><span id="more"></span><h2 id="Nginx-配置及现象"><a href="#Nginx-配置及现象" class="headerlink" title="Nginx 配置及现象"></a>Nginx 配置及现象</h2><p>我的需求是如果访问域名，那么直接展示首页，如果访问其他路径，则转发到后端服务。conf.d&#x2F;default.conf 文件内容如下：</p><pre><code>server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    location = / &#123;        root   /usr/share/nginx/html;        index  index.html;    &#125;    location / &#123;        proxy_pass http://192.168.0.10:8000;    &#125;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;&#125;</code></pre><p>根据 nginx 中 &#x3D; 精确匹配的优先级最好的原则，直接访问域名会匹配到第一个规则。但是实际上请求还是会被转发到后端，非常困惑。</p><p>途中发现一个很好用的 nginx 规则验证工具：<a href="https://nginx.viraptor.info/">Nginx location match tester</a> 。每次修改规则之后要重启，再发起请求然后看结果来验证配置是否符合预期，非常繁琐，这个工具网站可以省去这些步骤，极大的提高效率。</p><h2 id="问题和解决方案"><a href="#问题和解决方案" class="headerlink" title="问题和解决方案"></a>问题和解决方案</h2><p>今天上午认真的读了一篇写得挺不错的 nginx 配置教程：<a href="https://segmentfault.com/a/1190000022315733">一文理清 nginx 中的 location 配置（系列一）</a>，在文章下的评论中看到有人贴出了自己遇到的问题，配置以及问题描述都和我遇到的问题一致，原来是 index 转发的问题。</p><p>如下配置，访问网站根目录并没有正常显示，而是返回了 404：</p><pre><code>location = / &#123;    index index.html;&#125;location / &#123;    return 404;&#125;</code></pre><blockquote><p><a href="https://segmentfault.com/u/sufan_5911192950d85"><strong>苏凡</strong></a>：<a href="https://segmentfault.com/u/chengxiansen">@诚先森</a> 了解下 index 指令，请求被内部重定向到第二个 location 了</p><p>回复 2022-09-16</p></blockquote><p>直接访问域名 <a href="http://localhost,会匹配到第一个规则,但是/">http://localhost，会匹配到第一个规则，但是</a> index 指令并不是找到文件之后就直接用了，而是会重新发起内部重定向，相当于从客户端发起 <a href="http://localhost/index.html">http://localhost/index.html</a> ，所以会再一次匹配 location 配置。</p><p>知道原因之后就简单了，在配置中增加配置 location &#x3D; &#x2F;index.html 让 nginx 内部重定向到首页就好了：</p><pre><code>server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #access_log  /var/log/nginx/host.access.log  main;    location = / &#123;        root   /usr/share/nginx/html;        index  index.html;    &#125;        location = /index.html &#123;        root /usr/share/nginx/html;    &#125;    location / &#123;        proxy_pass http://192.168.0.10:8000;    &#125;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;&#125;</code></pre><p>重启 nginx 之后，就能实现直接访问域名展示首页，其余请求转发至后端服务了。</p><p>不得不提一点，Nginx location match tester 这个工具无法看出被转发的情况，比如上面的 index，它只会告诉你匹配到第一条规则了，但实际后面还有更多的动作，结果就是在这个工具里看到的结果与实际验证不一致，被这个点误导了很久。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nginx.viraptor.info/">Nginx location match tester</a></p><p><a href="https://segmentfault.com/a/1190000022315733">一文理清 nginx 中的 location 配置（系列一）</a></p><p><a href="https://www.cnblogs.com/kukudi/p/11496315.html">nginx中的index配置</a></p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> index转发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在MacOS系统中制作Windows10启动盘</title>
      <link href="/2024/07/31/289c198310f3/"/>
      <url>/2024/07/31/289c198310f3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天新买了一个迷你主机准系统，需要自己安装系统，手边只有 Mac，第一次在 MacOS 系统下制作启动盘，踩了一些坑，记录一下。</p><span id="more"></span><h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><h3 id="下载-Windows10-ISO-镜像文件"><a href="#下载-Windows10-ISO-镜像文件" class="headerlink" title="下载 Windows10 ISO 镜像文件"></a>下载 Windows10 ISO 镜像文件</h3><p>官方镜像文件下载地址：<a href="https://www.microsoft.com/zh-cn/software-download/windows10ISO">下载 Windows 10 光盘映像（ISO 文件）</a></p><h3 id="安装工具软件"><a href="#安装工具软件" class="headerlink" title="安装工具软件"></a>安装工具软件</h3><p>因为个别文件超大，不能直接复制，因此需要安装一个工具软件进行分割复制：</p><pre><code>brew install wimlib</code></pre><h3 id="开始制作"><a href="#开始制作" class="headerlink" title="开始制作"></a>开始制作</h3><p>将 U 盘插入后，使用 diskutil 命令查看磁盘：</p><pre><code>diskutil list</code></pre><p>我这里 U 盘的路径是 &#x2F;dev&#x2F;disk3。</p><p>将 U 盘格式化：</p><pre><code>diskutil eraseDisk MS-DOS &quot;WIN10&quot; GPT /dev/disk3</code></pre><p>GPT 和 MBR 格式的区别以及怎么选择，可以查查资料，一般来说，新硬件直接选择 GPT 就好了。</p><p>U 盘格式化完成之后，挂载 Windows ISO 镜像文件：</p><pre><code>hdiutil mount ~/Downloads/Win10_1903_V1_English_x64.iso</code></pre><p>挂载完成之后，开始将文件复制到 U 盘，这个过程非常耗时，我的 usb2.0 U 盘，花了整整一夜才复制完成。</p><pre><code>rsync -vha --exclude=sources/install.wim /Volumes/CCCOMA_X64FRE_EN-US_DV9/* /Volumes/WIN10</code></pre><p>此过程可能会持续两三个小时，如果是 usb3.0 应该会快得多。完成之后再单独复制超大文件：</p><pre><code>wimlib-imagex split /Volumes/CCCOMA_X64FRE_EN-US_DV9/sources/install.wim /Volumes/WIN10/sources/install.swm 3800</code></pre><p>此过程可能会持续几个小时，在完成之前进度可能一直是 0%，不要中止。它将使用 wimlib 将 install.wim 文件拆分为 2 个小于 4 GB 的文件（命令中使用 3.8 GB），然后将它们复制到你的 USB。完成后，你可以在 Finder 中从 Mac 中弹出 USB 和 ISO 镜像文件。</p><pre><code>diskutil eject /dev/disk3</code></pre><p>全部完成后就可以正常进行安装了。</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>系统安装时遇到“windows无法对计算机进行启动到下一个安装阶段的准备”的错误，无法进行后续步骤。查了一下，这是因为 U 盘和系统安装的硬盘中都存在 EFI 分区导致，需要将 U 盘中的 EFI 分区删除。</p><p>在安装过程进行到选择安装分区时，使用 <code>shift + F10</code> 打开命令行工具，然后输入 <code>diskpart</code> 进入磁盘工具：</p><p>查看磁盘：</p><pre><code>list disk</code></pre><p>找到安装系统的硬盘，记下硬盘编号，我这里 U 盘的磁盘编号是 1。</p><p>选中磁盘：</p><pre><code>select disk 1</code></pre><p>查看磁盘分区：</p><pre><code>list partition</code></pre><p>我这里看到两个分区，其中第一个只有 200M，应该就是对应的 EFI 分区，编号为 0。</p><p>选择磁盘分区：</p><pre><code>select partition 0</code></pre><p>删除对应的磁盘分区：</p><pre><code>delete partition override</code></pre><p>看到 successful 就表示删除成功了。此时关闭命令行工具，选择对应的安装分区，就可以继续进行安装了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.freecodecamp.org/chinese/news/how-make-a-windows-10-usb-using-your-mac-build-a-bootable-iso-from-your-macs-terminal/">如何使用 Mac 制作 Windows 10 U 盘启动盘</a></p><p><a href="https://juejin.cn/post/7289717829732745275">使用mac制作U盘启动盘并安装win10系统</a></p><p><a href="https://www.huluohu.com/posts/446/#">Windows中如何删除移动硬盘上的EFI系统分区</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 系统安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Pages博客加速</title>
      <link href="/2024/07/14/b35164b5de3a/"/>
      <url>/2024/07/14/b35164b5de3a/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这堵破墙，害人不浅！</p><p>这两天发现博客打开速度非常慢，有时甚至出现无法访问的情况，更新点东西想确认下效果点半天进不去，很是恼火😫！明明一个中文网站，在英文区秒开，到了中文区却无法访问，真的很烦。</p><p>于是想着找找有什么免费的方案可以优化一下，找了半天，发现很多人也被这个问题困扰，但是好像除了花钱，没看到什么有用的解决方案。</p><span id="more"></span><h2 id="一些解决方案"><a href="#一些解决方案" class="headerlink" title="一些解决方案"></a>一些解决方案</h2><h3 id="付费CDN"><a href="#付费CDN" class="headerlink" title="付费CDN"></a>付费CDN</h3><p>最简单粗暴的办法就是购买国内的 CDN 服务，比如阿里云、又拍云之类的厂商。这种方案的缺点首先就是流量需要花钱，如果网站被攻击，可能会损失惨重，需要时时留心；其次就是域名需要备案才能使用，比如 .day、.la 这些域名就别想了，根本无法备案。</p><h3 id="CloudFlare"><a href="#CloudFlare" class="headerlink" title="CloudFlare"></a>CloudFlare</h3><p>将网站托管到 CloudFlare 就能获得 CF 免费的 CDN 加速服务，但是效果也不好。我目前就是用的 CF，有人说去掉 CF，直接裸连 github.io 会更快，我试了暂停 CF，直接访问不了了。现在套上 CF 至少还要比裸连稳定性高得多。</p><h3 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h3><p>前两年可以使用 Vercel 进行加速，不过好景不长，随着用的人越来越多，现在 Vercel 也被拿下了。貌似推出了专门针对墙国的域名，但是看反馈也是寄。</p><h3 id="杀杀杀杀杀杀杀！"><a href="#杀杀杀杀杀杀杀！" class="headerlink" title="杀杀杀杀杀杀杀！"></a>杀杀杀杀杀杀杀！</h3><p>就真的没有办法了吗？不妨问问聪明的老祖宗！</p><p><img src="https://images.happy365.day/24/07/14101048_b1bcf50acfbff627fcb2b29bd726edcc.jpeg" alt="0"></p><p><img src="https://images.happy365.day/24/07/14100206_1.jpg" alt="1"></p><p><img src="https://images.happy365.day/24/07/14100227_2.jpg" alt="2"></p><p><img src="https://images.happy365.day/24/07/14100243_3.jpg" alt="3"></p><p><img src="https://images.happy365.day/24/07/14100257_4.jpg" alt="4"></p><p><img src="https://images.happy365.day/24/07/14100333_5.jpg" alt="5"></p><p><img src="https://images.happy365.day/24/07/14100348_6.jpg" alt="6"></p><p><img src="https://images.happy365.day/24/07/14100409_7.jpg" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>码乙己GitCode</title>
      <link href="/2024/07/12/d2ab6908393c/"/>
      <url>/2024/07/12/d2ab6908393c/</url>
      
        <content type="html"><![CDATA[<p>GitCode 一上线，所有搞 IT 的人便都看着它笑，有的叫道，“GitCode，你的反馈中心里又添上新 issue 了！”</p><p>它不回答，对用户说，“最低0.47元&#x2F;天解锁提交记录，VIP享 9 折下载代码。”便排出 50 个全球开源项目推荐。</p><p>他们又故意的高声嚷道，“你一定又偷了人家的代码了！”</p><p>GitCode 睁大眼睛说，“你怎么这样凭空污人清白……”</p><p>“什么清白？我前天亲眼见你偷了 GitHub 家的代码，被追着骂。”</p><p>GitCode 便涨红了脸，额上的青筋条条绽出，争辩道，“复制代码仓库不能算偷……剽窃代码！……技术人的事，能算偷么？”</p><p>接连便是难懂的话，什么“国产自研”，什么“开放、协作、自由”之类，引得众人都哄笑起来：互联网上充满了快活的空气。</p>]]></content>
      
      
      <categories>
          
          <category> 日志随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitCode </tag>
            
            <tag> 剽窃 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的LVM存储管理</title>
      <link href="/2024/07/12/1bf0cfdf8615/"/>
      <url>/2024/07/12/1bf0cfdf8615/</url>
      
        <content type="html"><![CDATA[<h2 id="学习视频推荐"><a href="#学习视频推荐" class="headerlink" title="学习视频推荐"></a>学习视频推荐</h2><p>下面这个视频逻辑清晰，还带有操作实例，非常推荐！</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=855524671&bvid=BV1rL4y1w7wS&cid=762502859&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><span id="more"></span><h2 id="什么是-LVM"><a href="#什么是-LVM" class="headerlink" title="什么是 LVM"></a>什么是 LVM</h2><p>LVM 是 Logical Volume Manager （逻辑卷管理）的缩写，是 Linux 系统中替代传统基于分区磁盘管理的一种磁盘管理方式。逻辑卷和分区的概念差不多。使用磁盘分区的方式不方便对磁盘容量进行调整，而 LVM 很好的解决了这个问题。</p><p>LVM 包含 3 个概念：</p><ul><li>Physical Volume - 物理卷</li><li>Volume Group - 卷组（相当于传统概念中的磁盘）</li><li>Logical Volume - 逻辑卷（相当于传统概念中的分区）</li></ul><p>这 3 个概念的关系如下：</p><p><img src="https://images.happy365.day/24/07/12021838_LVM-constructure.png" alt="结构"></p><p>物理卷相当于存储空间的一个池子，一个物理卷下可以包含多个卷组，一个卷组下可以又有多个逻辑卷。要想对卷组扩容，卷组所属的物理卷必须要有足够的容量，逻辑卷同理。</p><h2 id="Ubuntu-中的-LVM"><a href="#Ubuntu-中的-LVM" class="headerlink" title="Ubuntu 中的 LVM"></a>Ubuntu 中的 LVM</h2><p>在安装 ubuntu-20.04.6 桌面系统时记得勾选使用 LVM 的选项。这里遇到个问题，使用 LVM 这个选项只在默认分区下存在，自定义分区时无法指定。</p><p><img src="https://images.happy365.day/24/07/12022126_Snipaste20240711235848.png" alt="LVM选项"></p><p>这是本文中使用的安装系统默认分区方案：</p><p><img src="https://images.happy365.day/24/07/12022231_Snipaste20240711235946.png" alt="Snipaste_2024-07-11_23-59-46"></p><p>可以看到安装系统会默认创建 vgubuntu 这个卷组，然后在这个卷组下创建 root 和 swap_1 两个逻辑卷。</p><h2 id="查看-LVM-信息"><a href="#查看-LVM-信息" class="headerlink" title="查看 LVM 信息"></a>查看 LVM 信息</h2><p>使用 <code>pvdisplay</code> 查看物理卷信息：</p><pre><code>root@kitazono-vm:/home/kitazono# pvdisplay  --- Physical volume ---  PV Name               /dev/sda5  # 卷组名称  VG Name               vgubuntu  # 物理卷的容量  PV Size               &lt;19.50 GiB / not usable 0  Allocatable           yes  PE Size               4.00 MiB  Total PE              4991  Free PE               9  Allocated PE          4982  PV UUID               SopW29-0S5M-Oe33-ROb5-aBh7-aZXI-RECLAP</code></pre><p>PV Size 为物理卷容量，约等于 PE Size x Total PE &#x2F; 1024。</p><p>使用 <code>vgddisplay</code> 查看卷组信息：</p><pre><code>root@kitazono-vm:/home/kitazono# vgdisplay  --- Volume group ---  VG Name               vgubuntu  System ID  Format                lvm2  Metadata Areas        1  Metadata Sequence No  3  VG Access             read/write  VG Status             resizable  MAX LV                0  Cur LV                2  Open LV               2  Max PV                0  Cur PV                1  Act PV                1  VG Size               &lt;19.50 GiB  PE Size               4.00 MiB  Total PE              4991  Alloc PE / Size       4982 / 19.46 GiB  Free  PE / Size       9 / 36.00 MiB  VG UUID               qJWlI2-TS2u-fWHT-DSXz-b60b-6Ka1-mA1XfN</code></pre><p>本系统中包含一个卷组，就是安装系统时安装程序创建的默认卷组 vgubuntu，VG Size 约等于 20G。</p><p>使用 <code>lvdisplay</code> 查看逻辑卷：</p><pre><code>root@kitazono-vm:/home/kitazono# lvdisplay  --- Logical volume ---  LV Path                /dev/vgubuntu/root  LV Name                root  VG Name                vgubuntu  LV UUID                dCd3rn-q4yn-QHY1-RWfI-dFkt-XzE6-bIthjK  LV Write Access        read/write  LV Creation host, time ubuntu, 2024-07-11 23:59:14 +0800  LV Status              available  # open                 1  LV Size                &lt;18.51 GiB  Current LE             4738  Segments               1  Allocation             inherit  Read ahead sectors     auto  - currently set to     256  Block device           253:0  --- Logical volume ---  LV Path                /dev/vgubuntu/swap_1  LV Name                swap_1  VG Name                vgubuntu  LV UUID                Ru88TV-pasS-4TWp-DjGM-klC7-csnm-A3Pagb  LV Write Access        read/write  LV Creation host, time ubuntu, 2024-07-11 23:59:14 +0800  LV Status              available  # open                 2  LV Size                976.00 MiB  Current LE             244  Segments               1  Allocation             inherit  Read ahead sectors     auto  - currently set to     256  Block device           253:1</code></pre><p>本系统包含 &#x2F;dev&#x2F;vgubuntu&#x2F;root 和 &#x2F;dev&#x2F;vgubuntu&#x2F;swap_1 两个逻辑卷，还可以看到两个逻辑卷的容量、所属卷组等信息。</p><p>使用 <code>lsblk</code> 查看磁盘结构：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# lsblkNAME                MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTloop0                 7:0    0     4K  1 loop /snap/bare/5loop1                 7:1    0  63.3M  1 loop /snap/core20/1828loop2                 7:2    0 346.3M  1 loop /snap/gnome-3-38-2004/119loop3                 7:3    0  91.7M  1 loop /snap/gtk-common-themes/1535loop4                 7:4    0    46M  1 loop /snap/snap-store/638loop5                 7:5    0  49.9M  1 loop /snap/snapd/18357sda                   8:0    0    20G  0 disk├─sda1                8:1    0   512M  0 part /boot/efi├─sda2                8:2    0     1K  0 part└─sda5                8:5    0  19.5G  0 part  ├─vgubuntu-root   253:0    0  18.5G  0 lvm  /  └─vgubuntu-swap_1 253:1    0   976M  0 lvm  [SWAP]sr0                  11:0    1  1024M  0 rom</code></pre><p>其中 sda 对应磁盘，sda5 对应物理卷PV，vgubuntu 对应卷组，vgubuntu-root 和 vgubuntu-swap_1 对应该卷组下的两个逻辑卷。</p><h2 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h2><p>新增一块 10G 的硬盘，然后重新启动虚拟机。使用 <code>lsblk</code> 查看磁盘：</p><pre><code class="sh">kitazono@kitazono-vm:~$ lsblkNAME                MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTloop0                 7:0    0  63.3M  1 loop /snap/core20/1828loop1                 7:1    0 346.3M  1 loop /snap/gnome-3-38-2004/119loop2                 7:2    0     4K  1 loop /snap/bare/5loop3                 7:3    0  91.7M  1 loop /snap/gtk-common-themes/1535loop4                 7:4    0    46M  1 loop /snap/snap-store/638loop5                 7:5    0  49.9M  1 loop /snap/snapd/18357sda                   8:0    0    20G  0 disk├─sda1                8:1    0   512M  0 part /boot/efi├─sda2                8:2    0     1K  0 part└─sda5                8:5    0  19.5G  0 part  ├─vgubuntu-root   253:0    0  18.5G  0 lvm  /  └─vgubuntu-swap_1 253:1    0   976M  0 lvm  [SWAP]# 新增的磁盘sdb                   8:16   0    10G  0 disksr0                  11:0    1   4.1G  0 rom  /media/kitazono/Ubuntu 20.04.6 LTS amd64</code></pre><p>10G 的新硬盘 sdb 已经识别到了。</p><p>使用 <code>pvcreate</code> 创建物理卷：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# pvcreate /dev/sdb  Physical volume &quot;/dev/sdb&quot; successfully created.</code></pre><p>查看物理卷：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# pvdisplay  --- Physical volume ---  PV Name               /dev/sda5  VG Name               vgubuntu  PV Size               &lt;19.50 GiB / not usable 0  Allocatable           yes  PE Size               4.00 MiB  Total PE              4991  Free PE               9  Allocated PE          4982  PV UUID               SopW29-0S5M-Oe33-ROb5-aBh7-aZXI-RECLAP  &quot;/dev/sdb&quot; is a new physical volume of &quot;10.00 GiB&quot;  --- NEW Physical volume ---  PV Name               /dev/sdb  VG Name  PV Size               10.00 GiB  Allocatable           NO  PE Size               0  Total PE              0  Free PE               0  Allocated PE          0  PV UUID               a8qLmc-naFa-LVXu-zABA-kOfU-Wp9j-AV0L4r</code></pre><p>&#x2F;dev&#x2F;sdb 就是刚才创建的物理卷。</p><p>然后使用 <code>vgextend</code> 给 vgubuntu 卷组增加容量：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# vgextend vgubuntu /dev/sdb  Volume group &quot;vgubuntu&quot; successfully extended</code></pre><p>查看卷组详情：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# vgdisplay  --- Volume group ---  VG Name               vgubuntu  System ID  Format                lvm2  Metadata Areas        2  Metadata Sequence No  4  VG Access             read/write  VG Status             resizable  MAX LV                0  Cur LV                2  Open LV               2  Max PV                0  Cur PV                2  Act PV                2  VG Size               29.49 GiB  PE Size               4.00 MiB  Total PE              7550  Alloc PE / Size       4982 / 19.46 GiB  Free  PE / Size       2568 / 10.03 GiB  VG UUID               qJWlI2-TS2u-fWHT-DSXz-b60b-6Ka1-mA1XfN</code></pre><p>VG size  已经从 20G 增加到了约 30G，Free PE &#x2F; Size 容量就是新增的磁盘容量。卷组扩容成功之后就可以给逻辑卷扩容了。</p><p>先查看一下 root 卷的容量：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# lsblkNAME                MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTloop0                 7:0    0  63.3M  1 loop /snap/core20/1828loop1                 7:1    0 346.3M  1 loop /snap/gnome-3-38-2004/119loop2                 7:2    0     4K  1 loop /snap/bare/5loop3                 7:3    0  91.7M  1 loop /snap/gtk-common-themes/1535loop4                 7:4    0    46M  1 loop /snap/snap-store/638loop5                 7:5    0  49.9M  1 loop /snap/snapd/18357sda                   8:0    0    20G  0 disk├─sda1                8:1    0   512M  0 part /boot/efi├─sda2                8:2    0     1K  0 part└─sda5                8:5    0  19.5G  0 part  ├─vgubuntu-root   253:0    0  18.5G  0 lvm  /  └─vgubuntu-swap_1 253:1    0   976M  0 lvm  [SWAP]sdb                   8:16   0    10G  0 disksr0                  11:0    1   4.1G  0 rom  /media/kitazono/Ubuntu 20.04.6 LTS amd64</code></pre><p>vgubuntu-root 此时容量为 18.5G，下面对 vgubuntu-root 扩容 5G。</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# lvextend -L +5g /dev/vgubuntu/root  Size of logical volume vgubuntu/root changed from &lt;18.51 GiB (4738 extents) to &lt;23.51 GiB (6018 extents).  Logical volume vgubuntu/root successfully resized.</code></pre><p>再次查看磁盘容量情况：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# lsblkNAME                MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTloop0                 7:0    0  63.3M  1 loop /snap/core20/1828loop1                 7:1    0 346.3M  1 loop /snap/gnome-3-38-2004/119loop2                 7:2    0     4K  1 loop /snap/bare/5loop3                 7:3    0  91.7M  1 loop /snap/gtk-common-themes/1535loop4                 7:4    0    46M  1 loop /snap/snap-store/638loop5                 7:5    0  49.9M  1 loop /snap/snapd/18357sda                   8:0    0    20G  0 disk├─sda1                8:1    0   512M  0 part /boot/efi├─sda2                8:2    0     1K  0 part└─sda5                8:5    0  19.5G  0 part  ├─vgubuntu-root   253:0    0  23.5G  0 lvm  /  └─vgubuntu-swap_1 253:1    0   976M  0 lvm  [SWAP]sdb                   8:16   0    10G  0 disk└─vgubuntu-root     253:0    0  23.5G  0 lvm  /sr0                  11:0    1   4.1G  0 rom  /media/kitazono/Ubuntu 20.04.6 LTS amd64</code></pre><p>此时 vgubuntu-root 容量增加到了 23.5 G。</p><p>此时如果使用 <code>df -h</code> 查看磁盘容量，会发现 root 分区的容量没有变化，调整逻辑卷的大小之后还要调整文件系统的大小？</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# df -hFilesystem                 Size  Used Avail Use% Mounted onudev                       1.9G     0  1.9G   0% /devtmpfs                      388M  1.9M  386M   1% /run# 此时还是 19G/dev/mapper/vgubuntu-root   19G  6.6G   11G  39% /tmpfs                      1.9G     0  1.9G   0% /dev/shmtmpfs                      5.0M  4.0K  5.0M   1% /run/locktmpfs                      1.9G     0  1.9G   0% /sys/fs/cgroup/dev/loop0                  64M   64M     0 100% /snap/core20/1828/dev/loop1                 347M  347M     0 100% /snap/gnome-3-38-2004/119/dev/loop2                 128K  128K     0 100% /snap/bare/5/dev/loop3                  92M   92M     0 100% /snap/gtk-common-themes/1535/dev/loop5                  50M   50M     0 100% /snap/snapd/18357/dev/loop4                  46M   46M     0 100% /snap/snap-store/638/dev/sda1                  511M  4.0K  511M   1% /boot/efitmpfs                      388M   20K  388M   1% /run/user/1000/dev/sr0                   4.1G  4.1G     0 100% /media/kitazono/Ubuntu 20.04.6 LTS amd64</code></pre><p>使用 resize2fs 调整文件系统的大小，如果是 xfs 格式的话使用 xfs_grows。</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# resize2fs /dev/vgubuntu/rootresize2fs 1.45.5 (07-Jan-2020)Filesystem at /dev/vgubuntu/root is mounted on /; on-line resizing requiredold_desc_blocks = 3, new_desc_blocks = 3The filesystem on /dev/vgubuntu/root is now 6162432 (4k) blocks long.</code></pre><p>此时再查看磁盘容量：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# df -hFilesystem                 Size  Used Avail Use% Mounted onudev                       1.9G     0  1.9G   0% /devtmpfs                      388M  1.9M  386M   1% /run# 容量已经调整为 23 G/dev/mapper/vgubuntu-root   23G  6.6G   16G  30% /tmpfs                      1.9G     0  1.9G   0% /dev/shmtmpfs                      5.0M  4.0K  5.0M   1% /run/locktmpfs                      1.9G     0  1.9G   0% /sys/fs/cgroup/dev/loop0                  64M   64M     0 100% /snap/core20/1828/dev/loop1                 347M  347M     0 100% /snap/gnome-3-38-2004/119/dev/loop2                 128K  128K     0 100% /snap/bare/5/dev/loop3                  92M   92M     0 100% /snap/gtk-common-themes/1535/dev/loop5                  50M   50M     0 100% /snap/snapd/18357/dev/loop4                  46M   46M     0 100% /snap/snap-store/638/dev/sda1                  511M  4.0K  511M   1% /boot/efitmpfs                      388M   20K  388M   1% /run/user/1000/dev/sr0                   4.1G  4.1G     0 100% /media/kitazono/Ubuntu 20.04.6 LTS amd64</code></pre><p>可以看到 root 分区的容量已经调整为 23G。</p><h2 id="创建自己的卷组和逻辑卷"><a href="#创建自己的卷组和逻辑卷" class="headerlink" title="创建自己的卷组和逻辑卷"></a>创建自己的卷组和逻辑卷</h2><p>新增一块 5G 的硬盘然后重启虚拟机，然后查看磁盘详情：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# lsblkNAME                MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTloop0                 7:0    0     4K  1 loop /snap/bare/5loop1                 7:1    0  63.3M  1 loop /snap/core20/1828loop2                 7:2    0 346.3M  1 loop /snap/gnome-3-38-2004/119loop3                 7:3    0  91.7M  1 loop /snap/gtk-common-themes/1535loop4                 7:4    0    46M  1 loop /snap/snap-store/638loop5                 7:5    0  49.9M  1 loop /snap/snapd/18357sda                   8:0    0    20G  0 disk├─sda1                8:1    0   512M  0 part /boot/efi├─sda2                8:2    0     1K  0 part└─sda5                8:5    0  19.5G  0 part  ├─vgubuntu-root   253:0    0  23.5G  0 lvm  /  └─vgubuntu-swap_1 253:1    0   976M  0 lvm  [SWAP]sdb                   8:16   0    10G  0 disk└─vgubuntu-root     253:0    0  23.5G  0 lvm  /# 新增的 5G 硬盘sdc                   8:32   0     5G  0 disksr0                  11:0    1   4.1G  0 rom  /media/kitazono/Ubuntu 20.04.6 LTS amd64</code></pre><p>然后创建物理卷：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# pvcreate /dev/sdc  Device vgkitazono not found.  Physical volume &quot;/dev/sdc&quot; successfully created.</code></pre><p>查看物理卷信息：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# pvdisplay  --- Physical volume ---  PV Name               /dev/sda5  VG Name               vgubuntu  PV Size               &lt;19.50 GiB / not usable 0  Allocatable           yes (but full)  PE Size               4.00 MiB  Total PE              4991  Free PE               0  Allocated PE          4991  PV UUID               SopW29-0S5M-Oe33-ROb5-aBh7-aZXI-RECLAP  --- Physical volume ---  PV Name               /dev/sdb  VG Name               vgubuntu  PV Size               10.00 GiB / not usable 4.00 MiB  Allocatable           yes  PE Size               4.00 MiB  Total PE              2559  Free PE               1288  Allocated PE          1271  PV UUID               a8qLmc-naFa-LVXu-zABA-kOfU-Wp9j-AV0L4r  &quot;/dev/sdc&quot; is a new physical volume of &quot;5.00 GiB&quot;  --- NEW Physical volume ---  PV Name               /dev/sdc  VG Name  PV Size               5.00 GiB  Allocatable           NO  PE Size               0  Total PE              0  Free PE               0  Allocated PE          0  PV UUID               eSW0dn-QU6U-V8vj-KcG1-S6IF-bVBb-M34S4O</code></pre><p>第三部分就是刚才创建成功的物理卷。然后再创建新的卷组：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# vgcreate vgkitazono /dev/sdc  Volume group &quot;vgkitazono&quot; successfully created</code></pre><p>查看卷组信息：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# vgdisplay  --- Volume group ---  VG Name               vgkitazono  System ID  Format                lvm2  Metadata Areas        1  Metadata Sequence No  1  VG Access             read/write  VG Status             resizable  MAX LV                0  Cur LV                0  Open LV               0  Max PV                0  Cur PV                1  Act PV                1  VG Size               &lt;5.00 GiB  PE Size               4.00 MiB  Total PE              1279  Alloc PE / Size       0 / 0  Free  PE / Size       1279 / &lt;5.00 GiB  VG UUID               JP7PLR-a3Iy-w4ox-zDDO-3eiR-MoPG-zoznfl  --- Volume group ---  VG Name               vgubuntu  System ID  Format                lvm2  Metadata Areas        2  Metadata Sequence No  5  VG Access             read/write  VG Status             resizable  MAX LV                0  Cur LV                2  Open LV               2  Max PV                0  Cur PV                2  Act PV                2  VG Size               29.49 GiB  PE Size               4.00 MiB  Total PE              7550  Alloc PE / Size       6262 / 24.46 GiB  Free  PE / Size       1288 / 5.03 GiB  VG UUID               qJWlI2-TS2u-fWHT-DSXz-b60b-6Ka1-mA1XfN</code></pre><p>可以看到 vgkitazono 已经创建成功，容量约为 5G。接下来创建一个 2G 的逻辑卷：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# lvcreate -L 2g -n kitazono vgkitazono  Logical volume &quot;kitazono&quot; created.</code></pre><p>-L 参数指定容量大小，-n 指定逻辑卷名称，最后一个参数是卷组名。</p><p>查看此时的逻辑卷信息：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# lvdisplay  --- Logical volume ---  LV Path                /dev/vgkitazono/kitazono  LV Name                kitazono  VG Name                vgkitazono  LV UUID                UviiLK-ywm0-jTxP-ZtoR-IbDB-M7f3-DCIoah  LV Write Access        read/write  LV Creation host, time kitazono-vm, 2024-07-12 01:56:52 +0800  LV Status              available  # open                 0  LV Size                2.00 GiB  Current LE             512  Segments               1  Allocation             inherit  Read ahead sectors     auto  - currently set to     256  Block device           253:2  --- Logical volume ---  LV Path                /dev/vgubuntu/root  LV Name                root  VG Name                vgubuntu  LV UUID                dCd3rn-q4yn-QHY1-RWfI-dFkt-XzE6-bIthjK  LV Write Access        read/write  LV Creation host, time ubuntu, 2024-07-11 23:59:14 +0800  LV Status              available  # open                 1  LV Size                &lt;23.51 GiB  Current LE             6018  Segments               3  Allocation             inherit  Read ahead sectors     auto  - currently set to     256  Block device           253:0  --- Logical volume ---  LV Path                /dev/vgubuntu/swap_1  LV Name                swap_1  VG Name                vgubuntu  LV UUID                Ru88TV-pasS-4TWp-DjGM-klC7-csnm-A3Pagb  LV Write Access        read/write  LV Creation host, time ubuntu, 2024-07-11 23:59:14 +0800  LV Status              available  # open                 2  LV Size                976.00 MiB  Current LE             244  Segments               1  Allocation             inherit  Read ahead sectors     auto  - currently set to     256  Block device           253:1</code></pre><p>可以看到逻辑卷 &#x2F;dev&#x2F;vgkitazono&#x2F;kitazono 已经创建成功，容量为 2G。</p><p>逻辑卷创建成功之后还需要使用 <code>mkfs.ex4</code> 进行格式化：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# mkfs.ext4 /dev/vgkitazono/kitazonomke2fs 1.45.5 (07-Jan-2020)Creating filesystem with 524288 4k blocks and 131072 inodesFilesystem UUID: 0f25921a-4f2f-4f37-b014-b89fb79f7aebSuperblock backups stored on blocks:    32768, 98304, 163840, 229376, 294912Allocating group tables: doneWriting inode tables: doneCreating journal (16384 blocks): doneWriting superblocks and filesystem accounting information: done</code></pre><p>格式化成功。</p><p>创建挂载点：</p><pre><code class="sh">mkdir /mnt/kitazono</code></pre><p>将刚才创建的逻辑卷挂载到挂载点：</p><pre><code class="sh">mount /dev/vgkitazono/kitazono /mnt/kitazono</code></pre><p>挂载完成后再查看磁盘容量信息：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# df -hFilesystem                       Size  Used Avail Use% Mounted onudev                             1.9G     0  1.9G   0% /devtmpfs                            388M  1.9M  386M   1% /run/dev/mapper/vgubuntu-root         23G  6.6G   16G  30% /tmpfs                            1.9G     0  1.9G   0% /dev/shmtmpfs                            5.0M  4.0K  5.0M   1% /run/locktmpfs                            1.9G     0  1.9G   0% /sys/fs/cgroup/dev/loop0                       128K  128K     0 100% /snap/bare/5/dev/loop1                        64M   64M     0 100% /snap/core20/1828/dev/loop2                       347M  347M     0 100% /snap/gnome-3-38-2004/119/dev/loop3                        92M   92M     0 100% /snap/gtk-common-themes/1535/dev/loop4                        46M   46M     0 100% /snap/snap-store/638/dev/loop5                        50M   50M     0 100% /snap/snapd/18357/dev/sda1                        511M  4.0K  511M   1% /boot/efitmpfs                            388M   20K  388M   1% /run/user/1000/dev/sr0                         4.1G  4.1G     0 100% /media/kitazono/Ubuntu 20.04.6 LTS amd64# 刚才挂载的逻辑卷/dev/mapper/vgkitazono-kitazono  2.0G   24K  1.8G   1% /mnt/kitazono</code></pre><p>2G 容量的逻辑卷就可以正常使用了。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除命令：</p><ul><li>lvremove</li><li>vgremove</li><li>pvremove</li></ul><p>卸载逻辑卷：</p><pre><code class="sh">umount /mnt/kitazono/</code></pre><p>删除逻辑卷：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# lvremove /dev/vgkitazono/kitazonoDo you really want to remove and DISCARD active logical volume vgkitazono/kitazono? [y/n]: y  Logical volume &quot;kitazono&quot; successfully removed</code></pre><p>删除卷组：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# vgremove vgkitazono  Volume group &quot;vgkitazono&quot; successfully removed</code></pre><p>删除物理卷：</p><pre><code class="sh">root@kitazono-vm:/home/kitazono# pvremove /dev/sdc  Labels on physical volume &quot;/dev/sdc&quot; successfully wiped.</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://linuxhandbook.com/lvm-guide/">The Complete Beginner’s Guide to LVM in Linux</a></p><p><a href="https://cn.linux-console.net/?p=19893">Linux 中 LVM 的完整初学者指南 [带实践]</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> LVM </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>骑行_深圳至北京_PART5_安阳至北京</title>
      <link href="/2024/06/19/d083b2636358/"/>
      <url>/2024/06/19/d083b2636358/</url>
      
        <content type="html"><![CDATA[<h2 id="DAY19"><a href="#DAY19" class="headerlink" title="DAY19"></a>DAY19</h2><p><strong>河南省安阳市文峰区 至 河北省邢台市内丘县 142.7km</strong></p><p>早上 5 点半出发，太阳快要爬过安阳市图书馆，万达广场即将迎来今天的第一缕阳光。</p><p>出安阳市的途中，遇到很多跑步、骑车运动的人，大多数是老人，也有几个中年男女。才 6 点不到，很难想象他们的生活是多么自律。</p><span id="more"></span><p>经过一个小镇子的时候买了一杯豆浆和一根油条。到了铜雀三台景区遇到一个凉亭吃的时候才发现豆浆很难喝，感觉不是大豆做的豆浆，豆浆里全是渣子难以下咽，尝了一口剩下的全倒掉了。</p><p>八点不到就在不知不觉中进入了河北省邯郸市，因为走的通村小路，没有看到省界的标志。</p><p>今天经过磁县、邯郸市区、沙河市、邢台市区，最终到达内丘县。原本昨天晚上计划的终点是邢台市，但因为今天出发早，行程也很顺利，上午到11点半就骑到了沙河市行程共 90 多公里，于是将目的地改为了内丘县，正好匀一下后面徐水区到北京站的距离。</p><p>看今天进城前最后一块里程碑，到北京还剩 418 公里，争取大后天可以骑完全程。</p><p>5:29，快要爬上安阳市图书馆的朝阳。</p><p><img src="https://images.happy365.day/24/06/20223915_309EE306-C517-4CB2-AD66-6065A3830C22_1_102_o.jpeg" alt="太阳"></p><p>清晨的田野。</p><p><img src="https://images.happy365.day/24/06/20224001_D5BA0F2A-9B80-4D01-853F-3266CAD91A38_1_102_o.jpeg" alt="田野"></p><p>林间小路，路上已经有很多骑着电瓶车、三轮车出门干活的人。</p><p><img src="https://images.happy365.day/24/06/20224037_8A349E1D-02A0-467D-BBDA-8AEE1732E3B6_1_102_o.jpeg" alt="林间小路"></p><p>这小段路路况非常好，很难想象不出几百米，就是一段骑不走的烂路。</p><p><img src="https://images.happy365.day/24/06/20224105_F4A5B946-9696-467A-9565-BE3780DF5925_1_102_o.jpeg" alt="路"></p><p>叹口气，没想到大清早就要开始推车了。</p><p><img src="https://images.happy365.day/24/06/20224159_5CAAC5F6-75CD-41D6-A838-D0C9CE76FDC6_1_102_o.jpeg" alt="烂路"></p><p>幸好没几百米烂路，过了两村庄就是好路了。不知不觉间，已是河北省邯郸市境内了。</p><p><img src="https://images.happy365.day/24/06/20224305_F9A41D1A-31F5-44B5-942C-E8D5E38B1ED8_1_102_o.jpeg" alt="烂路"></p><p>7:16，路过“铜雀三台遗址公园”，没开门，是不是因为还太早了。</p><p><img src="https://images.happy365.day/24/06/20224359_94CE344B-6751-4823-B22F-745034EE01F4_1_102_o.jpeg" alt="铜雀三台遗址公园"></p><p>经过磁县。这条路没有经过城区，所以这一路上没见到什么人，路旁也很少有村庄。</p><p><img src="https://images.happy365.day/24/06/20224523_E02EE544-09C3-42BE-B588-89588794811B_1_102_o.jpeg"></p><p>9:32，经过邯郸站。邯郸学步，小学就知道的成语。以前上学坐绿皮车去北京，没少经过这里。</p><p><img src="https://images.happy365.day/24/06/20224709_CDC905DC-4991-4B4E-B093-13B2172EC117_1_102_o.jpeg" alt="邯郸站"></p><p>9:53，第一次在路标上看到北京，距离北京 440 公里。</p><p><img src="https://images.happy365.day/24/06/20224802_AA7ACD96-B174-4679-A004-55EAC477DEFE_1_102_o.jpeg" alt="路标"></p><p>有意思的村庄名：黄粱梦。</p><p><img src="https://images.happy365.day/24/06/20224852_1DCA84A9-F642-48ED-BC97-4A2CE8AFF762_1_102_o.jpeg" alt="黄粱梦"></p><p>邯郸市永年区的加油站，加油站员工一顿会员注册、来回转账操作，送了包卫生纸，热死了想要水还不给。</p><p><img src="https://images.happy365.day/24/06/20224949_3C4CF63D-884E-4A73-AFB3-C57E92E22CBE_1_102_o.jpeg" alt="活动送的卫生纸"></p><p>中午的太阳🔥能把人融化🫠，晒！</p><p><img src="https://images.happy365.day/24/06/20225122_646728F1-7EAF-47E5-9A44-5DFCCD8CEE0B_1_102_o.jpeg" alt="热"></p><p>11:13，进入邢台市。</p><p><img src="https://images.happy365.day/24/06/20225153_B9217F36-C4F6-48AA-8DB2-C3851B029F0F_1_102_o.jpeg" alt="邢台市界"></p><p>11:30，进入邢台市沙河市区，午饭是淮南牛肉汤，这家店很干净，老板娘人也很好，大方有礼，店里也很整洁。</p><p><img src="https://images.happy365.day/24/06/20225240_11C51692-CAA2-4F90-A3CD-EBD85740A60C_1_102_o.jpeg" alt="午饭"></p><p><img src="https://images.happy365.day/24/06/20225342_8965B1D2-5768-462F-A5AE-9DE69B674044_1_102_o.jpeg" alt="午饭"></p><p><img src="https://images.happy365.day/24/06/20225402_DD5D4A75-0171-453D-A32E-D263AE95A3B3_1_102_o.jpeg" alt="午饭"></p><p>这气温要热死了🔥</p><p><img src="https://images.happy365.day/24/06/20225534_88FF6C6D-DC6F-4B46-97C6-6F845EC60627_1_102_o.jpeg" alt="热"></p><p>找了个小亭子眯到 14:40 才出发，有个学生在里面，外放听歌，应该是在emo，见我来了，没一会儿他便骑着自行车走了。</p><p><img src="https://images.happy365.day/24/06/20225610_45C6D06E-3900-43A4-A669-92E9450604A3_1_102_o.jpeg" alt="乘凉"></p><p>14:54，距离邢台还有 11 公里。</p><p><img src="https://images.happy365.day/24/06/20225743_C2E04B8D-D765-4378-9E80-81904B95684E_1_102_o.jpeg" alt="路标"></p><p>15:35，进入邢台市区。</p><p><img src="https://images.happy365.day/24/06/20225817_66CC8C01-56CC-4DE8-BD63-031FDCE03A40_1_102_o.jpeg" alt="邢台市区"></p><p>一路上和铁路并行，想和客运列车合个影，晒了半天也没等来，放弃了。</p><p><img src="https://images.happy365.day/24/06/20225854_EBD07F19-4D35-4DDF-ABEE-DCF6E4CF6AD5_1_102_o.jpeg" alt="铁路"></p><p>16:51，内丘县界。进入内丘县。</p><p><img src="https://images.happy365.day/24/06/20225948_2FF568B4-B5BE-4FE8-858A-ECB414E6A55E_1_102_o.jpeg" alt="内丘县"></p><p>进入内丘县城区，距离北京还有 418 公里。</p><p><img src="https://images.happy365.day/24/06/20230030_EA0257A9-8052-4756-B010-CC580D343AB4_1_102_o.jpeg" alt="内丘县"></p><p>17:38，到达内丘县扁鹊公园，今天的行程结束。</p><p><img src="https://images.happy365.day/24/06/20230100_C4C54767-B4A9-47BD-8A7A-C88F3C02C5A8_1_102_o.jpeg" alt="扁鹊公园"></p><p>均速 19.4km，应该是最快的一天了。下午均速20以上，而且很轻松，猜测是气温和胎压的原因吧。</p><p><img src="https://images.happy365.day/24/06/20230139_5680ACE1-6BB3-4A8D-B6C8-A501F9B319BA_1_102_o.jpeg" alt="均速19.4"></p><h2 id="DAY20"><a href="#DAY20" class="headerlink" title="DAY20"></a>DAY20</h2><p><strong>河北省邢台市内丘县 至 河北省石家庄市新乐市 131.5km</strong></p><p>今天又起得比较晚，感觉睡不够。快 7 点才出发，出发的时候太阳已经很高了。</p><p>刚出内丘县就看到一起车祸，轿车和电动车在掉头处相撞。</p><p>每天上午骑车都很费劲，三档都踩不动，软绵绵的，总感觉像是爆胎了一样，弄得我不停的停车确认。到了下午就变得很轻，不怎么使劲就能匀速22公里以上，感觉很轻快。怀疑是胎压的原因可能性大一些。一路上都想找个地方给后轮补气，好不容易在临城县和隆尧县交界处看到一家合适的，说是管子坏了，暂时加不了。走了不远，在路边的白桦林里又自己补气，打气筒也承受不了太高的压力会崩开，补了感觉也没怎么补进去。</p><p>今天的路线基本和铁路平行，一路上看着很多客车来来往往，以前读书的时候就坐走这条线，那时候怎么也想不到几年后的一天我会骑个单车从旁边的公路上经过。感叹铁路上的绿皮车真快啊，一会儿就所有车厢离我远去，以前怎么老是觉得它很慢呢。本来想给火车拍个照，但是太热了，实在不想停车。</p><p>中午11点到达元氏县，温度已经到了 36 度，吃了份饺子然后去旁边不远的卧牛公园，刚好有个凉亭，休息到下午快 3 点才向着石家庄市区出发。</p><p>5 点多出石家庄市区进入正定县时遇到一个年纪较大的骑自行车的人，和他边聊边骑一起走了十来公里。大叔（或许叫大爷更合适）以前也是在深圳做产品，零几年在深圳开了自己的公司，最近几年市场不太景气加上孩子已经成家于是关了公司回到了正定。他也喜欢骑车，周末都会在附近骑个几十公里。还聊了一些我路上的见闻，他没骑过长途，觉得我很有勇气。</p><p>晚上去新乐市鲜虞街吃完饭，这个街道各家招牌都挺统一，步行街干净整洁，走起来很舒服。</p><p>明天的计划：保定市徐水区。不知不觉中，旅途已接近尾声。</p><p>即将出内丘县城，找了个阴凉地方，吃早餐。</p><p><img src="https://images.happy365.day/24/06/20230508_563AAC4B-3EED-4280-B63E-348CE5334FAB_1_102_o.jpeg" alt="吃早餐"></p><p>7:36，距离石家庄 86 公里，距离北京 365 公里。</p><p><img src="https://images.happy365.day/24/06/20230557_581D8A89-957E-449A-ACFE-797FE509EF72_1_102_o.jpeg" alt="路标"></p><p>8:47，距离石家庄 54 公里，距离北京还有 355 公里，这混乱的里程碑😵‍💫</p><p><img src="https://images.happy365.day/24/06/20230658_9BFB34D8-4D95-46F0-AF38-04050ABC3BBE_1_102_o.jpeg" alt="路标"></p><p>总感觉骑不动，遇到一个白桦林，下车补了一下气，休息了半小时。</p><p><img src="https://images.happy365.day/24/06/20230805_1512680A-B90B-42B3-98B1-CEBFD904F7E4_1_102_o.jpeg" alt="打气"></p><p>9:42，石家庄市界，进入石家庄境内。</p><p><img src="https://images.happy365.day/24/06/20230900_9609D719-84BC-4FE2-8800-34ECB36AF993_1_102_o.jpeg" alt="石家庄市界"></p><p>11 点进入元氏县，在元氏县吃午饭。107国道绕元氏县城而过，进城比较绕，吃饭没有太多的选择，在路边吃了一份饺子（不喜欢吃饺子）。正直午饭时候，很多大货车司机也在这里吃饭。</p><p><img src="https://images.happy365.day/24/06/20231011_188810F6-1502-4FA4-86E1-8717829A7446_1_102_o.jpeg" alt="元氏县"></p><p>天气预报显示今天最高气温 42 度，太热了，吃完饭直接在卧牛公园的凉亭眯到快 3 点才出发。</p><p><img src="https://images.happy365.day/24/06/20231047_E617BBAE-E82B-4D46-A475-5ABBBA92425E_1_102_o.jpeg" alt="气温42度"></p><p>刺眼的太阳光。照例小亭子睡午觉。</p><p><img src="https://images.happy365.day/24/06/20231154_6099567C-E44B-42A3-93D4-1E710079B24A_1_102_o.jpeg" alt="休息"></p><p>接近石家庄市区，天上的云遮住了太阳，感觉像是要下雨。</p><p><img src="https://images.happy365.day/24/06/20231258_008EE357-C0C3-4A88-B6EE-39683E7A9EA8_1_102_o.jpeg" alt="多云"></p><p>16:23，经过石家庄站。</p><p><img src="https://images.happy365.day/24/06/20231425_0C396439-EFC4-43B7-A6B7-1B9A64B4570D_1_102_o.jpeg" alt="石家庄站"></p><p>这个专门给京爷看的广告遍布整个河北。</p><p><img src="https://images.happy365.day/24/06/20231446_B7DCF635-4F12-4C80-8B7A-69965A30AEE7_1_102_o.jpeg" alt="广告"></p><p>出石家庄市区，经过正定县。</p><p><img src="https://images.happy365.day/24/06/20231549_0697727C-87A4-4B5B-82EE-830E3BF1083C_1_102_o.jpeg" alt="正定县"></p><p>18:23，距离新乐市 12 公里，距离北京 264 公里。</p><p><img src="https://images.happy365.day/24/06/20231640_DCE1F482-4BE0-439A-9C1A-0611B3D4C0C0_1_102_o.jpeg" alt="路标"></p><p>一望无际的田野。</p><p><img src="https://images.happy365.day/24/06/20231738_96F0DDE0-1921-4288-B7C8-9653E1852656_1_102_o.jpeg" alt="田野"></p><p>进入新乐市区。“生态优先，绿色发展，新乐磁河木刀沟”，但是这里看起来貌似不太像是景区。</p><p><img src="https://images.happy365.day/24/06/20231816_C637562F-1D7A-4B28-95E8-F5157CB22BE4_1_102_o.jpeg" alt="新乐市区"></p><p>新乐市夜晚的步行街鲜虞街，人少，很整洁。</p><p><img src="https://images.happy365.day/24/06/20231956_7D25B692-2A8E-48AD-8A7D-ACBC61AC3A59_1_102_o.jpeg" alt="步行街"></p><p>手臂上的盐渍。</p><p><img src="https://images.happy365.day/24/06/20232038_155B8F80-BBC7-4055-AF7D-7AC9816258A1_1_102_o.jpeg" alt="盐渍"></p><h2 id="DAY21"><a href="#DAY21" class="headerlink" title="DAY21"></a>DAY21</h2><p><strong>河北省石家庄市新乐市 至 河北省保定市徐水区 123.2km</strong></p><p>5点半从新乐市出发，经定州市、望都县、保定市市区，下午 4:40 到达保定市徐水区。</p><p>刚出新乐市就看到一起车祸，轿车和电动车撞到一起。今天总共看到两起车祸。</p><p>刚出发就感觉车子踩起来很吃力，速度15都上不去，到了承安铺补了一下气，没买到链条油。走了不远看到一个汽车维修保养的店，问了也没有，但是他给我刷了貌似其他机器用的油，有一点用，轻快了一点。车子貌似从孝感上了油就没再上油了。开封后的链条油总是会漏光，不知道怎么保存。胎压不足，链条缺油，还有逆向阵风，直接累死我了。</p><p>十一点到达望都县，在望都县吃了午饭。中午太阳大，但是没有昨天热，气温只有 36 度。本来想找个公园之类的地方睡一睡的，不想走太多回头路没找到，顶着太阳直接骑出了城。</p><p>下午去一个加油站买水，门口一位大姐给我从冰箱里拿了冰镇的，说不要钱，送我了。原来这些水是送给来加油的司机的。</p><p>明天的计划：北京广安门外、北京站。</p><p>5:30 的新乐市街道，这里过去左拐就是鲜虞街了。</p><p><img src="https://images.happy365.day/24/06/20232431_D2741D32-83EF-4478-B0C0-EA734B154660_1_102_o.jpeg" alt="新乐市"></p><p>5:50，出城区上了 107 国道。</p><p><img src="https://images.happy365.day/24/06/20232508_1769E321-B025-48F3-BCCE-7A23FA024275_1_102_o.jpeg" alt="新乐市"></p><p>7:32，距离保定 80 公里，距离北京 243 公里。</p><p><img src="https://images.happy365.day/24/06/20232558_31016B81-8D7B-49A8-A281-F4CBCB76077B_1_102_o.jpeg" alt="路标"></p><p>超级棒的路况。</p><p><img src="https://images.happy365.day/24/06/20232727_C7D22908-9E0D-42F4-BD49-F2C7292447E7_1_102_o.jpeg" alt="路况很好"></p><p>在 206 里程碑处吃了在定州买的一斤葡萄🍇，还喝了一大瓶冰水，肚子有点不舒服。</p><p><img src="https://images.happy365.day/24/06/20232825_77446490-4E4C-453A-BDE5-8B2608BA728A_1_102_o.jpeg" alt="路标"></p><p>9:56，望都县界，进入望都县境内。望都，遥望首都的意思吗？</p><p><img src="https://images.happy365.day/24/06/20232924_155B9664-0B63-4873-AF24-FD4FA94EFE2A_1_102_o.jpeg" alt="望都县界"></p><p>这两天看到很多收割机都往北走，之前经过的路边的田里小麦🌾都收割完了，他们是要去哪儿呢？</p><p><img src="https://images.happy365.day/24/06/20233030_D0CA07EF-EB4C-4816-BAB4-0F8C55F5D188_1_102_o.jpeg" alt="收割机"></p><p>“绿色通道”，意义不明。</p><p><img src="https://images.happy365.day/24/06/20233149_3BBA79FE-630A-45A7-B087-4E6369A4E3D5_1_102_o.jpeg" alt="绿色通道"></p><p>11 点在望都县吃的午饭，木须肉盖饭🍚，再加上一杯奶茶🥤，太幸福了！</p><p><img src="https://images.happy365.day/24/06/20233243_1303C677-4DF2-42CA-A065-10C232FB2BE6_1_102_o.jpeg" alt="午饭"></p><p>饭后没找到公园休息，直接出发了。12:04，距离保定 35 公里，距离北京 188 公里。</p><p><img src="https://images.happy365.day/24/06/20233406_1BCDE50F-F6E7-43F2-AEB6-851BA2FDD009_1_102_o.jpeg" alt="路标"></p><p>12:16，距离保定 20 公里？距离北京 193 公里？😵‍💫</p><p><img src="https://images.happy365.day/24/06/20233525_2BADB965-BEBE-478C-B7E4-7ED79A9FECDF_1_102_o.jpeg" alt="路标"></p><p>金黄的麦田，小麦🌾都已经收割完了。</p><p><img src="https://images.happy365.day/24/06/20233627_1CD80F8F-6466-4404-9D07-D74B502EB21F_1_102_o.jpeg" alt="金黄的麦田"></p><p>走了好久遇到一个加油站，想去买水，没想到刚好这个加油站不卖东西。几个正在聊天的阿姨听说我要买水，面对面都在笑，其中一个阿姨起身进屋从冰柜给我拿了一瓶，说不要钱，送我了，不好意思的收下了。</p><p><img src="https://images.happy365.day/24/06/20233659_90FA133A-2A15-4401-A42A-8D3A577E5E06_1_102_o.jpeg" alt="加油站阿姨送的水"></p><p>13:49，进入保定市区。中国保定，莫名的大气。一直以为保定只是一个县级市。</p><p><img src="https://images.happy365.day/24/06/20233825_2B147BE6-2072-4F92-97B2-1107C29D3FE9_1_102_o.jpeg" alt="保定市区"></p><p>路过保定市区东风公园，在公园休息了快一个小时。公园对面住宅区一层有个男的在练习不知什么管类乐器，像是低音号一样，吹的伴奏曲子很好听，可惜用QQ音乐识别了半天也没识别出来，后悔没有直接上去问。</p><p><img src="https://images.happy365.day/24/06/20233859_7B14F07C-C516-4033-8DB8-EA0309FE8DDA_1_102_o.jpeg" alt="休息"></p><p>旅程接近尾声，回看曾经走过的路，不敢相信自己能走来这么远。</p><p><img src="https://images.happy365.day/24/06/20233936_303F3CE7-53B4-44F3-8329-79784FBBC09A_1_102_o.jpeg" alt="地图"></p><p>“绿色通道 北京-深圳 保定-北京段”</p><p><img src="https://images.happy365.day/24/06/20234055_8A7007B1-201A-4E82-A2A6-1EA11F15DDEE_1_102_o.jpeg" alt="绿色通道"></p><p>15:53，接近徐水区，距离徐水 15 公里，距离北京 144 公里。</p><p><img src="https://images.happy365.day/24/06/20234142_34B9EEE2-2C99-4899-B9EB-93D54CA9B2F3_1_102_o.jpeg" alt="路标"></p><p>一路往北走，下午一点树荫都在对面，太阳直晒。</p><p><img src="https://images.happy365.day/24/06/20234231_5CB15C03-0042-477F-B445-4AE2658A59B9_1_102_o.jpeg" alt="路"></p><p>16:24，进入徐水。</p><p><img src="https://images.happy365.day/24/06/20234306_44F1EFD5-69B4-42BA-AD00-7D55A88A4CF7_1_102_o.jpeg" alt="徐水区"></p><p>16:40，到达徐水。</p><p><img src="https://images.happy365.day/24/06/20234347_8F2F0E6C-C7A8-4D62-A9C3-8BE73FBB4F4A_1_102_o.jpeg" alt="徐水区"></p><p>京雄近邻，宜居徐水。徐水的日落🌄</p><p><img src="https://images.happy365.day/24/06/20234418_8436E7E0-ACE3-42F3-A99E-FB1E9582F376_1_102_o.jpeg" alt="徐水区"></p><p>今天的行程结束，这次旅程也接近尾声了。</p><h2 id="DAY22"><a href="#DAY22" class="headerlink" title="DAY22"></a>DAY22</h2><p><strong>河北省保定市徐水区 至 北京市东城区 132.3km</strong></p><p>转眼已经是最后一天的行程。早上五点半从徐水区出发，没走多远遇到一个早餐店，喝了一杯兑水到没味道的豆浆，一根很小的油条。</p><p>一路上经过定兴县、高碑店市、涿州市、进入北京市。路标上到北京的里程数越来越小，渐渐到了100公里以内，周边的地名也逐渐有了北京的风格。</p><p>一路上国道两边的绿化带中有很多蜀葵，当下正值花期，争奇斗艳的开着。明媚的阳光穿过高大的桦树和垂柳，照射在蜀葵娇艳的花瓣上，伴着阵阵微风，明暗交错，更显艳丽多姿。</p><p>11点过了琉璃河，终于看到了北京界的牌子，半个月或者十天以前还不知道这一刻会是多么激动的心情，然而真正到了这一刻，预想中的各种感情好像都不是很强烈，只感觉到热。</p><p>好巧不巧，都快进入北京界了，还爆胎了，还以为在河北路况比较好，可以做到不爆胎。正好快到中午，先吃了饭，然后在旁边一个小亭子休息到两点半才开始补胎。找了半天，找到一根小铁丝，刺穿了外胎，从外胎外表面都看不到了。补好胎已经快四点了，还剩下50公里的路程，是这一个月下午出发最晚的一天了。</p><p>刚准备开始补胎，来了一个三十多岁样子的男的，跟我搭话。聊了一下我的行程，他表示很佩服，问我不害怕吗，还聊了一些工作、路上的事情之类的，差不多聊了一个小时。</p><p>不知道为什么，都是下午的状态比较好，车很轻快，轻轻一踩就能滑很远。一口气直接骑到了北京站。拍了几张照片，在北京站广场对面休息了一个多小时，这趟旅途算是圆满结束了。</p><p>进入北京后，路上骑车的人也多了起来，基本上都是公路车，只遇到一辆折叠车、一个山地车，大家都是组队在骑，很是羡慕。</p><p>北京的骑行体验算是最好的，几乎没有遇到断头路或者颠簸路。</p><p>5:40，从徐水区出发。</p><p><img src="https://images.happy365.day/24/06/20234951_3CD9636C-9CAC-4E21-8CA8-C88E04C90279_1_102_o.jpeg" alt="徐水区出发"></p><p>6:22，距离北京 129 公里。</p><p><img src="https://images.happy365.day/24/06/20235037_A387F74F-5CBE-465B-878E-A37EFF25B4BE_1_102_o.jpeg" alt="路标"></p><p>一级棒的路况👍</p><p><img src="https://images.happy365.day/24/06/20235141_FD25A59B-B086-4D8E-9EC6-6C6769030CEB_1_102_o.jpeg" alt="好路"></p><p>8:06，距离北京 99 公里。</p><p><img src="https://images.happy365.day/24/06/20235225_D981B88F-6959-4126-9650-EEE6781980CF_1_102_o.jpeg" alt="路标"></p><p>有意思的镇名：百尺竿——百尺竿头，更进一步。</p><p><img src="https://images.happy365.day/24/06/20235310_7B4D8446-0DA7-412E-98CA-682C62C9AECE_1_102_o.jpeg" alt="路标"></p><p>10:43，距离北京 62 公里。</p><p><img src="https://images.happy365.day/24/06/20235415_7F9CA6AC-BD8C-407D-AFC9-4947F1BC9E71_1_102_o.jpeg" alt="路标"></p><p>11:09，北京界，终于进入北京市了。第一次遇到查身份证，京爷就是爷。</p><p><img src="https://images.happy365.day/24/06/20235446_EDEC6ECB-A163-4623-9A63-4851492AADA4_1_102_o.jpeg" alt="北京界"></p><p>在琉璃河镇吃午饭，这盆饭吓到我了😓。正好遇到一群北京养护的工人进来吃饭，一行大概有20来个人，大家点的餐都不太一样，面还有过水和不过水的区别（头一次知道），这个店都是口头点餐。我对店主表示敬佩，换了我早乱了。</p><p><img src="https://images.happy365.day/24/06/20235540_998C0CB9-847B-455C-B48A-7665B92020BF_1_102_o.jpeg" alt="午饭"></p><p>吃完午饭在旁边的公园眯到了快 3 点，补好胎出发时已经快 4 点了。</p><p><img src="https://images.happy365.day/24/06/20235722_7DE95302-2E6C-4516-BAB6-76A69590389F_1_102_o.jpeg" alt="补胎"></p><p>经过房山区窦店镇。</p><p><img src="https://images.happy365.day/24/06/20235829_24B6B6A0-E997-454F-8852-DE1B7BE6F17A_1_102_o.jpeg" alt="房山区"></p><p><img src="https://images.happy365.day/24/06/20235906_20D809C4-EC38-4109-A815-5D9C71BD1193_1_102_o.jpeg" alt="房山区"></p><p>路边盛开的蜀葵。</p><p><img src="https://images.happy365.day/24/06/20235946_B2935F95-A7BB-44AD-A0E7-09AD7CEF038C_1_102_o.jpeg" alt="蜀葵"></p><p>18:31，经过北京西站。</p><p><img src="https://images.happy365.day/24/06/21000024_694B3B08-FC19-41B3-A55B-0540F6FC3D3E_1_102_o.jpeg" alt="北京西站"></p><p>19:15，到达终点北京站。</p><p><img src="https://images.happy365.day/24/06/21000116_0079FA0E-1AD7-4B6F-A82A-E10D3F889CC3_1_102_o.jpeg" alt="北京站"></p><p><img src="https://images.happy365.day/24/06/21000146_F814016D-A107-4E4E-AD62-E5F5E73A7D1C_1_102_o.jpeg" alt="北京站"></p><p><img src="https://images.happy365.day/24/06/21000235_D01A8445-EB18-4978-A3CB-83FFDE9F2774_1_102_o.jpeg" alt="北京站"></p><p>回头看看来时的路，终于攒齐了所有的拼图🧩</p><p><img src="https://images.happy365.day/24/06/20235626_A5A51B11-CFD3-48F8-AF40-05CFFD9CDE3B_1_201_a.jpeg" alt="地图"></p><p><em>22 天，2500 公里，欣喜、疲惫、孤独，一段难忘的旅途。</em></p>]]></content>
      
      
      <categories>
          
          <category> 日志随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骑行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>骑行_深圳至北京_PART4_孝感至安阳</title>
      <link href="/2024/06/19/356b30198360/"/>
      <url>/2024/06/19/356b30198360/</url>
      
        <content type="html"><![CDATA[<h2 id="DAY14"><a href="#DAY14" class="headerlink" title="DAY14"></a>DAY14</h2><p><strong>湖北省孝感市孝南区 至 河南省信阳市浉河区 146.4km</strong></p><p>今天路程比较远，导航目的地设置为信阳市显示距离为 148 公里，又是一个创纪录的骑行距离。</p><span id="more"></span><p>早上五点过几分准备起床，听到楼下已经有人在说话，拉开窗户看到一个老人已经开始摆摊卖菜了。不知道他的菜种在哪里、是不是今天早上现收来的菜，人这一生真苦啊。</p><p>收拾完行李出门已经快六点了，刚好楼下有卖早餐的，买了一个包子、一个鸡蛋和一杯豆浆。</p><p>今天是个大晴天，还是昨天多云的天气更适合赶路，可惜这肉体凡胎太脆弱了。</p><p>今天的路线全程走107国道，基本都是起伏路，最后 40 公里翻越大别山起伏比较大，路况都还挺好。进入河南省界之后路肩上的铁钉、铁丝、螺丝钉超级多，一直担心扎胎。</p><p>因为今天行程较远，没有规划吃午饭。中午就在广水市一个叫铺冲村的地方有个亭子吃了一个八宝粥、几个杏子，休息了将近半小时。本来还想多休息一会儿，来了个估计六十岁左右的男的，一直跟我搭话，但是他说话我一句也听不懂，牙齿不全加上不知道说的是不是方言，一句也听不明白，搞得我有点尴尬，只能顶着 30 多度的高温继续下午的骑行。</p><p>下午 4 点早早的到达了信阳站。简单洗漱了一下去逛了一下信阳站旁边的商场，还去沃尔玛和新华书店转了一圈，看到很多有趣的玩具，还在新华书店看到了初中教材、高中辅导书、日语教材，很怀念。</p><p>明天的计划：河南省驻马店市遂平县，120km。</p><p>5:17，楼下开始摆摊卖菜的大爷。</p><p><img src="https://images.happy365.day/24/06/20203502_C40DC529-A73A-454E-B238-F16235BB865A_1_102_o.jpeg" alt="卖菜的大爷"></p><p>6:25，太阳已经升高了。</p><p><img src="https://images.happy365.day/24/06/20203250_80E0D2BC-041F-4CC0-A80B-D2CE62460EF8_1_102_o.jpeg" alt="早晨的太阳"></p><p>9:10，距离北京还有 1222 公里。一路上里程碑时有时无、还时常绕路走，所以 2222、1999 这些里程碑都没看到。</p><p><img src="https://images.happy365.day/24/06/20203344_232D84AD-E416-40D6-9FFE-6EE95F8505EA_1_102_o.jpeg" alt="1222里程碑"></p><p>9:42，1212 里程碑。</p><p><img src="https://images.happy365.day/24/06/20203626_B6435DE2-E21D-480B-83C2-D3209B090931_1_102_o.jpeg" alt="1212里程碑"></p><p>“请勿超速，前方无医院”</p><p><img src="https://images.happy365.day/24/06/20203719_F074A2E5-1A6D-4643-9DBC-772287D61627_1_102_o.jpeg" alt="标语"></p><p>能看到远处的山。</p><p><img src="https://images.happy365.day/24/06/20203825_CC1C5324-677A-4C07-BA39-D96FC363E93F_1_102_o.jpeg" alt="远处的山"></p><p><img src="https://images.happy365.day/24/06/20203913_43E31054-D585-49B8-ACC1-6973AA5F6249_1_102_o.jpeg" alt="远处的山"></p><p>11:54，广水市一个叫铺冲村的村子遇到一个小亭子，休息吃午饭。</p><p><img src="https://images.happy365.day/24/06/20203942_92EA8156-1EBA-4EDA-B513-5071C3E62132_1_102_o.jpeg" alt="休息"></p><p>昨天在孝感买的杏子，很好吃😋，留了种子，以后种了试试看。</p><p><img src="https://images.happy365.day/24/06/20204035_1F5F704E-280E-4407-ADDF-91ECA8BAAA52_1_102_o.jpeg" alt="杏子"></p><p>不远处繁忙的铁路🚞</p><p><img src="https://images.happy365.day/24/06/20204125_BB53CDFB-69F5-49D7-A658-5EAC5E24C973_1_102_o.jpeg" alt="铁路"></p><p><img src="https://images.happy365.day/24/06/20204156_63F0EB72-B888-47D2-88C7-03135F599FBA_1_102_o.jpeg" alt="铁路"></p><p>12:48，武胜关桥。武胜关，一个听起来好像很厉害的名字。快要进入河南境内了。</p><p><img src="https://images.happy365.day/24/06/20204222_BBA16629-6477-4FD9-B5CF-4F47FB24FE0B_1_102_o.jpeg" alt="武胜关桥"></p><p>12:58，河南省界。从这里开始，路边好多都卖茶叶的，信阳毛尖，貌似有点耳熟。</p><p><img src="https://images.happy365.day/24/06/20204346_B32E683F-80AC-4B80-B3B5-5C9317CAE284_1_102_o.jpeg" alt="河南省界"></p><p>“奋力战疫情”——这一路上看到不少时代的印记。</p><p><img src="https://images.happy365.day/24/06/20204529_32D066BA-F08A-4BC8-9AB4-8617EC139B84_1_102_o.jpeg" alt="标语"></p><p>这就是进入大别山了吧。</p><p><img src="https://images.happy365.day/24/06/20204603_2405919E-65E3-4512-8386-B3FC4386A36A_1_102_o.jpeg" alt="山"></p><p><img src="https://images.happy365.day/24/06/20204632_29EB40B6-24CF-485E-A86A-E1C89F4632D9_1_102_o.jpeg" alt="山"></p><p><img src="https://images.happy365.day/24/06/20204711_C7BC6A57-9CE8-43AD-9FAB-D179EB727F34_1_102_o.jpeg" alt="山"></p><p>15:35，进入信阳市区。河边搭了很多凉棚，适合钓鱼🎣</p><p><img src="https://images.happy365.day/24/06/20204733_A1BE703B-DCDD-4C52-959B-4C63B49BB38C_1_102_o.jpeg" alt="信阳市区"></p><p>15:45，达到信阳站，今天的行程结束，比想象中要顺利。</p><p><img src="https://images.happy365.day/24/06/20204835_FCCBF2F1-CB95-4511-A467-1D8E2653AC49_1_102_o.jpeg" alt="信阳站"></p><p><img src="https://images.happy365.day/24/06/20205355_1D29A129-AF52-4001-8402-00B8E22E4E49_1_102_o.jpeg" alt="信阳市区"></p><h2 id="DAY15"><a href="#DAY15" class="headerlink" title="DAY15"></a>DAY15</h2><p><strong>河南省信阳市浉河区 至 河南省驻马店市遂平县 120.9km</strong></p><p>昨天就想说，这次骑行打破了我对河南的固有印象。以前读书坐火车也每年经过河南，在火车上看到的是一望无垠的平原，没想到也有山、也有连续上坡和连续下坡。</p><p>今天早上喝到的豆浆很难喝，上层好像兑水了一点味道也没有，底层有渣子还甜的过分，不知道怎么做的。</p><p>今天120公里比较近，早上 8 点才出发。</p><p>出门就开始出太阳，上午太阳断断续续，中午比较热，骑到 12 点实在骑不动，在任店镇吃了个午饭。进镇上时碰到一个骑电动车的小伙子，问我能不能跑过他的电动车、吃饭怎么弄、包里是不是带了饭。吃午饭的店的男老板也问了我从哪里来到哪里去，我没好意思说实话，只说从信阳过来骑到驻马店，希望我手上的晒黑的印记没有出卖我。</p><p>今天路上又遇到几只被车撞死的麻雀、喜鹊。说起来，从昨天进入河南开始，路边的大喜鹊渐渐的多了起来。</p><p>河南这边的城市和县城一个接一个，距离就在十几公里二十公里左右，刚出城没走几个村又开始进城，难怪可以容纳下这么多人。</p><p>明天的目标：长葛市。争取后天可以直接穿过郑州。</p><p>超级难喝的豆浆🥛</p><p><img src="https://images.happy365.day/24/06/20205435_88AD419C-19DF-4833-B9A8-201A0EA7CDA7_1_102_a.jpeg" alt="豆浆"></p><p>9:35，距离驻马店 80 公里。</p><p><img src="https://images.happy365.day/24/06/20205507_E7B5ACCD-7F42-4551-AC10-1DA9D23B36E0_1_102_o.jpeg" alt="路标"></p><p>低素质！路口停车，还停在人行道上，开着车门翘个脚刷短视频，袜子🧦还破了个洞。</p><p><img src="https://images.happy365.day/24/06/20205552_AFAC6098-E0F3-4B1F-98E0-51D60501FA68_1_102_o.jpeg" alt="乱停车"></p><p>在河南，你甚至能看到“连续下坡”，两公里左右的下坡。</p><p><img src="https://images.happy365.day/24/06/20205710_675AF64E-5304-43F1-BAB7-2437CD5C2795_1_102_o.jpeg" alt="连续下坡"></p><p>金鸡岭景区的山。</p><p><img src="https://images.happy365.day/24/06/20205825_39F9762D-2E4A-414B-8C3E-4A6F7341AED2_1_102_o.jpeg" alt="山"></p><p>这才是印象中的河南，已经收割完的小麦🌾</p><p><img src="https://images.happy365.day/24/06/20205855_D25BE777-8547-4D49-B58D-E7C5DB0280E7_1_102_o.jpeg" alt="平原"></p><p>12:06 到达任店镇。就是前面跷二郎腿骑电瓶车的小伙子跟我搭话。</p><p><img src="https://images.happy365.day/24/06/20205948_C355D5C7-1C3D-4C59-B682-5B4E853D08B8_1_102_o.jpeg" alt="任店镇"></p><p>中午照例沙县大酒店。</p><p><img src="https://images.happy365.day/24/06/20210046_A5500F35-3FFE-4246-9A9D-DB8F794225CC_1_102_a.jpeg" alt="午饭"></p><p>武汉：“昔日汉阳古郡，今日中法新城”；任店镇：“昔日朗陵故城，今日秀美任店”。</p><p><img src="https://images.happy365.day/24/06/20210125_5D445906-D821-4403-AA59-448BA1EB0429_1_102_o.jpeg" alt="任店镇"></p><p>13:50 进入确山县。</p><p><img src="https://images.happy365.day/24/06/20210443_444BD864-371D-4E42-AB0E-E038D8C8D9A5_1_102_o.jpeg" alt="确山县"></p><p>有红绿灯，但是大家好像都视而不见。</p><p><img src="https://images.happy365.day/24/06/20210523_144651C2-B46F-4FE0-A5FB-2B1B993F4AC6_1_102_o.jpeg" alt="交通混乱"></p><p>天气很热，远处的路好像水面一样，还有倒影。</p><p><img src="https://images.happy365.day/24/06/20210629_46874934-D7BB-46AE-BAD9-ABC02E4BE510_1_102_o.jpeg" alt="路"></p><p>14:45，进入驿城区，休息一下。</p><p><img src="https://images.happy365.day/24/06/20210749_8B212738-3DF0-4CE8-919C-55C45CBD071C_1_102_o.jpeg" alt="休息"></p><p>14:53，距离遂平县还有 25 公里，还要一个半小时才能到达。</p><p><img src="https://images.happy365.day/24/06/20210821_E239EBA8-29D9-4E21-9690-342450C0D0BE_1_102_o.jpeg" alt="路标"></p><p>进入河南之后，路上好多这种电动车，有三轮的、四轮的、长宽也有大有小，有的甚至和普通机动车没什么区别，但是都没有牌。</p><p><img src="https://images.happy365.day/24/06/20210914_2619866A-76FA-4906-B0CB-AA2FE9344EA6_1_102_o.jpeg" alt="各种电动车"></p><p>驻马店市区与遂平县之间的大片农田。</p><p><img src="https://images.happy365.day/24/06/20211040_517BB3FA-3D7C-450E-91E7-DE22C352078B_1_102_o.jpeg" alt="农田"></p><p>16:40，进入遂平县城区。</p><p><img src="https://images.happy365.day/24/06/20211126_213D5159-95A2-4217-8D03-CB413CE62BEE_1_102_o.jpeg" alt="遂平县"></p><p>河南很热，一路上出了很多汗。</p><p><img src="https://images.happy365.day/24/06/20211207_B8BD1300-A858-4010-BF01-EFC1143EBB77_1_102_o.jpeg" alt="手套上的盐渍"></p><p>18:39，遂平县的日落🌄</p><p><img src="https://images.happy365.day/24/06/20211323_1B73E7AE-B319-414F-93CD-06D14C28F27C_1_102_o.jpeg" alt="日落"></p><p>谢谢，确山和遂平都不是我的家。</p><p><img src="https://images.happy365.day/24/06/20211359_3171DCA1-3B11-4772-9502-1B7A45FC9001_1_102_o.jpeg" alt="电网短信"></p><p>遂平街道边盛开的月季🌹</p><p><img src="https://images.happy365.day/24/06/20211446_744410DE-C4C1-45DC-B571-1471C9AD95C2_1_102_a.jpeg" alt="月季"></p><p>20:18，遂平一中正下课的学生和接学生的家长。</p><p><img src="https://images.happy365.day/24/06/20211528_B6931EEB-36D0-4105-9539-8B6DE16C265C_1_102_o.jpeg" alt="遂平一中"></p><p>今日的行程结束。</p><h2 id="DAY16"><a href="#DAY16" class="headerlink" title="DAY16"></a>DAY16</h2><p><strong>河南省驻马店市遂平县 至 河南省许昌市长葛市 129.9km</strong></p><p>今天规划的路程还是正常的 120 公里，早上一直拖到 8 点才起床。多云的天气，阳光有一点但是不多。</p><p>从遂平县出来没看到卖早餐的，空着肚子一直骑到漯河市。中午在漯河市走了好几百米的路没看到有米饭的店，又折回来吃了一家面，只有炸酱面，酱里貌似有花生酱，简直灾难，吃了几口感觉想吐，只喝了一瓶冰红茶，休息到 1 点继续赶路。</p><p>虽然昨天已经见识到了，但还是为河南的城市密度感到惊叹。今天 130 公里的路程穿过西平县、漯河市、临颍县、许昌市。</p><p>下午五点半在许昌市内看到一座建筑，轨道穿行而过，轨道旁有类似高铁电线杆，地图上显示许昌市体育中心，感到很奇怪。走了几百米，看到牌子上写着地铁：郑许线。原来郑州的地铁已经通到了许昌。很难想象，在这样的小县城也能看到地铁站牌，离中心城市近就是好。</p><p>一天数着107国道的里程一路到长葛，没看到 1000、没看到 999，只看到了 998，然后还有911。</p><p>从遂平县出来后107国道上车道线也没了，慢车道上沙子和灰尘也很多，骑得人很烦躁。好在路两旁有无数枝繁叶茂的枫树和高大挺拔的桦树，像严肃站岗的卫兵，抵挡着利箭一般的太阳光芒。</p><p>在西平县又看到董永和七仙女的雕像，不知道这里和这个故事又有什么关联。</p><p>进入临颍县和长葛市都是猛踩进城，均速25以上，拉爆一众电动车和三轮车，听着耳边呼呼的风躁🚴💨💨💨，那感觉真的很爽。</p><p>明天的计划：穿过郑州，到达新乡市区。</p><p>麦田和村庄。</p><p><img src="https://images.happy365.day/24/06/20212511_19C3DA84-A85F-41C8-9752-F6136053FDB0_1_102_o.jpeg" alt="麦田和村庄"></p><p>9:08，距离郑州 165 公里。</p><p><img src="https://images.happy365.day/24/06/20212556_0353C4E2-1984-4F96-A24E-97B4E76BF634_1_102_o.jpeg" alt="路标"></p><p>107国道 996 里程碑。</p><p><img src="https://images.happy365.day/24/06/20212632_A7FC5243-FA4B-4CF7-B12B-589E0929A5F3_1_102_o.jpeg" alt="996里程碑"></p><p>9:33，进入西平县。</p><p><img src="https://images.happy365.day/24/06/20212707_9E59C275-61D0-4F1D-87C9-7F9C505D7E50_1_102_o.jpeg" alt="西平县"></p><p>距离许昌市 90 公里。</p><p><img src="https://images.happy365.day/24/06/20212733_6B0B6C45-F05F-4174-9BE1-2FBBF6C25F7B_1_102_o.jpeg" alt="路标"></p><p>路边不知名果子，海棠？</p><p><img src="https://images.happy365.day/24/06/20212825_9FD73FF3-9312-4B10-AD9B-96B0CE98ED6E_1_102_o.jpeg" alt="不知名果子"></p><p>为什么嫘祖河湿地公园里会有董永和七仙女的雕像🗿呢？</p><p><img src="https://images.happy365.day/24/06/20212907_33955806-70A1-4978-A119-35E70857A77D_1_102_o.jpeg" alt="雕像"></p><p>11:27，进入漯河市。</p><p><img src="https://images.happy365.day/24/06/20213042_62805E86-A66B-45C7-987C-32A03FE24FD4_1_102_o.jpeg" alt="漯河市界"></p><p>沙鳢河风景区。</p><p><img src="https://images.happy365.day/24/06/20213135_6E4FFB00-350F-4701-A8AB-3DF7CFB3849E_1_102_o.jpeg" alt="沙鳢河风景区"></p><p>一望无际的麦田。</p><p><img src="https://images.happy365.day/24/06/20213241_25A24BD0-989B-417C-881E-BE8D43429F96_1_102_o.jpeg" alt="麦田"></p><p>小商桥风景区。以前没听说过。</p><p><img src="https://images.happy365.day/24/06/20213317_D3051E9E-4AE4-4A86-B90D-4703FA95185A_1_102_o.jpeg" alt="小商桥风景区"></p><p>14:07，距离许昌市区还有 32 公里。</p><p><img src="https://images.happy365.day/24/06/20213358_DB7C9209-F8A3-488D-AE5E-4F3C86CD8DAB_1_102_o.jpeg" alt="路标"></p><p>持续好几公里的补胎广告🪧，不会有人在路上撒钉子吧？害怕😨</p><p><img src="https://images.happy365.day/24/06/20213434_4D1C6ED1-3268-4F95-B7B9-16DA158DEFED_1_102_o.jpeg" alt="补胎广告"></p><p>14:50，经过临颍县城，吃根雪糕🍦。</p><p><img src="https://images.happy365.day/24/06/20213534_277A696C-9191-4AEC-BDF9-0D4BB15767EE_1_102_o.jpeg" alt="车"></p><p><img src="https://images.happy365.day/24/06/20213616_16AAC6BB-9495-44E7-A8D6-DB226D1267B0_1_102_o.jpeg" alt="雪糕"></p><p>15:53，进入许昌市。</p><p><img src="https://images.happy365.day/24/06/20213643_78FEA8B2-F8B9-4668-BC8F-FE54C17D2BEA_1_102_o.jpeg" alt="许昌市界"></p><p>已经修到许昌的郑州地铁，惊到了。</p><p><img src="https://images.happy365.day/24/06/20213739_FB1EE390-4989-4DE7-B54B-FFD1400A44AC_1_102_o.jpeg" alt="郑州地铁"></p><p>从这里开始加速，均速 25 以上进入长葛市内，把骑电动车的小姐姐远远的甩在了身后。</p><p><img src="https://images.happy365.day/24/06/20213821_540D48D2-A70C-4C45-BD15-36D7D5277655_1_102_o.jpeg" alt="地铁站"></p><p>17:49，进入长葛市。</p><p><img src="https://images.happy365.day/24/06/20213927_9323A977-56FD-4D61-A268-554717E32B5E_1_102_o.jpeg" alt="长葛市区"></p><p>一路上遇到的第一个马踏飞燕。感觉长葛市很小啊，有什么很著名的景点吗？本来导航到了长葛市东边，为了到这里拍个照，又从东边骑到这里，多骑了 5 公里多，还担心是不是走错了，出城再进城可就走冤枉路了。</p><p><img src="https://images.happy365.day/24/06/20214028_A8E4997D-4170-4A22-BAB9-B2F427C2655C_1_102_o.jpeg" alt="马踏飞燕"></p><p>天太热了，一天不知道要喝多少水🥤</p><p><img src="https://images.happy365.day/24/06/20214207_8CE1C621-EB1B-424C-925A-0944B53F72A2_1_102_o.jpeg" alt="饮料"></p><h2 id="DAY17"><a href="#DAY17" class="headerlink" title="DAY17"></a>DAY17</h2><p><strong>河南省许昌市长葛市 至 河南省新乡市红旗区 132.1km</strong></p><p>今天从长葛市出发，经新郑市、郑州市、新乡县到达新乡市区。</p><p>这几天早上感觉都很困，昨天晚上做了一个奇怪的梦。早上才六点，太阳光就照得睡不着，拉上窗帘睡到七点过。</p><p>又是没有早餐吃的一天。</p><p>早上出发前特意给前胎补了一下气（这个小打气筒打出一身汗，后面胎压高了根本打不进去，后面要买一个自动充气泵比较方便），没想到走出去没多远发现胎压反而不足了，又在路边找了个店补了一下气，花了 2 块钱。自己买的打气筒不是很好用，气压一高就开始漏气。</p><p>补气的时候遇到一个骑公路车的骑友，我补气的时候他朝前走了，走了没几分钟我追上了。问他去哪儿，他可能没反应过来，没理我，我就朝前走了。过了两分钟他追了上来，跟他聊了几分钟，他也是去新乡。说中午十二点多就能到，后来算了一下，他得均速30多，实际上他的速度跟我差不多甚至还没我快。他说要和他哥会和，就先走了。没多久进入郑州市界前又被我超了，看到他一个人走的新郑快速通道旁的绿道，我走的路肩，直接先走了。</p><p>新郑快速通道两旁的行道树里好多紫叶李，有些树枝都被果子压弯了。一直想着灰尘、汽车尾气和农药，忍着没摘。后来趁着喝水的时候摘了几个放包里，下午出郑州进入新乡时走的是省道，路边没有村庄和店铺，水都喝完了，还好靠着这几颗李子撑了十来公里路。</p><p>36度，顶着太阳骑车，走几分钟嗓子就开始干燥，这一天喝了十来瓶水。天气预报上显示是多云，但现实却完全是大晴天，要死。</p><p>从长葛到新郑路两旁的高大枫树形成了很多树荫，好评。但是路面是水泥，每隔两三米就有沥青接缝，车子有规律的一颠一颠，心态都要颠崩了。</p><p>今天路上遇到骑行的人挺多，公路车、山地车、长途和短途的骑友都有。</p><p>每天几乎都是头盔戴一整天，下午头发都会变成波浪形，之前没看到异样眼神，今天到宾馆的路上，看到几个迎面骑电动车过来的女生一直盯着我看，还笑，应该是附近新乡医学院的学生。</p><p>郑州市的红绿灯动不动就是 90 秒 100 秒，顶着大太阳等这么久，实在让人受不了。</p><p>郑州市黄河公路大桥没有非机动车道，入口处路旁写着请使用公共交通工具过河。走了旁边的行人过道，很窄，外侧就是黄河，路上还有很大的坑，骑得胆战心惊，手腕握车把都握疼了，一手的汗，花了半个多小时才下桥。长江、黄河都过完了，距离终点更近了。</p><p>这几天太热了，后面每天的安排要调整一下，早上赶早，晚上晚到，中午尽量休息。</p><p>新乡这边的很多司机经常开上慢车道，让人很不爽。在其他城市倒确实没见过这种现象。</p><p>明天的计划：安阳市。到了安阳后先休整一天再进河北。</p><p>远处就是说要去和他哥会和的小伙子。</p><p><img src="https://images.happy365.day/24/06/20215115_BB433D84-AEC7-4E1E-ADB5-212BA071E85B_1_102_o.jpeg" alt="小伙子"></p><p>9:49，新郑市。太热了，休息一下。</p><p><img src="https://images.happy365.day/24/06/20215150_7DB52B42-EAD3-48C7-92CA-86C93F3515C4_1_102_o.jpeg" alt="新郑市休息"></p><p>热🔥。路边很多紫叶李。</p><p><img src="https://images.happy365.day/24/06/20215232_D93B1D3D-C8AB-4E34-81BD-D9DC31DA90B3_1_102_o.jpeg" alt="紫叶李"></p><p><img src="https://images.happy365.day/24/06/20215301_84EC7926-7674-45B1-8A6A-A3521C706DD3_1_102_o.jpeg" alt="紫叶李"></p><p>11:30，进入郑州市。</p><p><img src="https://images.happy365.day/24/06/20215325_276261F4-852D-4310-A0E1-7D4F64368C4C_1_102_o.jpeg" alt="郑州市界"></p><p>郑州市。</p><p><img src="https://images.happy365.day/24/06/20215403_BF4EDE5A-6008-487A-A560-ABCB038BBF5D_1_102_o.jpeg" alt="郑州市"></p><p>15:00，过黄河公路大桥🌉，黄河水很小，大片的滩涂。</p><p><img src="https://images.happy365.day/24/06/20215442_52337DB6-2D45-49F7-AFDE-517A80993261_1_102_o.jpeg" alt="黄河公路大桥"></p><p>黄河公路大桥上的新乡市界。</p><p><img src="https://images.happy365.day/24/06/20215542_200DA486-B0E8-411C-AF7C-73B12E194934_1_102_o.jpeg" alt="新乡市界"></p><p>花瓣一样的太阳能电池。刚好几个骑摩托车的人经过，摩托车真好啊，不费力一下就去好远。</p><p><img src="https://images.happy365.day/24/06/20215625_DB3C7B5D-26EA-4181-81AB-FAEAE8F6A93E_1_102_o.jpeg" alt="太阳能电池"></p><p>进入新乡县。一路上桥洞上都是这个广告，有钱赚谁不想为中原做贡献？</p><p><img src="https://images.happy365.day/24/06/20215747_45A47852-8187-4CF1-8FCE-E736DD0BF7AA_1_102_o.jpeg" alt="新乡县界"></p><p>16:30，距离新乡市区 22 公里。</p><p><img src="https://images.happy365.day/24/06/20215913_D31FC70D-0BE7-4402-952A-F72F42379492_1_102_o.jpeg" alt="路标"></p><p>距离新乡还有十几公里，休息了半个小时。</p><p><img src="https://images.happy365.day/24/06/20215956_FD39EDBB-A431-4816-A208-DF233E73D091_1_102_o.jpeg" alt="休息"></p><p>18:10，进入新乡市区，正逢下班时间。</p><p><img src="https://images.happy365.day/24/06/20220104_9A281F95-5150-41E8-B295-3504684E3371_1_102_o.jpeg" alt="新乡市区"></p><p>夜晚的新乡街道。</p><p><img src="https://images.happy365.day/24/06/20220206_8A55047D-85D7-4905-A62B-FBF2AF811ECB_1_102_o.jpeg" alt="新乡市区"></p><p>今天的行程结束。</p><h2 id="DAY18"><a href="#DAY18" class="headerlink" title="DAY18"></a>DAY18</h2><p><strong>河南省新乡市红旗区 至 河南省安阳市文峰区 111.8km</strong></p><p>因为昨天中午天气太热没法赶路，今天打算改变一下策略，早上和下午赶路，11:30 到 14:00 休息。五点过几分起来收拾好行李，六点出发。</p><p>行程不太顺利，骑出去几百米就发现后轮胎压不足，骑起来很费劲。想找个地方补补气，可是路上都没遇到。走了5公里多一点，找到一个无人的路边房子，在阴凉处看了一下后胎。看到了铁丝，但是没找到具体的漏气的地方，按着外胎被铁丝刺穿的地方补了一下，一直坚持到安阳市，晚上吃饭回来后发现后轮已经没气了，不知道是新扎的还是早上的没补好。</p><p>一路经过卫辉、淇县、鹤壁、汤阴，最后到达安阳市区万达广场。</p><p>中午顶着大太阳 36 度的高温骑到鹤壁，点了一份鸡蛋面，和想象中的差距太大，好像汤里放了豆汤的感觉，也没有辣椒什么的，吃不下去，就吃了几口。</p><p>本来想去拍一拍鹤壁站，正赶上施工，在站前广场看不到站楼。去附近喝了蜜雪冰城和一个不知名冷饮，这么热的天真完全靠冷饮续命。</p><p>晚上在万达吃了冒菜，有空调、人不多、有 Wi-Fi，环境不错，菜的味道也不错，热天还是吃点辣的比较有胃口。</p><p>下午办理宾馆入住的时候，被搭话了：“你这车能骑长途吗？”。“能啊，我都从广东深圳骑到这儿了”。“深圳？我的天，你好厉害啊，你太牛了，骑了几个月？<br>”。“骑了17天”。“你太牛了”。对屋里人说：“哎，这个人从深圳骑单车来”。“你这车多少钱啊？”。“淘宝买的，就两千多。”</p><p>现在回头看，自己也不敢相信，竟然真的骑来两千多公里了。</p><p>明天在安阳休息一天，后天去河北邢台。</p><p>5:38，眺望新乡市区。</p><p><img src="https://images.happy365.day/24/06/20220827_3C563949-6549-4675-B972-5DE13947908C_1_102_o.jpeg" alt="新乡市区"></p><p>7 点不到就开始补胎😮‍💨</p><p><img src="https://images.happy365.day/24/06/20220912_D69CAFF6-509C-42B2-8169-8B6269080564_1_102_o.jpeg" alt="扎胎"></p><p><img src="https://images.happy365.day/24/06/20220947_756A91A4-BC4D-4309-AD65-421DDB314E08_1_102_o.jpeg" alt="补胎"></p><p>8:13，进入卫辉市。</p><p><img src="https://images.happy365.day/24/06/20221016_3413C6B4-5AF6-423E-B329-0B89A67B9C88_1_102_o.jpeg" alt="卫辉市"></p><p>往北走，早晨有树荫，下午暴晒。</p><p><img src="https://images.happy365.day/24/06/20221053_D0297C35-93BC-4C20-92C7-2EBF1110D966_1_102_o.jpeg" alt="树荫"></p><p>不远处就是太行山脉。很久之前曾在 bilibili 看一个女生天津骑行广西的视频，骑到安阳之后，向西去了太行山，一路经过林州、西井山、平顺县城、挂壁公路。后来不知道什么原因视频没有更新，直到到了贵州境内才发一点动态。从那时开始，我也对太行山有了一点向往。</p><p><img src="https://images.happy365.day/24/06/20221136_852E6F65-4D8C-4553-AF4D-E646DA04EE9B_1_102_o.jpeg" alt="太行山"></p><p>上午 10 点，鹤壁界，距离淇县 10 公里。</p><p><img src="https://images.happy365.day/24/06/20221618_931BBD32-6637-4666-986E-F223AFA9164A_1_102_o.jpeg" alt="鹤壁界"></p><p>和国道并行的铁路🚞，说不定上学的时候，我就是坐着火车 n 次从这里经过。</p><p><img src="https://images.happy365.day/24/06/20221708_B403DAF8-6284-4AC6-A940-1E69B5F70F5B_1_102_o.jpeg" alt="铁路"></p><p>鹤壁市淇滨区吃的午饭，真吃不习惯。</p><p><img src="https://images.happy365.day/24/06/20221839_A877B4D2-241E-41C9-8F3C-43FB4BE7BFF6_1_102_o.jpeg" alt="午饭"></p><p>接近 40 度的正午，蜜雪冰城🥤救命。</p><p><img src="https://images.happy365.day/24/06/20221925_66AAFC64-88A0-4958-897D-276441CDDAC8_1_102_o.jpeg" alt="奶茶"></p><p>14:31，进入安阳市，距离安阳市区 30 公里。</p><p><img src="https://images.happy365.day/24/06/20222035_5F4EEAB2-E3F5-470A-AB33-06E7C3344257_1_102_o.jpeg" alt="安阳市界"></p><p>15:12，汤阴站。</p><p><img src="https://images.happy365.day/24/06/20222249_34C4D126-6195-4FDA-A447-52AA62F4F8BF_1_102_a.jpeg" alt="汤阴站"></p><p>在汤阴县公共厕所洗了下桃子🍑</p><p><img src="https://images.happy365.day/24/06/20222204_3BE04E26-83EB-4F35-AD60-7D05808045BC_1_102_o.jpeg" alt="洗桃子"></p><p>在汤阴县汤河公园休息了半个小时。</p><p><img src="https://images.happy365.day/24/06/20222321_30C36983-099B-452A-9EDA-5F74D2006929_1_102_o.jpeg" alt="汤河公园"></p><p>有机会也去林州市、西井山看看。</p><p><img src="https://images.happy365.day/24/06/20222405_31CAF7CC-5A22-419B-BF7C-889ACE883A0B_1_102_o.jpeg" alt="林州市路标"></p><p>17:00，进入安阳市区。</p><p><img src="https://images.happy365.day/24/06/20222505_D8A2725B-792C-4645-9140-F27F43F1702B_1_102_o.jpeg" alt="安阳市区"></p><p>万达广场的冒菜，好评。</p><p><img src="https://images.happy365.day/24/06/20222544_0EF38C38-786F-4513-B618-3D3AA527720B_1_102_o.jpeg" alt="晚饭"></p><p>I 💛 安阳</p><p><img src="https://images.happy365.day/24/06/20222627_3368FD40-5F9D-48A2-823A-485EBB97BE99_1_102_o.jpeg" alt="广告"></p><p>明天在安阳休整一天，后天进入河北省，到邢台市。</p>]]></content>
      
      
      <categories>
          
          <category> 日志随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骑行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>骑行_深圳至北京_PART3_长沙至孝感</title>
      <link href="/2024/06/19/42363581058a/"/>
      <url>/2024/06/19/42363581058a/</url>
      
        <content type="html"><![CDATA[<h2 id="DAY11"><a href="#DAY11" class="headerlink" title="DAY11"></a>DAY11</h2><p><strong>湖南省长沙市岳麓区 至 湖南省岳阳市岳阳楼区 146km</strong></p><p>今天又是里程破纪录的一天。</p><p>今天天气还可以，上午出了一会儿太阳，中午一点多开始阳光时有时无，不是很晒。</p><p>上午主要走县道和 S210 省道，省道路况非常好，感觉好像在高速公路上骑行一样。</p><p>十二点到达汨罗市区，本来想找个店吃饭喝点东西的，但是我导航直接导的岳阳县，直接从市区西部走过去了，没吃上饭。</p><span id="more"></span><p>离开市区后在汨罗江大桥旁看到一个亭子，过去吃了点零食、睡了半个多小时午觉。一点钟从汨罗江大桥出发。</p><p>汨罗江大桥上全部是端午节相关的标语。看汨罗市区里的宣传也都是和屈原相关。240国道中间绿化带上的龙舟柱子，一直从汨罗市区延续十几公里到与岳阳县交界处。</p><p>汨罗这个城市很特别。一路绿化带上种的很多果树：市区行道树下是石榴、240国道旁是紫叶李。地名也很新奇，很多在最后一个字都包含了姓氏：南坡徐、北塘张，很有意思。屈原大道上的水果店数不胜数，汨罗人都很爱吃水果吗？进去看了，都是常规的水果。</p><p>下午17:30到达岳阳市岳阳楼景区，本来想去岳阳楼看看的，没想到居然要门票，就作罢了。什么都围起来收费，不理解也不支持。</p><p>湖南这边很多城市市和县同名，但又不在一个地方：衡阳市衡阳县、湘潭市湘潭县、长沙市长沙县、岳阳市岳阳县。</p><p>国道上一路看到很多动物的尸体，以鸟类居多，还有些青蛙、老鼠之类的动物。</p><p>明天的目的地：湖北省赤壁市嘉鱼县。终于要进入湖北省了，希望别下雨。</p><!-- more --><p>7:20 过湘江。</p><p><img src="https://images.happy365.day/24/06/20143438_417DA521-A56F-424E-A8E4-4C790D9FCEEE_1_102_o.jpeg" alt="湘江大桥"></p><p>县道旁美丽的田野和村庄。</p><p><img src="https://images.happy365.day/24/06/20143534_E45DD2C2-1567-4963-A1D2-553CC47D5739_1_102_o.jpeg" alt="美丽的田野和村庄"></p><p><img src="https://images.happy365.day/24/06/20143636_C0BDA079-7B74-4CC2-8653-0B9AAD4A952C_1_102_o.jpeg" alt="美丽的田野和村庄"></p><p>远处是一条路吗？这个坡度真的有车敢走吗？</p><p><img src="https://images.happy365.day/24/06/20143701_A883199D-DC65-489F-BE1F-3C3794585200_1_102_o.jpeg" alt="很陡的一条路"></p><p>美丽的村庄和田野。</p><p><img src="https://images.happy365.day/24/06/20143753_C24DC9FC-E4A1-4AA9-A331-8FAE9F4674DC_1_102_o.jpeg" alt="美丽的村庄和田野"></p><p><img src="https://images.happy365.day/24/06/20143838_11D94428-9D77-4C3A-9F75-F2857DBD2430_1_102_o.jpeg" alt="美丽的村庄和田野"></p><p>汨罗界。</p><p><img src="https://images.happy365.day/24/06/20143900_0D0125D9-9B9B-4CB8-AAA3-61FE27CEE883_1_102_o.jpeg" alt="汨罗界"></p><p>9:48，距离今天的目的地岳阳还有92公里。</p><p><img src="https://images.happy365.day/24/06/20143939_8E384F38-0E88-4BD1-B6E0-759ADBDB4D6C_1_102_o.jpeg" alt="路标"></p><p>除了长沙，一路平坦很了很多。</p><p><img src="https://images.happy365.day/24/06/20144043_11FCE0AA-EAEC-4E36-8062-EF464F885913_1_102_o.jpeg" alt="村庄"></p><p>10:51，距离岳阳75公里。</p><p><img src="https://images.happy365.day/24/06/20144119_522E350C-0932-490F-A581-D6759239D9FB_1_102_o.jpeg" alt="路标"></p><p>12:00 左右从汨罗市经过，没吃午饭，在路边的亭子里打了会儿瞌睡到 13:00 才出发。</p><p><img src="https://images.happy365.day/24/06/20144202_1A53FFC6-EF23-465E-A4A4-303DC39A434C_1_102_o.jpeg" alt="汨罗市的公园"></p><p>漂亮的金丝桃。</p><p><img src="https://images.happy365.day/24/06/20144307_68920D8E-6F0E-4AAB-883C-A7F99DE7957D_1_102_o.jpeg" alt="金丝桃"></p><p>汨罗江大桥。很多关于端午的宣传标语。</p><p><img src="https://images.happy365.day/24/06/20144335_44A9493E-B082-46B4-AD7D-CAB294EFEDCA_1_102_o.jpeg" alt="汨罗江大桥"></p><p>13:10，距离岳阳还有 59 公里。</p><p><img src="https://images.happy365.day/24/06/20144415_84CCF6A2-3D94-44A8-A685-D26E4EC3DC22_1_102_o.jpeg" alt="路标"></p><p>路边全是紫叶李，摘了几个，还挺好吃的。因为路边灰尘多、汽车尾气多，所以没敢多摘。</p><p><img src="https://images.happy365.day/24/06/20144503_97775B97-8CF0-43A7-B483-97E67C2CB143_1_102_o.jpeg" alt="紫叶李"></p><p>14:14 进入岳阳县。</p><p><img src="https://images.happy365.day/24/06/20144628_15F34C8C-D9F8-4901-AF52-7D6F7D947D78_1_102_o.jpeg" alt="岳阳县界"></p><p>15:20 进入岳阳县城区。</p><p><img src="https://images.happy365.day/24/06/20144716_8E46CFF7-6E56-4ED0-9982-4C64074F11DB_1_102_o.jpeg" alt="岳阳县城区"></p><p>出岳阳县，路过一个湖泊。</p><p><img src="https://images.happy365.day/24/06/20144803_58490B9C-4C0F-46C7-A482-FB12DC45BD63_1_102_o.jpeg" alt="不知名湖泊"></p><p>16:05 距离岳阳市区还有 19 公里。</p><p><img src="https://images.happy365.day/24/06/20144838_8E099750-9976-4C0C-9E5C-A910604A1724_1_102_o.jpeg" alt="路标"></p><p>17:33 到达岳阳市岳阳楼景区附近，看了一下岳阳楼要收费，就没进去。</p><p><img src="https://images.happy365.day/24/06/20144920_8D3203F3-E0E8-47ED-BF45-A1D9E46C1456_1_102_o.jpeg" alt="岳阳楼景区"></p><p>今天的行程结束。</p><h2 id="DAY12"><a href="#DAY12" class="headerlink" title="DAY12"></a>DAY12</h2><p><strong>湖南省岳阳市岳阳楼区 至 湖北省咸宁市嘉鱼县 122.2km</strong></p><p>昨天晚上睡觉时在小雨，担心今天早上也会下雨，起来看了下，还好，从隔壁楼的玻璃上看到了太阳的反光。</p><p>快骑出城了也没看路边有卖包子油条豆浆的，只看到两三家卖粉的，味道还不好，难道岳阳人早上都自己做早餐的吗。</p><p>骑到云溪区，遇到一条蛇在路上，不知道是不是被车压到了，刚好在我正前方，差点压到，吓了我一跳。</p><p>上午一路沿着 S208 骑，一直骑到了这条路的起点黄盖湖镇。一点钟出了黄盖湖镇进入长江大堤，就算是出了湖南省，进入湖北省赤壁市。在两省交界的地方，遇到一个对面骑过来的人，问候了一下。</p><p>将近两点到达三国赤壁古战场景区，在沙县大酒店吃了碗炒粉，休息了二十分钟继续出发。</p><p>下午的路都在长江大堤上，骑了三十多公里，下午四点半进入嘉鱼县。</p><p>接下来的计划：明天到孝感，后天到信阳，然后看情况，在信阳休整一天。</p><p>在岳阳吃的早餐，很难吃的粉💩。</p><p><img src="https://images.happy365.day/24/06/20145404_DE529A39-0820-42E3-8EC1-26A62DA5BA83_1_102_o.jpeg" alt="早餐"></p><p>早晨的洞庭湖。</p><p><img src="https://images.happy365.day/24/06/20145452_6FFA90F0-F796-4992-9070-41E38B7AF8F3_1_102_o.jpeg" alt="洞庭湖"></p><p>云溪区的田野。</p><p><img src="https://images.happy365.day/24/06/20145539_E3A52A95-57D9-469E-A8F6-877883669AD4_1_102_o.jpeg" alt="田野"></p><p>9:47 进入临湘市。</p><p><img src="https://images.happy365.day/24/06/20145609_142D80DB-E52A-4151-80E6-1E41A027B71A_1_102_o.jpeg" alt="临湘市"></p><p>一望无际的大平地，真羡慕啊。</p><p><img src="https://images.happy365.day/24/06/20145706_D1646596-0E56-48E3-84E5-6CD075D53C91_1_102_o.jpeg" alt="田野"></p><p><img src="https://images.happy365.day/24/06/20145734_1A7C64A5-5D20-4FC6-B623-2448558E328C_1_102_o.jpeg" alt="田野"></p><p>笔直的路一眼望不到头。</p><p><img src="https://images.happy365.day/24/06/20145759_3340C758-EB80-4856-A403-9AE4D87E548E_1_102_o.jpeg" alt="路"></p><p>11块钱买了个西瓜🍉，没什么味道。大热天的在国道边上卖瓜，这些瓜农也不容易。</p><p><img src="https://images.happy365.day/24/06/20145849_78682E06-7AB3-4199-8D53-61BFBF76FDDB_1_102_o.jpeg" alt="西瓜"></p><p>热。省道还有 4 公里就到头了，省道的尽头就该进入湖北省了。</p><p><img src="https://images.happy365.day/24/06/20150040_9837235C-E5E2-4BE7-97D4-9D852E40AFE8_1_102_o.jpeg" alt="省道"></p><p>核酸检测点。嗓子好痒啊，好想做核酸。</p><p><img src="https://images.happy365.day/24/06/20150136_4F6F9DE0-3726-4AE4-A41F-21295FDEAE21_1_102_o.jpeg" alt="核酸检测点"></p><p>湖北省赤壁市的小村庄。</p><p><img src="https://images.happy365.day/24/06/20150243_44C20390-4856-4B93-B848-4C2A2DBEF4A1_1_102_o.jpeg" alt="村庄"></p><p>关于三国历史的一个景点。顺便吃个午饭。</p><p><img src="https://images.happy365.day/24/06/20150321_3336FB3F-BF70-42BE-B277-9D4FE9C69326_1_102_o.jpeg" alt="赤壁"></p><p>车少人少，穿林而过的公路，让人心情舒畅。</p><p><img src="https://images.happy365.day/24/06/20150411_63DD8795-567D-48EF-B6B5-3DB36E7FA91B_1_102_o.jpeg" alt="林间公路"></p><p>在长江大堤公路上看到了长江。</p><p><img src="https://images.happy365.day/24/06/20150539_706E83C8-7E71-4227-B37C-664BF6D68CEC_1_102_o.jpeg" alt="长江大堤公路"></p><p><img src="https://images.happy365.day/24/06/20150656_CF18A0BC-9AFF-4CEA-9D42-79C4EE3C4896_1_102_o.jpeg" alt="长江大堤公路"></p><p>长江。</p><p><img src="https://images.happy365.day/24/06/20150717_FFC322B7-C44D-49B2-98EF-6EAB9F4520A8_1_102_o.jpeg" alt="长江"></p><p>16:20，远处的嘉鱼县城区。</p><p><img src="https://images.happy365.day/24/06/20150742_1EE0A1DA-9837-4A9F-A731-844F486D1695_1_102_o.jpeg" alt="嘉鱼县"></p><p>16:35 进入嘉鱼县。</p><p><img src="https://images.happy365.day/24/06/20150818_28BA6C75-F2D3-47BC-A88C-A4C83E676D55_1_102_o.jpeg" alt="嘉鱼县"></p><p>今天的行程结束。</p><h2 id="DAY13"><a href="#DAY13" class="headerlink" title="DAY13"></a>DAY13</h2><p><strong>湖北省咸宁市嘉鱼县 至 湖北省孝感市孝南区 135km</strong></p><p>早上因为天气阴雨不定，等到快 9 点才嘉鱼县出发。</p><p>沿着省道、长江大堤骑行，11:40 到达簰洲湾渡口，刚好错过十一点半的轮渡，只能等下午一点钟的班次，就这样在长江边上坐了一个多小时。应该是人生中第二次坐轮渡，上次是在广州。过长江大约10分钟的时间，15块钱，说实话感觉有点贵，主要是一些当地做工的人在利用，我还以为可能和公交差不多。</p><p>上午晚出发加上轮渡耽搁，上午就骑了50公里多一点，剩下近90公里的路程是下午完成的。午饭也没来得及吃，四点多在武汉蔡甸区一个加油站买了盒饼干填肚子。</p><p>六点左右进入孝感时开始下小雨，将近一个小时到市区路上已经有积水，车上、鞋上全是泥浆。如果早上能按时出发也不会有这么多事，感觉走到哪儿雨下到哪儿，很烦。</p><p>在孝感找了住处放好东西之后，去旁边的万达广场转了一下，吃了晚饭，还在miniso买了个小手提袋，放在车把手上放东西，还挺合适。</p><p>明天计划 120km 进入信阳市，希望是个好天气。</p><p>8:33 从嘉鱼县出发。</p><p><img src="https://images.happy365.day/24/06/20151135_64A954C5-FB47-4B44-91B6-57EBFC14653C_1_102_o.jpeg" alt="嘉鱼县一中"></p><p>这边种荷花🪷的人家很多。</p><p><img src="https://images.happy365.day/24/06/20151220_CF55DB9A-2F8C-46FF-9AB9-26CEC138EA1D_1_102_o.jpeg" alt="荷花"></p><p>10:59 进入武汉境内了。</p><p><img src="https://images.happy365.day/24/06/20151254_41D563AC-42CA-471C-AD71-56ADB1E4A950_1_102_o.jpeg" alt="武汉"></p><p>接天莲叶无穷碧。</p><p><img src="https://images.happy365.day/24/06/20151335_4CA9A6E2-8B59-4796-A5AA-35154A5544A5_1_102_o.jpeg" alt="荷花"></p><p>长江边上，好大一片玉米🌽和好大一片南瓜🎃</p><p><img src="https://images.happy365.day/24/06/20151437_7DC83100-D720-45ED-B12F-61A84508E70E_1_102_o.jpeg" alt="玉米"></p><p><img src="https://images.happy365.day/24/06/20151453_B697642D-1E46-4DF2-A7BC-FF47E3CA1FFB_1_102_o.jpeg" alt="南瓜"></p><p>11:40 到达渡口，错过了 11:30 的轮渡⛴️，需要等下午一点钟的班次，耽搁一个多小时。</p><p><img src="https://images.happy365.day/24/06/20151511_8D5888F2-E917-42A4-9C5F-0E39B518CEED_1_102_o.jpeg" alt="渡口"></p><p>轮渡过江。</p><p><img src="https://images.happy365.day/24/06/20151616_185B06AF-5E9D-4BFF-B34C-57F387B225AB_1_102_o.jpeg" alt="轮渡"></p><p>武汉市蔡甸区不知名大桥。</p><p><img src="https://images.happy365.day/24/06/20151642_77740FE4-DD97-42C4-807E-192794034957_1_102_o.jpeg" alt="大桥"></p><p>被修剪之后又冒出头的月季。</p><p><img src="https://images.happy365.day/24/06/20151706_06357C70-85EA-4217-A280-2976F867A1FA_1_102_o.jpeg" alt="月季"></p><p>武汉超短地铁🚇</p><p><img src="https://images.happy365.day/24/06/20151753_3DD60A88-50BB-4E46-9D10-8CC65B8BF71F_1_102_o.jpeg" alt="地铁"></p><p>17:55，距离孝感还有 22 公里。</p><p><img src="https://images.happy365.day/24/06/20151834_8F7BB20D-0CA9-4005-B31D-DDF9400B142B_1_102_o.jpeg" alt="路标"></p><p>17:58，距离北京广安门外还有 1287 公里。</p><p><img src="https://images.happy365.day/24/06/20151923_DB75ED86-1DCF-4AB6-85BA-E7FAA51A6009_1_102_o.jpeg" alt="路标"></p><p>18:25，冒着小雨进入孝感市区。</p><p><img src="https://images.happy365.day/24/06/20152016_1C75B9A9-3E6E-40A7-8757-C2B2002E0A71_1_102_o.jpeg" alt="孝感市区"></p><p>夜晚的孝感市街道。</p><p><img src="https://images.happy365.day/24/06/20152049_F72258C7-410E-48F5-8014-0A8F0DC6F315_1_102_o.jpeg" alt="孝感市区"></p><p>今天的行程结束，明天在孝感市休息一天，后天去信阳。</p>]]></content>
      
      
      <categories>
          
          <category> 日志随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骑行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>骑行_深圳至北京_PART2_连州至长沙</title>
      <link href="/2024/06/19/bd9b305cd0ae/"/>
      <url>/2024/06/19/bd9b305cd0ae/</url>
      
        <content type="html"><![CDATA[<h2 id="DAY6"><a href="#DAY6" class="headerlink" title="DAY6"></a>DAY6</h2><p><strong>广东省清远市连州市 至 湖南省郴州市宜章县 103.1km</strong></p><p>早上 9:45 快要进入湖南省境内时遇到第一次爆胎，前轮被一根小铁丝扎了。正在路边停下来，遇到一位对面过来的骑友，年龄和我差不多，打了个招呼。两个人都没有补胎经验，花了差不多一个小时把胎补好了。闲聊了一下，他是阳山县人，在连州市星子镇一个中学教地理。今天是周末，想骑到湖南去，但是坡太多，于是返回了。</p><span id="more"></span><p>今天的路还可以，下午连续下了好几公里的坡，下午 4 点过到达郴州市宜章县。</p><p>今晚住在宜章一中旁边，出去吃饭的时候路上遇到很多回学校的学生，看着他们身着校服、三三两两有说有笑的样子，突然有一点对学生时代的怀念。</p><!-- more --><p>记个单词先。</p><p><img src="https://images.happy365.day/24/06/20115916_EF304B5D-E95F-4B70-AFC2-1B55E7870602_1_105_c.jpeg" alt="quaint"></p><p>路边绿油油的稻田。</p><p><img src="https://images.happy365.day/24/06/20120026_0BE1284E-669E-4E1F-BA54-1010D577CE97_1_105_c.jpeg" alt="稻田"></p><p>路过星子镇。旁边还有个地名叫大路边镇。</p><p><img src="https://images.happy365.day/24/06/20120116_13159EB3-472C-48A8-A690-85F4C9B49226_1_105_c.jpeg" alt="星子镇"></p><p>远处的许广高速。在这儿上坡发现踩不动，下车看了一下，前轮气已经漏光了。</p><p><img src="https://images.happy365.day/24/06/20120202_6CB05C02-C712-432C-BF03-A2670EE7671C_1_105_c.jpeg" alt="许广高速"></p><p>罪魁祸首。</p><p><img src="https://images.happy365.day/24/06/20120320_965D417D-9357-433A-A73F-48976E1ED74D_1_105_c.jpeg" alt="扎胎"></p><p>第一次补胎。耽搁了整整一个小时。</p><p><img src="https://images.happy365.day/24/06/20120347_09240DFA-90F9-4DBA-A1E1-2DC38E2D8C41_1_105_c.jpeg" alt="补胎"></p><p>湖南界。11:17 终于出广东，进入湖南境内了。</p><p><img src="https://images.happy365.day/24/06/20120436_0CC4A716-9163-4C5C-A4EF-9B4295E85940_1_105_c.jpeg" alt="湖南界"></p><p>中午还是老样子，青椒炒鸡蛋🫑🥚</p><p><img src="https://images.happy365.day/24/06/20120540_7B5EB038-5E7C-4706-AB90-9BBDE143EDB6_1_102_o.jpeg" alt="青椒炒蛋"></p><p>山路十八弯。</p><p><img src="https://images.happy365.day/24/06/20120658_5BE6B032-34C5-4625-AF1D-F2949B636BDC_1_102_o.jpeg" alt="爬坡"></p><p>牛角山。小雨🌧️，路边刚好有个亭子，在这里躲雨。</p><p><img src="https://images.happy365.day/24/06/20121121_3A214510-FCE6-406E-BD2C-BD87529D8ECD_1_102_o.jpeg" alt="躲雨"></p><p>又下小雨🌧️，在一个废弃棚下躲雨。</p><p><img src="https://images.happy365.day/24/06/20120800_6E2C13A8-0A69-4BA4-AC45-7BD5D0806E62_1_102_o.jpeg" alt="小雨"></p><p>美丽的田野。</p><p><img src="https://images.happy365.day/24/06/20121247_631D35C7-EA86-4FAB-B5A4-C6D1E6BF6E4E_1_102_o.jpeg" alt="美丽的田野"></p><p>14:49，距离宜章县 18 km。</p><p><img src="https://images.happy365.day/24/06/20120858_DB47F676-1565-4191-8E59-57875DD035B4_1_102_o.jpeg" alt="路标"></p><p>雨后的山。</p><p><img src="https://images.happy365.day/24/06/20121002_6BD39F74-3456-4097-B19E-7ECA1D8A0532_1_102_o.jpeg" alt="雨后的山"></p><p>16:12 进入宜章县城区。</p><p><img src="https://images.happy365.day/24/06/20121038_3FDF2508-4D1E-469B-977A-5E5B372430D8_1_102_o.jpeg" alt="达到宜章县"></p><p>今天的行程结束。</p><h2 id="DAY7"><a href="#DAY7" class="headerlink" title="DAY7"></a>DAY7</h2><p><strong>湖南省郴州市宜章县 至 湖南省郴州市北湖区 53.94km</strong></p><p>一天都在断断续续的下雨，今天直接摆烂，没怎么骑。</p><p>出宜章县城区就是一个 3km 的连续上坡，后来看行者地图才知道是4级坡，一步没推，硬骑上来了。</p><p>骑了不到一个小时，又爆胎了，补上之后发现轮胎不止一个地方漏，补了两个地方还是不行，直接换了条新的内胎。</p><p>走了一条县道，没什么车，风景也很美，路两边都是绿树和各种盛开的野花，这样的田间小道真的多少次也骑不腻，羡慕这里的人能生活在这么漂亮的地方。</p><p>还在路边遇到了3只小野猪，毛都被雨淋了，在路边吃草，很可爱。</p><p>下午四点钟快到郴州市区时，遇到一个山西骑过来的骑友，已经骑了一个多月、1500多公里。这个时间他还要赶到宜章县，发现我骑得是真的慢。但是我也一直没想明白为什么骑这么快，一个多月只骑了1500公里。</p><p>3km 的坡之后，有一个短短的下坡。</p><p><img src="https://images.happy365.day/24/06/20122003_B02B8DAA-D00A-4636-9834-4B2B9429B1A9_1_102_o.jpeg" alt="下坡"></p><p>出发 10km 不到，又下半个多小时的大雨🌧️</p><p><img src="https://images.happy365.day/24/06/20122100_C07EC321-E7BB-4D8B-916B-1784D106CCCB_1_102_o.jpeg" alt="下雨"></p><p>上场雨结束不到半小时，又开始下小雨🌧️</p><p><img src="https://images.happy365.day/24/06/20122154_14933D55-A6C0-4DAA-A68E-D16B8DC7A657_1_102_o.jpeg" alt="小雨"></p><p>一个不怎么壮观的瀑布。</p><p><img src="https://images.happy365.day/24/06/20122248_EA6A4A4A-FAD5-4004-8CFD-A4C1EE0458F1_1_105_c.jpeg" alt="瀑布"></p><p>11点，又扎胎了！补胎耽搁一个小时。</p><p><img src="https://images.happy365.day/24/06/20122327_F5C25216-C04B-49EC-9DCD-59E151023743_1_105_c.jpeg" alt="爆胎"></p><p>罪魁祸首。</p><p><img src="https://images.happy365.day/24/06/20122409_4705ACCD-72E1-427D-B2C9-C6477CA15472_1_105_c.jpeg" alt="扎胎"></p><p>湘南的村庄，乌云密布。</p><p><img src="https://images.happy365.day/24/06/20122447_73ED50B1-6B87-4A23-95A0-BF0641CD8F72_1_105_c.jpeg" alt="村庄"></p><p>乌云仿佛要把山压垮了。田地里很多插秧的村民。</p><p><img src="https://images.happy365.day/24/06/20122602_1D92FBEA-9E45-42F2-8BE6-76D79A82501C_1_105_c.jpeg" alt="乌云"></p><p>村庄左侧是普速铁路，右侧是高速铁路。</p><p><img src="https://images.happy365.day/24/06/20122707_ECA6BFCB-5266-402F-8AE9-96140444CD7F_1_105_c.jpeg" alt="普速列车"></p><p><img src="https://images.happy365.day/24/06/20122751_1B1BB120-2903-4113-9787-38E24C82C852_1_105_c.jpeg" alt="高速列车"></p><p>又开始下雨🌧️，在铁路下方的桥洞里躲雨。</p><p><img src="https://images.happy365.day/24/06/20122835_DE1BC712-31DA-40BB-B712-C254FF2DA3F9_1_102_o.jpeg" alt="桥洞里躲雨"></p><p>走了不到半小时，又下雨。</p><p><img src="https://images.happy365.day/24/06/20123633_A2A5E523-F22B-424A-843B-E427FA6B2AF4_1_102_o.jpeg" alt="下雨"></p><p>美丽的菊科植物。</p><p><img src="https://images.happy365.day/24/06/20123248_BAA16570-3A6F-4229-9F35-0C2480B17C43_1_102_o.jpeg" alt="菊花"></p><p><img src="https://images.happy365.day/24/06/20123006_3CDFFF71-CD18-4ED8-9666-E29756B7A808_1_102_o.jpeg" alt="菊花"></p><p><img src="https://images.happy365.day/24/06/20123404_6D4F77CC-0134-4F51-9DCA-D9733B01537D_1_102_a.jpeg" alt="菊花"></p><p><img src="https://images.happy365.day/24/06/20124924_BAA16570-3A6F-4229-9F35-0C2480B17C43_1_102_o.jpeg" alt="菊花"></p><p>乡道的路两边全是这种小花，最美的路段。</p><p><img src="https://images.happy365.day/24/06/20124956_0DF9241C-7161-4A07-AABE-4908FF1A07DB_1_102_o.jpeg" alt="路边的野花"></p><p>路边看到3只野猪🐗，拍了1分钟的视频才发现忘记按开始了！！</p><p><img src="https://images.happy365.day/24/06/20125101_099F6B0C-6FF3-4F68-BDA9-D3A0CA2EE623_1_102_o.jpeg" alt="野猪"></p><p><img src="https://images.happy365.day/24/06/20125238_1A0A72F8-C3E4-4279-9280-F345FDED14E0_1_102_o.jpeg" alt="乡道"></p><p><img src="https://images.happy365.day/24/06/20125300_F8C2E06E-9623-4DB2-B3AF-96B87B7B5CAD_1_102_o.jpeg" alt="乡道"></p><p><img src="https://images.happy365.day/24/06/20125323_76B0518D-9961-45FC-AB6D-98BCA106B69D_1_102_o.jpeg" alt="乡道"></p><p>16:20 进入郴州市区。</p><p><img src="https://images.happy365.day/24/06/20125344_1100DC42-9F83-445F-9E57-3FA1EE256834_1_102_o.jpeg" alt="郴州市区"></p><p>夜幕降临的郴州市区。</p><p><img src="https://images.happy365.day/24/06/20125430_491DBE24-2867-49F3-88A0-61BB0E19026E_1_102_o.jpeg" alt="郴州市区"></p><p>今天的行程结束。</p><h2 id="DAY8"><a href="#DAY8" class="headerlink" title="DAY8"></a>DAY8</h2><p><strong>湖南省郴州市北湖区 至 湖南省衡阳市衡南县 131.3km</strong></p><p>因为计划今天到衡南县，有一百三十多公里，会比较远，早上 6 点起来，收拾好行李，6:30 就出发。</p><p>骑了不到1小时，后轮又爆胎了。因为后轮比较麻烦，要弄链条、刹车之类，比较脏，就索性在附近找了个修车店。</p><p>修车的是个大爷，手脚都比较慢，补了快一个小时才补好。</p><p>昨天晚上看天气预报说今天全天没有雨，刚到补胎的地方，雨就下起来了。补胎躲雨差不多一个小时。十一点了才骑了二十来公里，担心今天能不能到衡南县。</p><p>补胎走了没多远，又碰上107国道在修路，连续好几公里路面的水泥和沥青全部被刮掉了，坑坑洼洼的，下过雨之后路上全是淤泥坑，龟速骑了半个多小时才走完，车上鞋上腿上行李包上全是白色泥浆。</p><p>车上的泥沙导致骑车很费力，只能一档二档骑，平路三档都很费力。过了耒阳市，下午才有所好转。</p><p>下午为了赶路，路上也没怎么拍照，也没吃中午饭。下午两点多到达耒阳市，在路边的奶茶店喝了一杯奶茶，歇了半小时左右继续赶路。</p><p>除了修路的五六公里路之外，其他的路况都挺好，路肩很宽。</p><p>下午六点到达衡南县洛夫公园。虽说是公园，好像就是江边以前的野草丛，还有很多地方都被附近的人除了草种上了各种蔬菜。</p><p>出门没多久，又是扎胎又是半个多小时的小雨🌧️</p><p><img src="https://images.happy365.day/24/06/20130007_F637F5EC-86BD-42CF-8A73-A5270A674B36_1_102_o.jpeg" alt="小雨"></p><p>好几公里修路🚧，骑了快一个小时才走完，全身的泥浆。</p><p><img src="https://images.happy365.day/24/06/20130049_037FB161-1EAE-4793-8F2F-B93772B663B9_1_102_o.jpeg" alt="修路"></p><p>11:55，距离今天的目的地衡南县还有 86km。</p><p><img src="https://images.happy365.day/24/06/20130148_9DE2B903-BDCD-4B02-952A-4270A6B9A4EB_1_102_o.jpeg" alt="路标"></p><p>在路边买了几个柚柑还是啥来着，籽多水少，味道一般。</p><p><img src="https://images.happy365.day/24/06/20130229_5D60A82F-651A-4F29-B8BE-FC3BD6CE9125_1_102_o.jpeg" alt="柚柑"></p><p>12:23 进入衡阳市。</p><p><img src="https://images.happy365.day/24/06/20130328_EF34EA64-2CA5-4DB1-B300-F7710C0B673C_1_102_o.jpeg" alt="衡阳市"></p><p>14:27 进入耒阳市区，太热了，喝杯奶茶🥤</p><p><img src="https://images.happy365.day/24/06/20130404_8DBDFA98-5A8B-45B2-92E0-32B96BBB0A9B_1_102_a.jpeg" alt="喝奶茶"></p><p>全是起伏路。</p><p><img src="https://images.happy365.day/24/06/20130535_4A0566BF-1EAF-4544-A0AE-4A9AE584426C_1_102_o.jpeg" alt="起伏路"></p><p><img src="https://images.happy365.day/24/06/20130508_69541D10-E502-4C90-8CC6-46E390FFAE23_1_102_o.jpeg" alt="111.9km"></p><p><img src="https://images.happy365.day/24/06/20130627_8E6D5120-B808-44B3-8427-0B3617142E99_1_102_o.jpeg" alt="起伏路"></p><p>18:00，到达衡南县。</p><p><img src="https://images.happy365.day/24/06/20130732_3764D02A-D220-4065-BBCE-B1BF91A80641_1_102_o.jpeg" alt="衡南县"></p><p><img src="https://images.happy365.day/24/06/20130910_D7DF5B7C-1E15-4366-B9A9-E1A891F6488E_1_102_o.jpeg" alt="衡南县"></p><p><img src="https://images.happy365.day/24/06/20130808_73098583-84FA-44FE-81EC-3FFDF4181EDE_1_102_o.jpeg" alt="不知名的花"></p><p>满身的泥浆。</p><p><img src="https://images.happy365.day/24/06/20130932_C6A84D11-2FCA-41E7-AA47-4BA0D6921120_1_102_o.jpeg" alt="满身的泥浆"></p><p>今天的行程结束。</p><h2 id="DAY9"><a href="#DAY9" class="headerlink" title="DAY9"></a>DAY9</h2><p><strong>湖南省衡阳市衡南县 至 湖南省湘潭市湘潭县 143.8km</strong></p><p>早上七点四十吃了早餐出发。早餐摊上全是幼儿园小孩和接送的家长，几乎都是女性。旁边的药店的喇叭里放着一首很好听的歌《放心微微笑》（后来才知道楼下有药店多么痛苦！）</p><p>下午走了一段县道经过萱洲镇，好像是这个文化旅游小镇，路旁边都是盛开的格桑花，很漂亮。这边好像桃树种植很多，一路上道路两边都在卖桃子和李子，买了5个桃子花了8块多，还以为在乡下路边买会很便宜，不知道是不是被坑了。</p><p>快进入湘潭县的时候，看到路边有几棵很大的杨梅树，走过来一个45左右的人，说是他哥哥家的，没人在家，让我想吃就摘点装着，酸酸甜甜，很好吃。</p><p>注意到两件事：</p><p>1、一路上基本所有城市城区所在地海拔都比较低，所以基本上都是下坡进城，上坡出城。</p><p>2、这边的商店里会把槟榔摆在最显眼的地方，甚至超过了烟，小商店空间不够大的直接把槟郎放在了门前。</p><p>今天都在赶路，基本没怎么拍照。</p><p>今天天气还挺好，没下雨，大多数时间都是阴天，骑了 140km 车也不怎么脏。</p><p>下午 5:30 进入湘潭县，比计划提前一个半小时，天还没黑。</p><p>单日骑行距离最远，打算明天到长沙休整两天。</p><p>7:25，早餐。最近食量变大了，之前一天一顿饭都没啥胃口，现在破纪录的早餐能吃两个包子一杯豆浆🥛了。</p><p><img src="https://images.happy365.day/24/06/20131550_102F20DA-4A13-4325-BDCF-E927386EA4A0_1_102_a.jpeg" alt="早餐"></p><p>吃早餐的学生和学生家长，绝大多数是女性。</p><p><img src="https://images.happy365.day/24/06/20131710_7E0F3A48-CA34-495A-B0BD-7736A8D0A239_1_102_o.jpeg" alt="吃早餐学生和学生家长"></p><p>经过衡阳市区。</p><p><img src="https://images.happy365.day/24/06/20131850_AD8CAD80-B63B-4D96-A55E-0DFF99A38B97_1_102_o.jpeg" alt="衡阳市区"></p><p>11:06，距离湘潭县还有 106 公里。</p><p><img src="https://images.happy365.day/24/06/20131912_4560D95D-4EAA-420E-B80B-02CAC0016385_1_102_o.jpeg" alt="路标"></p><p>又有县道可以走啦！这条路会经过宣洲镇。</p><p><img src="https://images.happy365.day/24/06/20131944_0C6B6D65-5931-42DE-ADE7-03DCD46712AD_1_102_o.jpeg" alt="县道"></p><p>路边的花。</p><p><img src="https://images.happy365.day/24/06/20132051_B9B3FA82-2DDC-4F74-8C8B-530E6B539082_1_102_o.jpeg" alt="路边的花"></p><p>中午吃了青椒炒蛋粉，老板的女儿热情有礼貌，喝了两瓶王老吉，差点少收我 4 块钱。</p><p><img src="https://images.happy365.day/24/06/20132121_493687C0-23A8-4387-823E-5B565A56A4F2_1_102_o.jpeg" alt="午饭"></p><p>经过衡山县。</p><p><img src="https://images.happy365.day/24/06/20132253_77517090-4E24-46E2-94E7-83397E3A4FF6_1_102_o.jpeg" alt="衡山县"></p><p>快进入湘潭县时，路边人家的杨梅，因为没人摘，地上掉了一大片。主人家很热情，让我摘点装着路上吃。</p><p><img src="https://images.happy365.day/24/06/20132326_EE80AA8F-2030-4CD9-A832-1C53634ACF78_1_102_o.jpeg" alt="杨梅"></p><p><img src="https://images.happy365.day/24/06/20132447_9AE4FF0C-3248-4FF1-81A3-B992E40AA2E4_1_102_o.jpeg" alt="杨梅"></p><p><img src="https://images.happy365.day/24/06/20132508_127E84DD-8572-408D-8C10-7D97E3F4F1C7_1_102_o.jpeg" alt="杨梅"></p><p>爬上一个大坡，14:46 进入湘潭县。</p><p><img src="https://images.happy365.day/24/06/20132533_30BA2ABC-D90C-4A1C-98DA-F89FF3298257_1_102_o.jpeg" alt="进入湘潭县"></p><p>路过齐白石中学🏫。后面还路过齐白石故居，书画小镇。</p><p><img src="https://images.happy365.day/24/06/20132620_765EFC19-08AF-4003-BCD3-E73104448D32_1_102_o.jpeg" alt="齐白石中学"></p><p>16:56，距离湘潭县 16km。</p><p><img src="https://images.happy365.day/24/06/20132751_6F17F316-9635-4231-B16C-04AEED59B708_1_102_o.jpeg" alt="路标"></p><p>17:31 进入湘潭县城。</p><p><img src="https://images.happy365.day/24/06/20132836_6B87AF91-64C7-4E0F-B329-513647A4BDAB_1_102_o.jpeg" alt="湘潭县城"></p><p>在湘江边上休息一下。</p><p><img src="https://images.happy365.day/24/06/20132913_160B70BB-8BA7-42B4-A180-07F57869E43D_1_102_o.jpeg" alt="湘江"></p><p>远处正在建设的桥梁🌁</p><p><img src="https://images.happy365.day/24/06/20132955_D35E072A-EFB4-40EC-8E62-2868C8F89DC7_1_102_o.jpeg" alt="正在建设的桥梁"></p><p>今天的行程结束。</p><h2 id="DAY10"><a href="#DAY10" class="headerlink" title="DAY10"></a>DAY10</h2><p><strong>湖南省湘潭市湘潭县 至 湖南省长沙市岳麓区 58.19km</strong></p><p>今天冒着小雨沿着湘江穿过湘潭市区，到达长沙市岳麓区茶子山地铁站附近。因为避雨一路走走停停，58公里路程从上午九点骑到下午三点。</p><p>在长沙市区休整两天，顺便见一见朋友。</p><p>早上又是小雨🌧️</p><p><img src="https://images.happy365.day/24/06/20133343_1701E325-6069-4A05-A303-3821D24C69D9_1_102_o.jpeg" alt="小雨"></p><p>才早上八点半就开始打麻将，真悠闲。</p><p><img src="https://images.happy365.day/24/06/20133251_74523B9E-C522-4352-9D87-1FD8845932C6_1_102_o.jpeg" alt="打麻将的人"></p><p>穿过湘潭市区。</p><p><img src="https://images.happy365.day/24/06/20133432_B58411FF-658C-4626-92A2-F6F89249725B_1_102_o.jpeg" alt="湘潭市区"></p><p>接近长沙市界，快要下雨了。</p><p><img src="https://images.happy365.day/24/06/20133516_26A7CF73-711D-4741-A6E8-B9A2F82A98D3_1_102_o.jpeg" alt="下雨"></p><p>11:22，下雨🌧️，在地铁高架下躲了快一个小时的雨。</p><p><img src="https://images.happy365.day/24/06/20133636_FE09CA8D-C67C-49D0-A748-AEB28B1F1644_1_102_o.jpeg" alt="下雨"></p><p>没走多远，达到长沙地铁西环线黄家湾站，又开始下雨。在地铁站桥下多了半个小时的雨。甚至感觉穿个速干衣有点冷。</p><p><img src="https://images.happy365.day/24/06/20133716_A74ABD22-853B-4B08-8791-7A026D6FDE5A_1_102_o.jpeg" alt="下雨"></p><p>什么 mini 地铁，为了拍个照片，耽搁二十分钟。</p><p><img src="https://images.happy365.day/24/06/20133839_CE4FC318-32D6-47EF-BF0D-0F988335D5D3_1_102_o.jpeg" alt="mini地铁"></p><p>13:36，快达到目的地了，吃个午饭🥣</p><p><img src="https://images.happy365.day/24/06/20133924_5F7FA96B-CC26-4CF1-B951-16F4D654C264_1_102_o.jpeg" alt="吃午饭"></p><p><img src="https://images.happy365.day/24/06/20133956_854F6267-1B28-4905-9A93-C8DC67946067_1_102_o.jpeg" alt="吃午饭"></p><p>路过湘江公园，很漂亮。在这里上学应该很幸福☺️</p><p><img src="https://images.happy365.day/24/06/20134031_7124BEFB-A0F4-42FF-9D96-ABBFEB227077_1_102_o.jpeg" alt="湘江公园"></p><p>下午三点到达茶子山附近，今天的行程结束。</p><p>在长沙休整两天。</p><p>又见交通安全员，一个路口投入好几个人，令人感叹。</p><p><img src="https://images.happy365.day/24/06/20134308_C88FB568-97BE-414D-A0D0-F1B2F9E114D3_1_102_o.jpeg" alt="交通安全员"></p><p>第一次喝茶颜悦色。我不是一个跟风的人，甚至别人越跟风什么，我会越讨厌什么，但是我不会在别人面前表现出来，让别人尴尬或是难堪。</p><p><img src="https://images.happy365.day/24/06/20134431_801DB8C8-6BA9-4A83-B472-D8192A6CDA86_1_102_o.jpeg" alt="茶颜悦色"></p><p>吃完饭回宾馆的地铁上，两个女孩子在开心的自拍🤳</p><p><img src="https://images.happy365.day/24/06/20134642_13514F88-D224-4B09-BCF0-473C504FE88B_1_102_o.jpeg" alt="两个自拍的女生"></p>]]></content>
      
      
      <categories>
          
          <category> 日志随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骑行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>骑行_深圳至北京_PART1_深圳至连州</title>
      <link href="/2024/06/19/6a2c08f6ea04/"/>
      <url>/2024/06/19/6a2c08f6ea04/</url>
      
        <content type="html"><![CDATA[<h2 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a>DAY1</h2><p><strong>广东省深圳市罗湖区 至 广东省东莞市长安镇 76km</strong></p><p>出发的第一天，心里很忐忑，早上还有小雨。一边犹豫不决一边等雨停，八点多雨停了，鼓起勇气出发。先去了这次长途的起点：文锦渡口岸。八点雨停出发，十点到达文锦渡口岸。</p><p>在文锦渡口岸拍了个照休息了几分钟，然后算是正式踏上旅途。</p><p>一路上还比较顺利，中途也没有下雨，一路沿着广深公路的非机动车道骑行，下午六点到达长安镇霄边广场。</p><span id="more"></span><p>小车与107国道终点里程碑合影。刚出发，一位路过的大爷过来问我的车在哪儿买的、多少钱，说还挺好看的。</p><p><img src="https://images.happy365.day/24/06/19142909_4D0CE89E-8F9D-4550-9709-1C3219D4F50D_1_102_o.jpeg" alt="与107终点里程碑合影"></p><p>银湖山下的不知名公园，雨后显得很宁静。</p><p><img src="https://images.happy365.day/24/06/19143203_D5327DF7-DA84-4DF8-89F6-927192DD7898_1_102_o.jpeg" alt="不知名公园"></p><p>最喜欢的一段路，深圳华侨城湿地公园？绿油油的草地上点缀着星星点点的黄色小花，很漂亮。</p><p><img src="https://images.happy365.day/24/06/19143313_2CF0B10D-D30F-4A1B-A330-8D1086176FD3_1_102_o.jpeg" alt="林间小路"></p><p>初夏，路边繁花盛开，心情舒畅。</p><p><img src="https://images.happy365.day/24/06/19144218_BFCE63AD-F90C-471F-BC51-36C1BACDE6C9_1_102_o.jpeg" alt="花"></p><p>下午5:55进入东莞市。路边的里程碑显示2597，107国道全程2698km，到这里骑了101公里。</p><p><img src="https://images.happy365.day/24/06/19144413_0B25F2B0-DA4F-4A4E-B16F-F4D64A3E7D4E_1_102_o.jpeg" alt="东莞市界"></p><p>18:06 到达长安霄边广场，今天的行程结束。</p><p><img src="https://images.happy365.day/24/06/19144713_5E3A6DCB-A64A-4230-A3CC-19AC31DEB1CE_1_102_o.jpeg" alt="长安霄边广场"></p><p>今天是5月20日，晚上吃饭时看到饭店里的桌上放着一束花。</p><p><img src="https://images.happy365.day/24/06/19145129_12790B03-361C-4C75-ADBB-4ED765E21CCA.heic" alt="饭店里的花"></p><h2 id="DAY2"><a href="#DAY2" class="headerlink" title="DAY2"></a>DAY2</h2><p><strong>广东省东莞市长安镇 至 广东省广州市天河区 95km</strong></p><p>早上五点半醒来外面在下雨，睡到七点半起来雨还是没停。在楼下吃了份蒸饺。九点雨终于停了，趁着这个间隙开始了第二天的行程。才下楼还没上国道，绑带卡到后拨里去了，后轮动不了，也拉不出来。想把后拨给松开但是工具不太好用，索性打了个车找了家电动车修理店，老板把后拨螺丝送了一下就拉出来了。</p><p>弄到10:35才出发。</p><p>大岭山的非机动车道修的很好，人也很少，上午骑得很舒服。遇到两个年纪比较大的骑友，看行李应该也是长途骑行，一路骑了几公里，最终还是没上去打个招呼。</p><p>遇到两次小雨，在比亚迪专卖店前的路口，后轮打滑了一下，差点喜提第一摔。（很幸运，本次骑行全程未摔车）</p><p>中午在东莞东城南站附近吃了个饭，休息了半个小时。这个青椒炒鸡蛋做得很棒，从来没吃过做得这么好的，料足味道好。</p><p>下午路过东莞的很多河流，我发现这边的桥大多都是拱桥，遇桥必爬坡。</p><p>三点二十左右进入广州，一路经过广深大道东、广深大道中、广深大道西，这条路专门修了一条辅道供非机动车通行，骑行感受属于上等。</p><p>晚上快七点到达天河区棠下村，出去吃了个木桶饭，又是青椒炒鸡蛋。</p><p>回来时去旁边的菜市场看了一下，竟然看到了杏子，可惜看起来已经不新鲜了，不然还想买点。</p><p>繁忙的107国道。出发就失去方向！错综复杂的立交桥，又怕误上机动车道，找了两圈路，晕头转向😵‍💫。找到路后，又开始下小雨🌧️。</p><p><img src="https://images.happy365.day/24/06/19150108_7DB3637F-8DF3-4AF8-AAFF-B801201657B2_1_102_o.jpeg" alt="错综复杂的立交桥"></p><p>雨后的山上云雾缭绕，犹如仙境。</p><p><img src="https://images.happy365.day/24/06/19150430_001B2DAD-8837-44C6-95CD-FA5664CDBE72_1_102_o.jpeg" alt="雨后的山"></p><p>12:25，距离广州47km。</p><p><img src="https://images.happy365.day/24/06/19150533_AA4411BA-65B4-4D44-9E91-E2D960523894_1_102_o.jpeg" alt="距离广州47km"></p><p>数一数二好吃的青椒炒鸡蛋，量大味美价优。</p><p><img src="https://images.happy365.day/24/06/19150620_D8411786-83D5-40E3-BFC1-A4AD15AED452_1_102_o.jpeg" alt="青椒炒鸡蛋"></p><p>中途下雨，在桥下躲雨，一个吃力的拖着行李箱路过阿姨，世人皆苦。</p><p><img src="https://images.happy365.day/24/06/19150750_862B76FC-EE39-4BBB-A28D-CE8A86F9824B_1_102_o.jpeg" alt="一个吃力的拖着行李箱路过阿姨"></p><p>15:18 进入广州。</p><p><img src="https://images.happy365.day/24/06/19150923_8AED25DC-72CB-4367-951B-261B65C4F0C9_1_102_o.jpeg" alt="广州界"></p><p>某楼盘下：天降巨款、平安喜乐、成功上岸、事事顺心，谢谢祝福🙏</p><p><img src="https://images.happy365.day/24/06/19151021_55356959-4F2B-47E3-99A3-2F71C6AFFF31_1_102_o.jpeg" alt="横幅"></p><p>又是小雨，在天桥下躲雨。</p><p><img src="https://images.happy365.day/24/06/19151146_5C94B5AD-3AF4-4A67-A77B-8D553FC6BFB6_1_102_o.jpeg" alt="天桥下躲雨"></p><p>19:30 到达棠下村。刚想拍照，一个大爷过去坐着了😓</p><p><img src="https://images.happy365.day/24/06/19151307_5216842D-1CF3-4C69-8F16-B86A092ACDD6_1_102_o.jpeg"></p><p>猫困在宠物店里，人大概也一样。</p><p><img src="https://images.happy365.day/24/06/19151431_EF59AA13-6FC0-4270-BA74-D23C33FAB020_1_102_o.jpeg" alt="困在宠物店里的猫"></p><p>第二天的行程结束。</p><h2 id="DAY3"><a href="#DAY3" class="headerlink" title="DAY3"></a>DAY3</h2><p><strong>广东省广州市天河区 至 广东省清远市清新区 100km</strong></p><p>早上7点出发，今天没下雨，十点多开始断断续续出太阳。下午三点半到清远酒店一看，手臂和膝盖黑了一大截，明天要把裤袜穿上了。</p><p>花了一上午才骑出广州，十点半还在花都区的路上看到广州地铁花城站的路标，广州地铁厉害👍</p><p>上午一路上经过了白云山入口、华南师范大学等地方，很多地方都没拍照。</p><p>经过一个可以摘桃子的果园，说是种的台湾什么桃子，现在正是采摘的季节。30块钱一个人，时间也是有的，但是想着一个人摘也没意思，就没进去。</p><p>今天没怎么按107国道走，完全跟着导航走，县道、乡道都有，还经过了几个村庄，还好没被狗追。</p><p>下午1点多实在骑不动了，在离清城站20公里的地方吃了份炒河粉。</p><p>后面基本走广清大道，走了十几公里，非机动车道很宽敞，车也少，很好走，就是树荫有点少。</p><p>第一次折叠车单日骑行超100km，还以为今天可能到不了，没想到下午3点过就到了。</p><p>下一个目的地阳山县，开始翻粤北的山了，有点忐忑。明天预计骑个60km左右到石潭镇就不错了，后天才能到阳山县，大后天到连州，真不知道什么时候能出广东。</p><p>清晨的路上，尽是学生和送学生的家长，求学也很辛苦啊💦，希望以后能有个好结果。</p><p><img src="https://images.happy365.day/24/06/19152425_96924666-ED89-40C5-B242-A6195EA359D8_1_102_o.jpeg" alt="清晨的路上很多学生"></p><p>骑车戴头盔，这么一件小事，都要投入大量人力，耳提面命，令人感叹。</p><p><img src="https://images.happy365.day/24/06/19152643_EBF50370-38F1-4FDE-82D4-7968E7BE09EF_1_102_o.jpeg" alt="交通安全劝导"></p><p>路边休息，可以看到白云机场飞过来的飞机，真快。</p><p><img src="https://images.happy365.day/24/06/19152925_086306D9-C489-47DE-8038-2F3CA87381E0_1_102_o.jpeg" alt="路边休息"></p><p>花都区，路边几百米全是理发的。</p><p><img src="https://images.happy365.day/24/06/19153027_24017177-DBD3-4B0B-8E72-1599FA14C284_1_102_o.jpeg" alt="路边理发"></p><p>广州地铁花城路站。从这里坐地铁到珠江新城有几个站？</p><p><img src="https://images.happy365.day/24/06/19153146_6F3BB980-43B6-4505-BACD-C6FE34316B98_1_102_o.jpeg" alt="广州地铁花城路站"></p><p>花瓣落在草地上，像是草地上开出的花。</p><p><img src="https://images.happy365.day/24/06/19153303_A60D1E3E-D112-43FB-AFF3-3265B36D4BFF_1_102_o.jpeg" alt="落花"></p><p>广州郊区，无边无际的苗木基地。</p><p><img src="https://images.happy365.day/24/06/19153402_3B9D75B0-4400-41B6-9C28-CAED67FD4D14_1_102_o.jpeg" alt="苗木基地"></p><p>广州花都马岭观花植物园中的水库，旁边有两个女生在拍照。</p><p><img src="https://images.happy365.day/24/06/19153512_C478DF0D-458A-4F9C-9108-119D93CC2269_1_102_o.jpeg" alt="水库"></p><p>这边种玉米都是一颗一颗的种，新奇。</p><p><img src="https://images.happy365.day/24/06/19153637_016159D2-C0A7-4B1E-B37B-ACBCD5D66ADE_1_102_o.jpeg" alt="玉米"></p><p>半边月村，名字好听。</p><p><img src="https://images.happy365.day/24/06/19153743_9F8D1BB8-3FC4-42B8-8E9D-3572D5C47EDF_1_102_o.jpeg" alt="半边月村"></p><p>清远北站（还以为是高铁站，结果好像是汽车站？），今天的终点。</p><p><img src="https://images.happy365.day/24/06/19153937_02F57FFB-83F2-421D-B941-67B6CC78F19F_1_102_o.jpeg" alt="清远北站"></p><h2 id="DAY4"><a href="#DAY4" class="headerlink" title="DAY4"></a>DAY4</h2><p><strong>广东省清远市清新区 至 广东省清远市阳山县 135.2km</strong></p><p>昨天那个旅店老板人还不错，看我推车上楼比较麻烦，让我放在一楼。</p><p>又一次打破单日骑行最远记录，而且今天爬升1150m，翻了好几座山，中途下雨还在树下等了半个多小时。</p><p>粤北的风景真漂亮，有山有水，尤其是鱼水村，宛如人间天堂。下了几公里的坡穿村而过的时候，遇到两个骑自行车从旁边经过的中学女生，我很羡慕她们能在这个风景优美的地方出生长大。</p><p>上午走107国道，没有非机动车道，大车又很多，喇叭的声音能吓死人。十点半到一个河边去洗脸，满脸的黑色粉尘洗都洗不下来，再也不想走国道了，下午走了县道和乡道，虽然爬坡很多，但是雨后的风景也很漂亮，还不用吃灰。</p><p>本来昨天晚上计划今天只到石潭镇，没想到没有想象中那么多难，上午十一点多就走完了60km，下午直接奔阳山来了。</p><p>明天计划到连州，才70km不到，应该会比较轻松。计划到了连州休整一下。</p><p>6:20 的清远街头，一如既往的学生和接送的家长。</p><p><img src="https://images.happy365.day/24/06/19154506_3BEAD923-DAB1-4F3E-8A70-B7BE207CF134_1_102_o.jpeg" alt="清晨的清远市街头"></p><p>出城前买瓶水。</p><p><img src="https://images.happy365.day/24/06/19154643_291E0160-30F6-4E11-90DF-9CE80C5CDB76_1_102_o.jpeg" alt="加油站买水"></p><p>清晨雨雾缭绕的群山。</p><p><img src="https://images.happy365.day/24/06/19154723_162852AD-0AA0-4D35-B2B2-A56A2CEA4406_1_102_o.jpeg" alt="云雾缭绕的群山"></p><p>连续下坡😄</p><p><img src="https://images.happy365.day/24/06/19154826_3E741C24-B440-4916-A3DD-0A739267AD73_1_102_o.jpeg" alt="连续下坡"></p><p>偶遇一个公园，抄近路，远处的桥就是107国道。顺便在河里洗了个脸、脚，全是洗不下来的黑色灰尘，再也不想走国道了！</p><p><img src="https://images.happy365.day/24/06/19154948_38FC8DAB-8B34-4EF8-8579-F2524B29A70B_1_102_o.jpeg" alt="公园"></p><p>宁静的绿道两旁是大片绿油油的稻田，风景如画。</p><p><img src="https://images.happy365.day/24/06/19155139_B6CA6C0A-5DAC-476C-B6AB-99469FFB651D_1_102_o.jpeg" alt="绿油油的稻田"></p><p>从石潭镇出发。</p><p><img src="https://images.happy365.day/24/06/19155313_FCB39C38-5B59-4641-AE20-9C290B9E72BE_1_102_o.jpeg" alt="绿油油的草地"></p><p>风景优美、宁静空旷的县道。</p><p><img src="https://images.happy365.day/24/06/19155409_690F558B-6747-411B-9E15-1F2F76BD79A5_1_102_o.jpeg" alt="县道"></p><p>村落。</p><p><img src="https://images.happy365.day/24/06/19155518_4687F305-9C38-4986-AD95-2E1C2F40B6B3_1_102_o.jpeg" alt="村落"></p><p>死亡爬坡，年少的我此时还不知道，这不是爬坡，这是爬山，要爬山顶！</p><p><img src="https://images.happy365.day/24/06/19155550_E8DB63B6-76FD-4F46-B82A-EE3839E33567_1_102_o.jpeg" alt="弯多坡长"></p><p>远处的山头正在下雨。</p><p><img src="https://images.happy365.day/24/06/19155702_329D3CAA-9A52-44AA-89D6-823539D0B258_1_102_o.jpeg" alt="远处下雨的山头"></p><p>在我的以前的认识里，这个地方应该在广西。</p><p><img src="https://images.happy365.day/24/06/19155808_2ECB25B2-6A67-4D75-9127-B8EA2EDA3091_1_102_o.jpeg" alt="山丘"></p><p>继续S弯爬坡。</p><p><img src="https://images.happy365.day/24/06/19155919_99379E13-6AFC-4548-ADD2-B78CDF7EE14F_1_102_o.jpeg" alt="继续爬坡"></p><p>雨下过来了，在这棵树下躲了半小时的雨。</p><p><img src="https://images.happy365.day/24/06/19160002_D0ACC774-6D92-4888-BD3F-6A2421A36C5F_1_102_o.jpeg" alt="躲雨"></p><p>雨后的山里雾气缭绕。</p><p><img src="https://images.happy365.day/24/06/19160112_2F5FA600-E9A9-47C3-A372-BED45DA11CBD_1_102_o.jpeg" alt="雨后的山"></p><p>我以为到山顶了，结果还差点。</p><p><img src="https://images.happy365.day/24/06/19160213_85DE4448-182A-4BCE-B062-2F957D97F588_1_102_o.jpeg" alt="垭口"></p><p>15:09 终于开始下坡。</p><p><img src="https://images.happy365.day/24/06/19160306_42B50900-21FD-44C9-89B6-BFCD93052D7F_1_102_o.jpeg" alt="连续下坡"></p><p>秀美的山峰，难得的一小段平路。</p><p><img src="https://images.happy365.day/24/06/19160415_78AEE027-B978-40FE-8723-3F101E79EF51_1_102_o.jpeg" alt="山"></p><p>死亡爬坡，估计有百分之十几，推车都吃力。</p><p><img src="https://images.happy365.day/24/06/19160528_94B720F3-FF3D-4823-B1D2-5DE76F3ED8C0_1_102_o.jpeg" alt="爬坡"></p><p>继续爬坡。</p><p><img src="https://images.happy365.day/24/06/19160621_C1A34FB8-4BDF-4194-A051-FEE1B8E5451E_1_102_o.jpeg" alt="继续爬坡"></p><p>穿过小村子爬上来的。</p><p><img src="https://images.happy365.day/24/06/19160809_84261CE7-4F04-40E0-98E8-95CC03CEEC7D_1_102_o.jpeg" alt="穿过小村子爬上来的"></p><p>一路上遇到好几个大洞。</p><p><img src="https://images.happy365.day/24/06/19160906_508CF4D5-771D-43B4-AB97-2C193AC8636F_1_102_o.jpeg" alt="洞穴"></p><p>开始下坡，四五公里的坡，从来没下过这么长的坡。</p><p><img src="https://images.happy365.day/24/06/19160953_B9F12ACE-3ECC-47AF-B65F-7E4857FD8F78_1_102_o.jpeg" alt="开始下坡"></p><p>人间仙境-鱼水村。</p><p><img src="https://images.happy365.day/24/06/19161106_22CAB790-4770-4267-8A78-0D4B54FE8672_1_102_o.jpeg" alt="鱼水村"></p><p><img src="https://images.happy365.day/24/06/19161212_579457B9-49A1-4A85-B41A-606E40438A29_1_102_o.jpeg" alt="鱼水村"></p><p>迎着夕阳，一路十几公里的平路进入阳山县城。</p><p><img src="https://images.happy365.day/24/06/19161304_FD9EFE80-51A1-4CCF-8AE7-11BF262289BD_1_102_o.jpeg" alt="平路"></p><p>到达阳山县城。</p><p><img src="https://images.happy365.day/24/06/19161436_8E7E3E3C-B770-46F2-8B59-BFB21E2530DE_1_102_o.jpeg" alt="阳山县"></p><p>今天总共爬升将近 1200 米，总行程 135 公里，强度最大的一天。</p><h2 id="DAY5"><a href="#DAY5" class="headerlink" title="DAY5"></a>DAY5</h2><p><strong>广东省清远市阳山县 至 广东省清远市连州市 60.22km</strong></p><p>昨天看了下路线，阳山县离连州市不是很远，于是早上放心的睡到了七点钟才起床。在附近吃了一个包子、一杯豆浆，还额外吃了一碗肠粉。</p><p>顺着107国道出阳山县城，一路顺着连江骑了20公里平路到小江镇。有了昨天的经验，今天又选择走县道和乡道，虽然从阳山出来107国道车很少而且已经有路肩够非机动车走了。沿着384县道、934乡道爬了两座山，今天推车推了两三公里，中午十二点半左右到达西江镇。在西江镇路边的饭店吃了个午饭，因为太阳太大，一直休息到 13:40 才出发。看了一下地图，顺着107国道进入连州市的话，后面还要骑十几公里的回头路，权衡之下，没有往连州市内去，而是改为到龙坪镇。</p><p>去超市买了点肥皂🧼、牙膏之类的生活用品。</p><p>中午还是大太阳，下午就下了一场大雨。</p><p>晚上洗了衣服，明天后天在这里休整一下。</p><p>骑了5天，回过头看，不知不觉粤北已经走过了大半，之前一直让我忧心忡忡的岭南山区，也不过如此！看地图后面湘南地区爬坡会好一些，最难走的路已经快走完了。</p><p>从阳山县出发，应该会是很热的一天。</p><p><img src="https://images.happy365.day/24/06/19162022_72F6F016-398A-4821-9B1C-8AFF9F80D3C7_1_102_o.jpeg" alt="出阳山县"></p><p>出城后沿着连江骑了十几公里平路，不想再走国道，于是绕路开始爬山。</p><p><img src="https://images.happy365.day/24/06/19162143_49DDA0E5-AC92-4A16-9AC4-796B9AD16965_1_102_o.jpeg" alt="爬山前的村庄"></p><p>在山里回望来时的村子。</p><p><img src="https://images.happy365.day/24/06/19162329_8DA7653F-CE7D-4275-B878-166285794FEA_1_102_o.jpeg" alt="来时的村子"></p><p>顶着太阳爬山。</p><p><img src="https://images.happy365.day/24/06/19162435_56C53FA8-5A54-465D-98E9-EF3FC409FBFF_1_102_o.jpeg" alt="爬山"></p><p>在树荫下死亡爬坡…不，是推车。</p><p><img src="https://images.happy365.day/24/06/19162510_19C9CE2C-C2F4-4A69-BDB5-7257BE5374C1_1_102_o.jpeg" alt="死亡爬坡"></p><p>爬坡。</p><p><img src="https://images.happy365.day/24/06/19162609_192BA5C1-8101-450E-8619-FA29E07ADB93_1_102_o.jpeg" alt="爬坡"></p><p>11:45 开始下坡，只不过只有很小一段。下坡之后进入323国道。</p><p><img src="https://images.happy365.day/24/06/19162651_23065328-CF5B-4664-B4B3-A4291F423A20_1_102_o.jpeg" alt="下坡"></p><p>爬坡。</p><p><img src="https://images.happy365.day/24/06/19162800_C4B276CE-2111-4B36-9DFC-E6BF34866884_1_102_o.jpeg" alt="爬坡"></p><p>进入龙坪镇之前，遇到一片桃林🍑，可惜找不到主人，想吃🤤</p><p><img src="https://images.happy365.day/24/06/19162846_1BE00555-87D9-4410-98DB-A2DA078DD388_1_102_o.jpeg" alt="桃林"></p><p>路过村子，云很壮观。</p><p><img src="https://images.happy365.day/24/06/19162943_7391DA4B-8CC6-426E-9D8C-40497900C90D_1_102_o.jpeg" alt="村子"></p><p>15:30 到达龙坪镇。</p><p><img src="https://images.happy365.day/24/06/19163032_EB8801F0-A982-4896-84CA-B30B7DED3AD4_1_102_o.jpeg" alt="龙坪镇"></p><p>傍晚时分静谧的龙坪镇。</p><p><img src="https://images.happy365.day/24/06/19163126_B8B1015E-0740-4AF0-8031-89E12A77DFD3_1_102_o.jpeg" alt="龙坪镇"></p>]]></content>
      
      
      <categories>
          
          <category> 日志随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骑行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions报错：fatal: could not read Password for &#39;https://***@github.com&#39;: No such device or address</title>
      <link href="/2024/05/15/368f0e609534/"/>
      <url>/2024/05/15/368f0e609534/</url>
      
        <content type="html"><![CDATA[<p>今天给博客添加一个友链时，发现过了十几分钟页面都没有更新。最初怀疑是 CloudFlare 缓存的原因，等了半小时无果后，就在 CloudFlare 开启了开发模式并清空了缓存，但是发现还是没更新。然后去看了 GitHub 静态文件仓库，发现最新一次提交还是 2 天前，顺着检查了源文件仓库的自动部署任务，发现有错误：<code>fatal: could not read Password for &#39;https://***@github.com&#39;: No such device or address</code>，因为 Actions 的 push 代码后加了 <code>|| echo &quot;nothing to commit&quot;</code>，所以无论 push 成功与否，Actions 任务都会成功结束。</p><span id="more"></span><p>知道了是密码错误导致 push 错误，想起前两天 GitHub 邮件提示有 token 即将过期，那就简单了，Regenerate 一下重新执行任务就完事了，然而更新 token 之后任务还是在 push 的时候报同样的错，有点不能理解了。</p><p>然后就理了一下，在 Actions 里引用的密码是这样的：</p><pre><code class="sh">git commit -m &quot;GitHub Actions Auto Builder at $(date +&#39;%Y-%m-%d %H:%M:%S&#39;)&quot; &amp;&amp; git push --force &quot;https://$&#123;&#123; secrets.HEXO_BLOG_DEPLOY_KEY &#125;&#125;@$GITHUB_REPO&quot; master:main || echo &quot;Nothing to commit&quot;</code></pre><p>但 Personal access token 中的 token 却是没有名称的，只有一个 note：</p><p><img src="https://images.happy365.day/24/05/15153542_Snipaste_2024-05-15_15-32-45.png" alt="Personl access token"></p><p>理了一下，将新的 token 的 value 更新到源文件仓库 Secrets and variables &gt; Actions &gt; Repository secrets 的 HEXO_BLOG_DEPLOY_KEY 中，再重新运行任务，就部署成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G107国道骑行计划</title>
      <link href="/2024/05/13/c5a3675fc06b/"/>
      <url>/2024/05/13/c5a3675fc06b/</url>
      
        <content type="html"><![CDATA[<br><br><p>早在 2017 年秋天在北京实习时，</p><p>就诞生了要骑一次 G107 国道全程的想法，</p><span id="more"></span><p>实习结束时甚至已经准备好了自行车和日程计划，</p><p>最后因为钱的问题未能成行。</p><br><br><p>时隔 7 年，</p><p>这个念头又在我的胸口燃烧，</p><p>白天让我心潮澎湃，</p><p>夜晚让我难以成眠。</p><br><br><p>我想，</p><p>是时候背起行囊，踏上旅途了，</p><p>骑上小折，忘记烦恼，</p><p>去看一看世界的繁华。</p>]]></content>
      
      
      <categories>
          
          <category> 日志随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骑行 </tag>
            
            <tag> G107国道 </tag>
            
            <tag> 折叠车 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20240420折叠车环马峦山骑行</title>
      <link href="/2024/04/20/9e7bd5f89727/"/>
      <url>/2024/04/20/9e7bd5f89727/</url>
      
        <content type="html"><![CDATA[<p>去年 12 月 30 日、12 月 31 日曾环深圳骑行一周。从葵涌公园至大梅沙途中经过马峦山，后半段10公里左右全是山林郊游绿道，路况很好，人很少，但是坡也很多。11 点从葵涌公园出发，13:10 到达大梅沙。</p><span id="more"></span><p>去年年底的照片已归档，放一张上个月爬大梧桐时的照片。</p><p><img src="https://images.happy365.day/24/04/20195025_IMG_1901.jpeg" alt="大梧桐"></p><p>爬坡虽然辛苦，却也是骑行途中最难忘的一部分，一直想着有时间再回去骑一次这段路。担心自己拖延最后不了了之，今年特意把环盐田骑行加到了全年计划里。下周五一假期要回家，如果这周末不去，后面离职之后可能就没机会去了，就把计划放在了周六。南方快进入雨季了，这周的天气不是很稳定，周三的时候就开始关注天气预报。昨天晚上因为临时和同事聚餐还睡的很晚，大概 2 点才睡，一直担心自己可能睡过头。所幸今天早上 6 点按时起床，看了几个天气预报都显示降雨概率 8%，洗漱完就放心大胆的出门了，甚至连伞都没带。</p><p>6:50 下楼才发现，太阳已经快出来了。</p><p><img src="https://images.happy365.day/24/04/20190012_IMG_2096.jpeg" alt="出太阳了"></p><p>路边被雨淋了快要谢掉花。</p><p><img src="https://images.happy365.day/24/04/20190049_IMG_2101.jpeg" alt="花"></p><p>阴凉的非机动车道，人很少。</p><p><img src="https://images.happy365.day/24/04/20190131_IMG_2102.jpeg" alt="绿道"></p><p>快要遮住太阳的乌云，可别在下午 5 点前下雨啊！</p><p><img src="https://images.happy365.day/24/04/20190155_IMG_2106.jpeg" alt="乌云"></p><p>8:21 出平湖，进入东莞。</p><p><img src="https://images.happy365.day/24/04/20190221_IMG_2108.jpeg" alt="进入东莞"></p><p>9:35 到达龙东地铁站，骑了两个半小时，滴水未进。在地铁站旁边买了一盒早餐奶、一块米糕。</p><p><img src="https://images.happy365.day/24/04/20185627_IMG_2120.jpeg" alt="早餐"></p><p>9:59 到达坪山站。</p><p><img src="https://images.happy365.day/24/04/20190342_IMG_2126.jpeg" alt="坪山站"></p><p>坪山云巴。感觉只是比地铁车厢少，其实算是地铁了。</p><p><img src="https://images.happy365.day/24/04/20191629_IMG_2133.jpeg" alt="坪山云巴"></p><p>一朵开得非常娇艳的花。</p><p><img src="https://images.happy365.day/24/04/20191714_IMG_2136.jpeg" alt="花"></p><p>快到金龟社区，天很黑，感觉快下雨了。前面还有一个大坡要爬，山上连避雨的地方都难找。</p><p><img src="https://images.happy365.day/24/04/20191834_IMG_2147.jpeg" alt="乌云"></p><p>到到坡顶，开始下坡。3 分钟下完这个坡，就到葵涌了。</p><p><img src="https://images.happy365.day/24/04/20192027_IMG_2151.jpeg" alt="坡顶"></p><p>11:05 达到葵涌。</p><p><img src="https://images.happy365.day/24/04/20192226_IMG_2153.jpeg" alt="葵涌"></p><p>达到葵涌公园后，点了一份炒河粉。刚进店下完单，就流鼻血了。不知道是不是人少的原因，葵涌公园这里吃饭的店太少了。</p><p><img src="https://images.happy365.day/24/04/20192313_IMG_2156.jpeg" alt="流鼻血"></p><p>吃完东西去葵涌公园休息了一下，顺便上个厕所洗洗手。12:00 从葵涌公园出发。</p><p>很多推荐深圳游玩地点的自媒体上都出现过的海岸，好像附近就是“玫瑰海岸”。</p><p><img src="https://images.happy365.day/24/04/20192523_IMG_2167.jpeg" alt="海"></p><p>到了这里，我知道我要开始推车了，上次也是从这里开始推车，9% 的坡，小腿快断了都维持不了车不倒。半推半骑走了几百米，感觉小腿已经快抽筋了。</p><p><img src="https://images.happy365.day/24/04/20192940_IMG_2169.jpeg" alt="爬坡"></p><p>在这里遇到一个往回骑的公路车骑友，跟我说了一句“加油！“，虽然是走 S 线，这个坡一步也没推，骑上来了！</p><p><img src="https://images.happy365.day/24/04/20193140_IMG_2171.jpeg" alt="爬坡"></p><p><img src="https://images.happy365.day/24/04/20193410_IMG_2172.jpeg" alt="继续爬坡"></p><p>在坡顶休息了 10 分钟左右。上次在葵涌买了几个橘子，也是在这里休息，坐在这儿吃橘子。</p><p><img src="https://images.happy365.day/24/04/20193442_IMG_2175.jpeg" alt="休息"></p><p>13:49 ，终于爬完了所有的坡！从这里开始要连续大下坡了。</p><p><img src="https://images.happy365.day/24/04/20193624_IMG_2178.jpeg" alt="爬坡终点"></p><p>14:03 到达大梅沙地铁站，这个时间比从葵涌出发时苹果地图预估的时间快了 2 分钟，不得不说这个时间预测真的很准。去年年初来大梅沙地铁站还没开通，今年已经通车了。</p><p><img src="https://images.happy365.day/24/04/20193734_IMG_2179.jpeg" alt="大梅沙"></p><p><img src="https://images.happy365.day/24/04/20193853_IMG_2181.jpeg" alt="大梅沙"></p><p><img src="https://images.happy365.day/24/04/20193946_IMG_2182.jpeg" alt="大梅沙地铁站"></p><p>达到大梅沙，正准备去大梅沙海滩入口那里休息半小时左右，继续经盐田翻过伯公坳去黄贝岭，才走了没几步就开始下雨，只能到路边一家永和大王去避雨，出于面子，被迫点了一份最便宜的鱼香肉丝饭，这东西我根本不会吃，痛失 33 块钱。</p><p>避雨半小时到了 14:45，雨渐渐小了，地面也积水了。打消了继续骑到黄贝岭的念头，直接开启地铁传送。进站很顺利，没有被拦。</p><p><img src="https://images.happy365.day/24/04/20194620_IMG_2184.jpeg" alt="带自行车上地铁"></p><p>坐了一个小时地铁，16:10 到五和站，不坐地铁继续骑的话，大概才开始爬伯公坳。</p>]]></content>
      
      
      <categories>
          
          <category> 日志随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骑行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>订阅RSS并自动更新到博客内展示</title>
      <link href="/2024/04/16/80bdc9461149/"/>
      <url>/2024/04/16/80bdc9461149/</url>
      
        <content type="html"><![CDATA[<p>从 <a href="https://www.travellings.cn/go.html">开往</a> 进入到一个站点：若志随笔（<a href="https://rz.sb)/">https://rz.sb）</a></p><p>第一印象是这个域名很别致，4个字母加上弱智傻逼的首字母简写，简直是过目不忘的优质域名。</p><p>这个站点有个朋友圈的功能，就是定时更新别人发布的博客文章到自己的站点内，当然仅限于 title 和摘要内容。我也萌生了这样的想法，虽说很多人在交换友链，但是经常互相看看的应该少之又少。</p><p>说干就干，于是开始了新功能的开发计划。</p><span id="more"></span><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>首先要设计好数据链路：</p><ol><li>RSS 订阅（本想更新加了友链的这几个，但是很多都没有 RSS 订阅功能，只能订阅一些其他的订阅源）</li><li>写一个定时任务，定时获取 RSS 的 xml 文件</li><li>解析 RSS 的 xml 文件并加工成一个包含发布时间在前 n 的文章的 json 文件（moments.json）</li><li>在主题内增加一个 page，用来解析 moments.json 文件并展示（包含作者、作者主页、发布时间、标题、摘要）</li></ol><p>定时任务根据配置好的 atom.xml 文件地址获取文件暂存到本地，然后进行解析，解析的数据覆盖跟新到 source&#x2F;_data&#x2F;moments.json 文件中，然后 push 到博客源文件仓库，并重新执行发布操作，这样就完成了一次状态更新。</p><h2 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h2><p>仔细了解了 RSS ，文件格式统一，这样一来，解析就不是问题。</p><p>刚刚学会使用 GitHub Actions 进行博客静态文件部署，只知道可以配置定时任务，不确定是否可以在 task 中执行 python 脚本，包括文件操作、os 命令等。</p><p>后来网上找了一下，GitHub Actions 都支持，这产品体验确实没得说。</p><p>剩下的都不是问题了。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>先用静态的 moments.json 文件实现静态页面。</p><pre><code class="json">[  &#123;    &quot;author&quot;: &quot;优世界&quot;,    &quot;homepage&quot;: &quot;http://www.xiaoliu.life/&quot;,    &quot;title&quot;: &quot;最近整理的主机配置清单&quot;,    &quot;momentUrl&quot;: &quot;http://www.xiaoliu.life/p/20240415a/&quot;,    &quot;publishTime&quot;: &quot;2024-04-05 20:02:00&quot;,    &quot;summary&quot;: &quot;上山曲径通幽处,禅房花木深。喝水不容呀。蝉蜕化的壳。发现了“灵芝”。到达了山顶的“罗汉祖殿”。对面的山是我们村最高的山，爬的这座山是第二高。土地公小庙。下山发现草药，摘了回去炖肉。......&quot;  &#125;,  &#123;    &quot;author&quot;: &quot;lozhu&quot;,    &quot;homepage&quot;: &quot;http://www.xiaoliu.life/&quot;,    &quot;title&quot;: &quot;最近整理的主机配置清单&quot;,    &quot;momentUrl&quot;: &quot;http://www.xiaoliu.life/p/20240414b/&quot;,    &quot;publishTime&quot;: &quot;2024-04-05 20:02:00&quot;,    &quot;summary&quot;: &quot;上山曲径通幽处,禅房花木深。喝水不容呀。蝉蜕化的壳。发现了“灵芝”。到达了山顶的“罗汉祖殿”。对面的山是我们村最高的山，爬的这座山是第二高。土地公小庙。下山发现草药，摘了回去炖肉。......&quot;  &#125;]</code></pre><p><img src="https://images.happy365.day/24/04/17220007.png" alt="原型图"></p><p>页面很简单。</p><p>一直没有实现随机颜色的头像背景色。头像配合伪元素实现的，不知道怎么用 js 动态的改变伪元素的背景色。下面这种方式无法实现，而且就算实现了，改了一个伪类，所有的头像都会变成一个颜色，还是无法实现功能。</p><pre><code class="javascript">(function() &#123;    var avatarNodes = document.getElementsByClassName(&quot;avatar&quot;);    if (!avatarNodes || avatarNodes.length === 0) &#123;        console.log(&quot;节点元素不存在&quot;);    &#125;    for (var i = 0; i&lt; avatarNodes.length; i++) &#123;        var avatarNode = avatarNodes[i];        var val = avatarNode.getAttribute(&quot;value&quot;);        var str = &#39;&#39;;        for (var j = 0; j &lt; val.length; j++) &#123;            str += parseInt(val[j].charCodeAt(0), 10).toString(16);        &#125;        var bgColor = &#39;#&#39; + str.slice(1, 4);        avatarNode.setAttribute(&quot;data-content&quot;, bgColor);        console.log(&#39;val: &#39;, avatarNode.getAttribute(&quot;data-content&quot;));    &#125;&#125;)();</code></pre><h2 id="RSS-XML-解析"><a href="#RSS-XML-解析" class="headerlink" title="RSS XML 解析"></a>RSS XML 解析</h2><h3 id="python-脚本"><a href="#python-脚本" class="headerlink" title="python 脚本"></a>python 脚本</h3><p>因为 RSS xml 文件格式固定，使用 python xml.dom.minidom 库进行解析：</p><pre><code class="python">import xml.dom.minidomimport osimport timeimport reclass Moment:    author = &quot;&quot;    homepage = &quot;&quot;    title = &quot;&quot;    postUrl = &quot;&quot;    publishTime = &quot;&quot;    postSummary = &quot;&quot;    def __init__(self, author, homepage, title, postUrl, publishTime, postSummary):        self.author = author        self.homepage = homepage        self.title = title        self.postUrl = postUrl        self.publishTime = publishTime        self.postSummary = postSummaryclass Tool:    # 要订阅的网站    urls = []    # 处理指定日志之后更新的文章    moments = []    def __init__(self, urls, moments):        self.urls = urls        self.moments = moments    def parseInfo(self):                for url in self.urls:            # os.system(&quot;curl https://lozhu.happy365.day/atom.xml &gt; tmp.xml&quot;)            os.system(&quot;curl &quot; + url + &quot; &gt; tmp.xml&quot;)            # 打开xml文档            dom = xml.dom.minidom.parse(&quot;tmp.xml&quot;)            # 得到文档元素对象            root = dom.documentElement            # 获取作者名称            authorNodes = root.getElementsByTagName(&quot;author&quot;)            author = authorNodes[0].getElementsByTagName(&quot;name&quot;)[0].firstChild.data            # author            print(&quot;作者: &quot;, author)            # 获取主页链接            linkNodes = root.getElementsByTagName(&quot;link&quot;)            homepage = linkNodes[1].getAttribute(&quot;href&quot;)            # homepage            print(&quot;主页: &quot;, homepage)            postNodes = root.getElementsByTagName(&quot;entry&quot;)            if (postNodes is None):                print(&quot;一篇文章也没有&quot;)            for postNode in postNodes:                print(&quot;========&quot;)                # 文章标题                title = postNode.getElementsByTagName(&quot;title&quot;)[0].firstChild.data                print(&quot;文章标题: &quot;, title)                # 文章链接                postLinkNode = postNode.getElementsByTagName(&quot;link&quot;)[0]                postUrl = postLinkNode.getAttribute(&quot;href&quot;)                print(&quot;文章链接: &quot;, postUrl)                # 发布时间                publishTimeStr = postNode.getElementsByTagName(&quot;published&quot;)[0].firstChild.data                publishTime = publishTimeStr[0:10] + &quot; &quot; + publishTimeStr[11:19]                print(&quot;发布时间&quot;, publishTime)                # 文章摘要                postSummary = &quot;暂无文章摘要&quot;                if (len(postNode.getElementsByTagName(&quot;summary&quot;)) &gt; 0):                    postSummary = postNode.getElementsByTagName(&quot;summary&quot;)[0].firstChild.data                    postSummary = re.sub(r&#39;&lt;.*?&gt;&#39;, &#39;&#39;, postSummary)                    postSummary = re.sub(r&#39;&lt;\r\n&gt;&#39;, &#39;&#39;, postSummary)                    postSummary = re.sub(r&#39;[\n\&quot;\\]*?&#39;, &#39;&#39;, postSummary)                    if len(postSummary) &gt; 200:                        postSummary = postSummary[0:150]                    postSummary = postSummary + &quot;...&quot;                    print(&quot;文章摘要: &quot;, postSummary)                moment = Moment(author, homepage, title, postUrl, publishTime, postSummary)                self.moments.append(moment)    def writeContent(self, fullFilePath: str):        jsonStrs = []        sortedMoments = sorted(self.moments, key=lambda Moment: time.strptime(Moment.publishTime, &quot;%Y-%m-%d %H:%M:%S&quot;))        # 按发布时间倒序        sortedMoments.reverse()        # 如果有超过 50 篇的话，只展示前 50 篇        if (len(sortedMoments) &gt; 100):            sortedMoments = sortedMoments[0:100]        for moment in sortedMoments:            json = (&quot;  &#123;\n&quot;                        &quot;    \&quot;author\&quot;: \&quot;&quot; + moment.author + &quot;\&quot;,\n&quot;                        &quot;    \&quot;homepage\&quot;: \&quot;&quot; + moment.homepage + &quot;\&quot;,\n&quot;                        &quot;    \&quot;title\&quot;: \&quot;&quot; + moment.title + &quot;\&quot;,\n&quot;                        &quot;    \&quot;momentUrl\&quot;: \&quot;&quot; + moment.postUrl + &quot;\&quot;,\n&quot;                        &quot;    \&quot;publishTime\&quot;: \&quot;&quot; + moment.publishTime +&quot;\&quot;, \n&quot;                        &quot;    \&quot;summary\&quot;: \&quot;&quot; + moment.postSummary + &quot;\&quot;\n&quot;                    &quot;  &#125;&quot;)            jsonStrs.append(json)        momentContent = &quot;[\n&quot; + &#39;,\n&#39;.join(jsonStrs) + &quot;\n]\n&quot;        print(&quot;准备写入文件\n&quot;)        with open(fullFilePath, &quot;w&quot;) as f:            f.write(momentContent)            f.close()        print(&quot;写入文件完成\n&quot;)if __name__ == &#39;__main__&#39;:    urls = [&quot;https://www.xiaoliu.life/atom.xml&quot;, &quot;https://blog.bxzdyg.cn/atom.xml&quot;,    &quot;https://blog.liukuan.cc/atom.xml&quot;, &quot;https://www.xwsclub.top/atom.xml&quot;,    &quot;https://b.leonus.cn/atom.xml&quot;, &quot;https://liheyuting.github.io/atom.xml&quot;,    &quot;https://aciano.top/atom.xml&quot;, &quot;https://z.arlmy.me/atom.xml&quot;,    &quot;https://blog.starsharbor.com/atom.xml&quot;]    moments = []    tool = Tool(urls, moments)    tool.parseInfo()    tool.writeContent(&quot;source/_data/moments.json&quot;)    print(&quot;主函数处理完成\n&quot;)</code></pre><p>将脚本放在博客根目录下，定时执行：<code>python parse_feed.py</code>。</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>这里发现一个问题，atom.xml 里的摘要 summary 字段存放的是 html 源码，有些还带有样式，展示到摘要里观感很不好。这里使用了简单的正则表达式去除了部分标签，但是会有残留，不太好处理。</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>只支持 atom.xml 这样的 RSS 源。</p><h2 id="GitHub-Actions-定时任务配置"><a href="#GitHub-Actions-定时任务配置" class="headerlink" title="GitHub Actions 定时任务配置"></a>GitHub Actions 定时任务配置</h2><p>脚本内容如下：</p><pre><code class="yaml">name: update blogenv:  TZ: Asia/Shanghaion:  push:    branches:    - main  schedule:  - cron: &#39;0 0/2 * * *&#39;jobs:  fetch:    name: fetch rss post    runs-on: ubuntu-latest    steps:    - name: checkout actions      uses: actions/checkout@v4    - name: Set up Python 3.9      uses: actions/setup-python@v2      with:        python-version: 3.9            - name: fetch post list      run: |        python feed_parse.py            - name: commit      env:        GITHUB_REPO: github.com/lozhu20/blogsource      run: |        git config --global user.name lozhu20        git config --global user.email lozhu@icloud.com        git pull --rebase        git add .        git commit -m &quot;feed parse schedule task&quot; &amp;&amp; git push &quot;https://$&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;@$GITHUB_REPO&quot; main:main || echo &quot;Nothing to cmomit&quot;  blog-cicd:    name: Hexo blog build &amp; deploy    needs: fetch    runs-on: ubuntu-latest # 使用最新的 Ubuntu 系统作为编译部署的环境    steps:    - name: Checkout codes      uses: actions/checkout@v4    - name: Setup node      # 设置 node.js 环境      uses: actions/setup-node@v1      with:        node-version: &#39;18.x&#39;    - name: Cache node modules      # 设置包缓存目录，避免每次下载      uses: actions/cache@v1      with:        path: ~/.npm        key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125;    - name: Install hexo dependencies      # 下载 hexo-cli 脚手架及相关安装包      run: |        npm install -g hexo-cli        npm install    - name: Generate files      # 编译 markdown 文件      run: |        hexo clean        hexo generate    - name: Deploy hexo blog      env:         # Github 仓库        GITHUB_REPO: github.com/lozhu20/lozhu20.github.io      # 将编译后的博客文件推送到指定仓库      run: |        cd ./public &amp;&amp; git init &amp;&amp; git add .        git config user.name &quot;lozhu20&quot;        git config user.email &quot;lozhu@icloud.com&quot;        git add .        git commit -m &quot;GitHub Actions Auto Builder at $(date +&#39;%Y-%m-%d %H:%M:%S&#39;)&quot; &amp;&amp; git push --force &quot;https://$&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;@$GITHUB_REPO&quot; master:main || echo &quot;Nothing to commit&quot; </code></pre><p>遇到一个报错卡了好久：</p><pre><code>[main 7686805] feed parse schedule task 2 files changed, 1823 insertions(+), 47 deletions(-) create mode 100644 tmp.xmlCurrent branch main is up to date.remote: Write access to repository not granted.fatal: unable to access &#39;https://github.com/lozhu20/my-blog-source/&#39;: The requested URL returned error: 403</code></pre><p><img src="https://images.happy365.day/24/04/17220118.png" alt="报错"></p><p>仓库默认只给 Actions 读取权限，需要手动设置写权限：<a href="https://lozhu.happy365.day/2024/04/16/3cae97c7d635/">解决:github actions remote: Write access to repository not granted</a></p><p><img src="https://images.happy365.day/24/04/17220156.png" alt="修改配置"></p><p>至此，整体功能已经实现。</p><p><img src="https://images.happy365.day/24/04/17220255.png" alt="初步效果"></p><h2 id="更好的-RSS-解析方案"><a href="#更好的-RSS-解析方案" class="headerlink" title="更好的 RSS 解析方案"></a>更好的 RSS 解析方案</h2><h3 id="feedparser"><a href="#feedparser" class="headerlink" title="feedparser"></a>feedparser</h3><p>网上看到有专门解析 RSS 的第三方 python 库：feedparser</p><p>安装：</p><pre><code class="sh">pip3 install feedparser</code></pre><p>安装完成直接就能用了。</p><pre><code class="python">&gt;&gt;&gt; import feedparser# 美团技术团队&gt;&gt;&gt; d = feedparser.parse(&quot;https://tech.meituan.com&quot;)&gt;&gt;&gt; d.feed.author&#39;tech@meituan.com (美团技术团队)&#39;&gt;&gt;&gt; d.feed.title&#39;美团技术团队&#39;&gt;&gt;&gt; d.feed.subtitle&#39;美团技术团队最近更新内容。&#39;&gt;&gt;&gt; d.feed.link&#39;https://tech.meituan.com/feed/&#39;</code></pre><p>这可比自己写的 python 脚本管用多了，还能处理各种格式的订阅源，真的很方便！</p><h2 id="其他-RSS-订阅器实现"><a href="#其他-RSS-订阅器实现" class="headerlink" title="其他 RSS 订阅器实现"></a>其他 RSS 订阅器实现</h2><ul><li>参考 <strong>若志随笔</strong> 大佬的 freshrss 实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> RSS订阅 </tag>
            
            <tag> 自动更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决:github actions remote: Write access to repository not granted</title>
      <link href="/2024/04/16/3cae97c7d635/"/>
      <url>/2024/04/16/3cae97c7d635/</url>
      
        <content type="html"><![CDATA[<p>最近在折腾 RSS 订阅更新，用到了 GitHub Actions。写了一个定时任务部署上去，一直报错，卡了好几个小时，记录一下解决方案。</p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>定时任务到时间才会触发，先用 push 触发来进行测试。Actions 的脚本：</p><pre><code class="yaml">name: fetch rss scriptionson:  push:    branches:      - mainenv:  TZ: Asia/Shanghaijobs:  build:    name: fetch rss post    runs-on: ubuntu-latest    steps:    - name: checkout actions      uses: actions/checkout@v4    - name: Set up Python 3.9      uses: actions/setup-python@v2      with:        python-version: 3.9            - name: fetch post list      run: |        python feed_parse.py            - name: commit      env:        GITHUB_REPO: github.com/lozhu20/my-blog-source      run: |        git config --global user.name lozhu20        git config --global user.email zhulongkun20@icloud.com        git add .        git commit -m &quot;feed parse schedule task&quot;        git pull --rebase        git push &quot;https://$&#123;&#123; secrets.HEXO_BLOG_DEPLOY_KEY &#125;&#125;@$GITHUB_REPO&quot; main:main    </code></pre><p>内容很简单，就是在每次 push 的时候执行一个 python 脚本，然后变更文件提交到 main 分支上。</p><p>报错信息：</p><pre><code>▶️ Run git config --global user.name lozhu20[main 7686805] feed parse schedule task 2 files changed, 1823 insertions(+), 47 deletions(-) create mode 100644 tmp.xmlCurrent branch main is up to date.remote: Write access to repository not granted.fatal: unable to access &#39;https://github.com/lozhu20/my-blog-source/&#39;: The requested URL returned error: 403</code></pre><p><img src="https://images.happy365.day/24/04/17220118.png" alt="报错"></p><p>提示没有写入权限。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>一直以为是脚本里的仓库名称、分支或者 URL 不对，或者是生成的 key 的权限问题，网上搜了半天发现还需要给授权仓库写入权限：</p><p>repo &gt; settings &gt; Actions &gt; General &gt; Workflow permissions</p><p><img src="https://images.happy365.day/24/04/17221158.png" alt="修改配置"></p><p>这个地方默认选择是：Read repository contents and packages permissions</p><p>需要勾选：<strong>Read and Write permissions</strong></p><p>授权之后，再重新提交触发 Actions，就是舒心的绿色 ✅ 了！</p><p><img src="https://images.happy365.day/24/04/17221244.png" alt="绿色"></p><p>参考: <a href="https://stackoverflow.com/questions/75250751/github-actions-write-access-to-repository-is-not-granted">Github Actions - Write access to repository is not granted</a></p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Actions </tag>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GitHub Actions部署Hexo博客</title>
      <link href="/2024/04/14/f40b3e6d9a60/"/>
      <url>/2024/04/14/f40b3e6d9a60/</url>
      
        <content type="html"><![CDATA[<p>这两天注意到 GitHub 上的 Actions 功能就详细了解了一下，没想到这功能已经出来四五年了。学习了一下，发现用来部署博客很合适，只要维护博客源文件就好，每次发布新文章到备份仓库，GitHub 自动部署静态文件，太完美了。即便是以后换了电脑，也能省去搭建本地环境的麻烦了。个人用户的免费计划已经足够使用了。</p><span id="more"></span><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>看了网上一些资料，很多没有将清楚流程和准备工作，直接上 Actions 代码，看的人很疑惑。</p><p>整个流程需要两个仓库：一个私有仓库用来存储源文件，一个公有仓库用来部署静态文件。在源文件仓库添加 Actions 工作流，每次 push 到源文件仓库时，Actions 自动触发部署，然后将生成的静态文件 push 到公有静态文件仓库。</p><p>当然一个仓库应该也可以，从 A 分支的源文件生成静态文件部署到 B 分支。</p><p>步骤如下：</p><ol><li>新建源文件私有仓库，新建公有的静态文件部署仓库</li><li>在源文件仓库的 <strong>Secrets and variables</strong> &gt; <strong>Actions</strong> 下新增一个 “Repository secret”，这个 secret 在 Actions 中会用到</li><li>在源文件仓库新建 Actions，代码见下方，其中的 secrets 即为上一步中生成的 sercet</li><li>完成</li></ol><h2 id="workflows"><a href="#workflows" class="headerlink" title="workflows"></a>workflows</h2><p>感谢 yifangzheng 的 Actions 脚本，这个脚本还支持推送 gitee 和 coding。</p><pre><code class="yaml">name: Hexo blog auto deploy# 触发条件：在 push 到源文件仓库分支后触发on:  push:    branches:       - mainenv:  TZ: Asia/Shanghaijobs:  blog-cicd:    name: Hexo blog build &amp; deploy    runs-on: ubuntu-latest # 使用最新的 Ubuntu 系统作为编译部署的环境    steps:    - name: Checkout codes      uses: actions/checkout@v4    - name: Setup node      # 设置 node.js 环境      uses: actions/setup-node@v1      with:        node-version: &#39;18.x&#39;    - name: Cache node modules      # 设置包缓存目录，避免每次下载      uses: actions/cache@v1      with:        path: ~/.npm        key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125;    - name: Install hexo dependencies      # 下载 hexo-cli 脚手架及相关安装包      run: |        npm install -g hexo-cli        npm install    - name: Generate files      # 编译 markdown 文件      run: |        hexo clean        hexo generate    - name: Deploy hexo blog      env:         # Github 仓库        GITHUB_REPO: github.com/lozhu20/lozhu20.github.io        # Coding 仓库        # CODING_REPO: e.coding.net/yifanzheng/blogs.git        # Gitee 仓库        # GITEE_REPO: gitee.com/yifanzheng/yifangzheng.gitee.io.git      # 将编译后的博客文件推送到指定仓库      run: |        cd ./public &amp;&amp; git init &amp;&amp; git add .        git config user.name &quot;lozhu20&quot;        git config user.email &quot;zhulongkun20@icloud.com&quot;        git add .        git commit -m &quot;GitHub Actions Auto Builder at $(date +&#39;%Y-%m-%d %H:%M:%S&#39;)&quot;        git push --force &quot;https://$&#123;&#123; secrets.HEXO_BLOG_DEPLOY_KEY &#125;&#125;@$GITHUB_REPO&quot; master:main        # git push --force &quot;https://RoYFbFDSfM:$&#123;&#123; secrets.CODING_TOKEN &#125;&#125;@$CODING_REPO&quot; master:master        # git push --force &quot;https://yifanzheng:$&#123;&#123; secrets.GITEE_ACCESS_TOKEN &#125;&#125;@$GITEE_REPO&quot; master:master</code></pre><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>报错1：</p><p>执行到 Deploy hexo blog 报错，日志：</p><pre><code>error: src refspec main does not match anyerror: failed to push some refs to &#39;https://github.com/lozhu20/lozhu20.github.io&#39;Error: Process completed with exit code 1.</code></pre><p>这是因为静态仓库分支不存在导致的，检查 git push  的分支名是否正确：</p><pre><code class="sh">git push --force &quot;https://$&#123;&#123; secrets.HEXO_BLOG_DEPLOY_KEY &#125;&#125;@$GITHUB_REPO&quot; master:main</code></pre><p>冒号前是 master 固定的，冒号后是静态文件仓库的分支名。</p><p>报错2：</p><p>Actions 顺利执结结束，静态文件成功推送，但是打开网站首页空白且无报错。仔细查看了日志，发现 Generate files 步骤有告警：</p><pre><code>WARN  No layout: about/index.htmlWARN  No layout: categories/index.htmlWARN  No layout: friends/index.html...</code></pre><p>再往前检查，发现推送到源文件仓库的文件中 themes 目录下的两个主题文件夹都没有推送上去。修复了这个问题重新推送，再次触发工作流后就能正常访问了。</p>]]></content>
      
      
      <categories>
          
          <category> 博客维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Actions </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git检测不到本地仓库里的文件</title>
      <link href="/2024/04/14/5b6c6f78fbdb/"/>
      <url>/2024/04/14/5b6c6f78fbdb/</url>
      
        <content type="html"><![CDATA[<p>今天晚上在给博客源文件备份仓库配置 Actions 的时候，发现 git 检测不到本地仓库里的文件，记录一下这个问题。</p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为初始化仓库的时候，子目录中已经存在 .git 目录，本地仓库初始化报错，于是删除了子目录里的 .git 目录，然后本地仓库顺利初始化。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>博客部署的 Action 跑完之后，打开博客主页，发现主页空白，没有错误。然后仔细检查了各个环节，没有发现明显的错误。只能去认真阅读 Actions 部署日志，发现 <code>hexo generate</code> 命令执行过程中有很多警告：</p><pre><code>warn: No layout for xxx.html</code></pre><p>找不到 layout？第一反应是 layout 目录下文件是不是丢了？</p><p>确认了源文件仓库的文件，确实是主题目录下的文件夹都没 push 上去。奇怪的是，<code>git status</code> 也不显示这个目录下的任何文件，即便是文件又修改。并且也确认 .gitignore 文件中没有排除这个子目录。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>执行 <code>git rm -r --cached</code> 删除 git 本地缓存，然后执行 <code>git status</code> 就可以看到这个子目录了🎉</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手实现一个短链接服务</title>
      <link href="/2024/04/13/7c444bb72964/"/>
      <url>/2024/04/13/7c444bb72964/</url>
      
        <content type="html"><![CDATA[<h2 id="服务地址"><a href="#服务地址" class="headerlink" title="服务地址"></a>服务地址</h2><p><a href="https://t.happy365.day/">https://t.happy365.day</a></p><p>服务部署在本地，由 cloudflare tunnel 提供内网穿透服务。</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在知乎上看到一篇关于短链生成的设计文档 <a href="https://zhuanlan.zhihu.com/p/370475544">系统设计之路：如何设计一个URL短链服务</a>，其中涉及到的知识点较多，包括：短链方案设计及取舍、分库分表、高可用设计等。一个看似简单的需求想要真正上线，需要需要实现功能，还要兼顾性能、安全性、可靠性等各个方面。于是想亲自上线一个短链生成服务，锻炼一下动手能力。</p><h2 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h2><p>短链服务在微博类网站中较为流行，使用短链服务好处包括：</p><ol><li>精简目标网址，缩短文本长度，便于记忆和传播；</li><li>隐藏目标地址及参数；</li><li>控制目标网址的跳转，不安全网址可以限制跳转。</li></ol><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><h3 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h3><ol><li>实现长链接转换短链接，长度缩短且唯一；</li><li>生成之后的短链接能正确跳转至原地址；</li><li>短链接可以设置失效时长，默认5年；</li></ol><h3 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h3><ol><li>性能：短链接跳转时长与原链接跳转时长无明显差异；</li><li>安全：短链接不能被遍历；</li><li>可用：不能存在单点故障。</li></ol><h2 id="系统数据量预期"><a href="#系统数据量预期" class="headerlink" title="系统数据量预期"></a>系统数据量预期</h2><p>写请求数：10个&#x2F;s</p><p>读请求数：100个&#x2F;s</p><p>5年内产生短链数量：10 * 60 * 60 * 24 * 365 * 5 &#x3D; 1,576,800,000 （约16亿）</p><p>62 ^ n &gt;&#x3D; 16亿 &#x3D;&gt; n &gt;&#x3D; 6</p><p>短码长度设置为6位中英文大小写字母和数字可满足需求。</p><h2 id="短链生成方案"><a href="#短链生成方案" class="headerlink" title="短链生成方案"></a>短链生成方案</h2><h3 id="自增id"><a href="#自增id" class="headerlink" title="自增id"></a>自增id</h3><p>每次请求生成一个递增唯一的id，根据生成的id转换到62进制得到一个唯一的短链接。但是此种方式生成的短链接是有规律的，如果接口被恶意调用，可能会导致短链接被迅速消耗完，并且浪费掉大部分性能，正常的请求得不到处理。</p><h3 id="普通随机数"><a href="#普通随机数" class="headerlink" title="普通随机数"></a>普通随机数</h3><p>每次请求随机生成一个随机数，再根据这个随机数进行转换到62进制得到短链接，如果该短链接已被占用，则重新生成随机数。实现起来很简单，但缺点也很明显：1.随着生成的短链接数量的增加，碰撞的概率越来越大；2.伪随机数可以被攻击者预测。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>使用 MurmurHash3 （对比 md5 随机分布性更好，发生 Hash 碰撞的几率更低，可以提高性能），对原始链接进行哈希，得到哈希值，转换成 62 进制得到短链接。如果存在碰撞，则在原始链接后增加特定后缀再进行 Hash。</p><p>⚠️ 要特别注意，hashcode 可能为负数！</p><h2 id="数据库设计方案"><a href="#数据库设计方案" class="headerlink" title="数据库设计方案"></a>数据库设计方案</h2><h3 id="数据库选择"><a href="#数据库选择" class="headerlink" title="数据库选择"></a>数据库选择</h3><p>选择 Postgresql 做为系统数据库。</p><h3 id="分库方案"><a href="#分库方案" class="headerlink" title="分库方案"></a>分库方案</h3><p>单条记录占用内存大小：</p><p> (36 + 512 + 6 + 8 + 4 + 4 + 8 + 100 + 8 + 100) byte &#x3D; 786 byte</p><p>5年内所有记录占用内存大小：</p><p>16 亿 * 786 byte &#x2F; 1024KB &#x2F; 1024MB &#x2F; 1024 GB &#x3D; 1.13 TB</p><p>分 3 个库，主库写，从库读，主从复制。</p><h3 id="分表方案"><a href="#分表方案" class="headerlink" title="分表方案"></a>分表方案</h3><p>单表记录不超过 500 万行，16 亿 &#x2F; 500 万 &#x3D;  320 张表，此时单表容量为 1130 GB &#x2F; 320 &#x3D; 3.5 GB。平均到 5 年共 60 个月，大约 5.5 天需要新增一张表，为了简表方便，按 5 天新增一张表实现。</p><h3 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h3><p>URL映射表（t_url_mapping）：</p><table><thead><tr><th>字段名</th><th>类型</th><th>默认值</th><th>是否可空</th><th>是否主键</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>varchar(36)</td><td>uuid</td><td></td><td>Y</td><td>主键id</td><td></td></tr><tr><td>url</td><td>varchar(512)</td><td></td><td></td><td></td><td>原始URL</td><td></td></tr><tr><td>short_url</td><td>varchar(6)</td><td></td><td></td><td></td><td>短链接</td><td>唯一索引</td></tr><tr><td>expire_time</td><td>timestamp</td><td></td><td>Y</td><td></td><td>失效时间</td><td></td></tr><tr><td>status</td><td>int</td><td>0</td><td></td><td></td><td>状态(0:正常,1:失效)</td><td></td></tr><tr><td>visit_count</td><td>int</td><td>0</td><td></td><td></td><td>短链接访问次数</td><td></td></tr><tr><td>create_time</td><td>timestamp</td><td>current_timestamp</td><td></td><td></td><td>创建时间</td><td></td></tr><tr><td>create_by</td><td>varchar(100)</td><td>unknow</td><td></td><td></td><td>创建人</td><td></td></tr><tr><td>update_time</td><td>timestamp</td><td>current_timestamp</td><td></td><td></td><td>更新时间</td><td></td></tr><tr><td>update_by</td><td>varchar(100)</td><td>unknow</td><td></td><td></td><td>更新人</td><td></td></tr></tbody></table><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>父表建表 SQL 如下：</p><pre><code class="sql">drop table if exists public.t_url_mapping;create table public.t_url_mapping(    id          varchar(36) default gen_random_uuid() not null,    url         varchar(512)                          not null,    short_url   varchar(6),    expire_time timestamp,    status      int         default 0,    visit_count int         default 0,    create_time timestamp   default current_timestamp,    create_by   varchar(100),    update_time timestamp   default current_timestamp,    update_by   varchar(100),    primary key (id, create_time)) partition by range (create_time);comment on table public.t_url_mapping is &#39;短链接映射表&#39;;comment on column public.t_url_mapping.id is &#39;主键&#39;;comment on column public.t_url_mapping.url is &#39;原始链接&#39;;comment on column public.t_url_mapping.short_url is &#39;短链接&#39;;comment on column public.t_url_mapping.expire_time is &#39;过期时间&#39;;comment on column public.t_url_mapping.status is &#39;状态(0:正常,1:失效)&#39;;comment on column public.t_url_mapping.visit_count is &#39;访问次数&#39;;comment on column public.t_url_mapping.create_time is &#39;创建时间&#39;;comment on column public.t_url_mapping.create_by is &#39;创建人&#39;;comment on column public.t_url_mapping.update_time is &#39;更新时间&#39;;comment on column public.t_url_mapping.update_by is &#39;更新人&#39;;</code></pre><p>创建分区表并在时间字段上加索引：</p><pre><code class="sql">drop table if exists public.t_url_mapping_20240413_to_20240417;drop index if exists idx_t_url_mapping_create_time;drop index if exists uk_t_url_mapping_short_url;-- 创建分表create table if not exists public.t_url_mapping_20240413_to_20240417    partition of public.t_url_mapping        for values from (&#39;2024-04-13&#39;) to (&#39;2024-04-17&#39;);-- 创建分表分区字段索引create index idx_t_url_mapping_create_time on public.t_url_mapping_20240413_to_20240417 (create_time);-- 创建唯一索引create unique index if not exists uk_t_url_mapping_short_url on public.t_url_mapping_20240413_to_20240417 (short_url);</code></pre><p>pg10 已经对分区表的支持已经很好了，网上一些资料中使用继承的方式创建分区表已经很过时了。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/110927990">实战 PostgreSQL 分区表</a></p><h3 id="实现分区表创建自动化"><a href="#实现分区表创建自动化" class="headerlink" title="实现分区表创建自动化"></a>实现分区表创建自动化</h3><p>需要使用触发器，在执行插入操作时如果发现分区表不存在，则先创建对应的分区表。</p><p>参考：<a href="https://www.cnblogs.com/shijiehaiyang/p/17406142.html">postgresql 自动创建分区表</a></p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>Postgresql 16</li><li>Redis 7.2</li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul><li>JDK17</li><li>Springboot 3.1.x</li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>Nginx 1.24.0</li><li>Vue3</li><li>Bootstrap5</li><li>Webpack</li></ul><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul><li>Docker</li></ul><h2 id="使用-Docker-部署数据库"><a href="#使用-Docker-部署数据库" class="headerlink" title="使用 Docker 部署数据库"></a>使用 Docker 部署数据库</h2><p>创建 3 个持久化数据卷，shorturl00 为主库，其他两个为从库。</p><pre><code class="sh">docker create volume shorturl00docker create volume shorturl01docker create volume shorturl02</code></pre><p>创建网络</p><pre><code class="sh">docker network create --subnet 172.12.0.0/16 --gateway 172.12.0.1 postgresqlnet</code></pre><p>拉取镜像</p><pre><code class="sh">docker pull postgres</code></pre><p>运行容器</p><pre><code class="sh">docker run -id --name=shorturl00 --network postgresqlnet --network-alias shorturl00 --ip 172.12.0.2 -v shorturl00:/var/lib/postgresql/data -p 5440:5440 -e POSTGRES_PASSWORD=12345678 -e LANG=C.UTF-8 postgresdocker run -id --name=shorturl01 --network postgresqlnet --network-alias shorturl01 --ip 172.12.0.3 -v shorturl01:/var/lib/postgresql/data -p 5441:5441 -e POSTGRES_PASSWORD=12345678 -e LANG=C.UTF-8 postgresdocker run -id --name=shorturl02 --network postgresqlnet --network-alias shorturl02 --ip 172.12.0.4 -v shorturl02:/var/lib/postgresql/data -p 5442:5442 -e POSTGRES_PASSWORD=12345678 -e LANG=C.UTF-8 postgres</code></pre><p>进入容器 &#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data 目录修改 pg_hba.conf 端口</p><pre><code>port=5440</code></pre><p>修改 pg_hba.conf 允许外部连接</p><pre><code># IPv4 local connections:host    all             all             0.0.0.0/0               trust</code></pre><p>在容器内创建数据库 shorturl，外部连接测试。</p><p>注：在容器内编辑配置文件需要用到 vim，替换一下软件源速度会更快。</p><pre><code class="sh">cd /etc/aptmv sources.list.d sources.list.d.bak# 使用中科大的源，并且不要用 https，不然会报证书错误echo &#39;deb http://mirrors.ustc.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb-src http://mirrors.ustc.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb http://mirrors.ustc.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb-src http://mirrors.ustc.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb http://mirrors.ustc.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmwaredeb-src http://mirrors.ustc.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmwaredeb http://mirrors.ustc.edu.cn/debian-security/ bookworm-security main contrib non-free non-free-firmwaredeb-src http://mirrors.ustc.edu.cn/debian-security/ bookworm-security main contrib non-free non-free-firmware&#39; &gt; sources.listapt-get update</code></pre><h2 id="Docker-部署-Postgresql"><a href="#Docker-部署-Postgresql" class="headerlink" title="Docker 部署 Postgresql"></a>Docker 部署 Postgresql</h2><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>使用缓存提高性能。生成新的短链接写入数据库的同时写入缓存中，访问短链接时首先从缓存中获取，缓存中获取不到再从数据库中获取，获取成功后将其放入缓存中。</p><p>使用 Redis 做为缓存中间件，缓存大小设置为 1G</p><p>1G &#x2F; 782 byte &#x3D; 137 万</p><p>137 万 &#x2F; 10条 &#x2F; s</p><p>缓存过期时间设置为 1 天。</p><h2 id="后端接口设计"><a href="#后端接口设计" class="headerlink" title="后端接口设计"></a>后端接口设计</h2><h3 id="短链生成接口"><a href="#短链生成接口" class="headerlink" title="短链生成接口"></a>短链生成接口</h3><p>接口名：api&#x2F;v1&#x2F;shortenURL</p><p>请求方式：GET</p><p>参数：</p><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td>sign</td><td>请求签名（对参数进行编码）</td></tr><tr><td>URL</td><td>原始URL</td></tr></tbody></table><p>返回值：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>code</td><td>0:处理成功,-1:处理失败</td></tr><tr><td>message</td><td>处理结果</td></tr><tr><td>data: shortURL</td><td>短链接</td></tr></tbody></table><h3 id="短链统计数据接口"><a href="#短链统计数据接口" class="headerlink" title="短链统计数据接口"></a>短链统计数据接口</h3><p>接口名：api&#x2F;v1&#x2F;statistics</p><p>请求方式：GET</p><p>参数：</p><table><thead><tr><th>参数名</th><th>解释</th></tr></thead><tbody><tr><td>sign</td><td>请求签名</td></tr></tbody></table><p>返回值：</p><table><thead><tr><th>参数名</th><th>解释</th></tr></thead><tbody><tr><td>code</td><td>返回 0 时成功，否则失败</td></tr><tr><td>message</td><td>处理结果</td></tr><tr><td>data:</td><td></td></tr><tr><td>totalCount</td><td>共生成短链条数</td></tr></tbody></table><h3 id="短链访问接口"><a href="#短链访问接口" class="headerlink" title="短链访问接口"></a>短链访问接口</h3><p>接口名：api&#x2F;v1&#x2F;visitShortURL</p><p>请求方式：GET</p><p>参数：</p><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td>shortURL</td><td>短链接</td></tr></tbody></table><p>返回值：</p><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td>code</td><td>301:跳转,-1:处理失败</td></tr><tr><td>message</td><td>处理结果</td></tr><tr><td>data:</td><td></td></tr><tr><td>URL</td><td>原始URL</td></tr></tbody></table><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="数据库高可用"><a href="#数据库高可用" class="headerlink" title="数据库高可用"></a>数据库高可用</h3><p>一主两从，主从复制，主库写，从库读。</p><h3 id="后端服务高可用"><a href="#后端服务高可用" class="headerlink" title="后端服务高可用"></a>后端服务高可用</h3><p>后端服务分布式部署，Nginx做负载均衡。</p><h2 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h2><p>前端通过 nginx 将前端请求转发至后端，后端同时运行多个实例，通过 nginx 实现负载均衡。</p><p>docker 部署 nginx 参考文档：<a href="https://blog.csdn.net/BThinker/article/details/123507820">Docker 安装 Nginx 容器 (完整详细版)</a> </p><h3 id="镜像拉取"><a href="#镜像拉取" class="headerlink" title="镜像拉取"></a>镜像拉取</h3><pre><code class="sh">docker pull nginx:latest</code></pre><h3 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>nginx 配置文件放在宿主机管理，启动容器，nginx 会生成默认配置文件，将容器中的配置文件拷贝到宿主机自定义目录中。</p><pre><code class="sh">docker run -dp 80:80 --name nginx nginx</code></pre><p>建立本地 nginx 配置文件夹：</p><pre><code class="sh">mkdir /home/lozhu/Documents/nginx_config/confmkdir /home/lozhu/Documents/nginx_config/htmlmkdir /home/lozhu/Documents/nginx_config/log</code></pre><p>拷贝配置文件至宿主机：</p><pre><code class="sh">docker cp nginx:/etc/nginx/nginx.conf /home/lozhu/Documents/nginx_config/confdocker cp nginx:/etc/nginx/html /home/lozhu/Documents/nginx_config/htmldocker cp nginx:/etc/nginx/conf.d /home/lozhu/Documents/nginx_config/conf</code></pre><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>先删除之前启动的容器：</p><pre><code class="sh">docker stop nginxdocker rm nginx</code></pre><p>为了后面 nginx 能将请求转发至后端接口，将 nginx 和数据库容器、后端服务容器放在同一个网络中。</p><pre><code class="sh">docker run -dp 80:80 \--name nginx \--network postgresqlnet \--ip 172.12.0.10 \-v /home/lozhu/Documents/nginx_config/conf/nginx.conf:/etc/nginx/nginx.conf \-v /home/lozhu/Documents/nginx_config/conf/conf.d:/etc/nginx/conf.d \-v /home/lozhu/Documents/nginx_config/html:/usr/share/nginx/html \nginx:latest</code></pre><p>小插曲：容器启动时路径 &#x2F;home&#x2F;lozhu&#x2F;Documents&#x2F;nginx_config&#x2F;conf&#x2F;conf.d 错写为 &#x2F;home&#x2F;lozhu&#x2F;Documents&#x2F;nginx_config&#x2F;conf.d，少了一层 conf，容器启动后无法访问：</p><pre><code>$ curl http://localhostcurl: (56) Recv failure: Connection reset by peer</code></pre><p>路径修正后再启动就可以正常访问了。</p><h2 id="前端项目"><a href="#前端项目" class="headerlink" title="前端项目"></a>前端项目</h2><p>本来想趁此机会学习一下 React 和 Next.js ，但是发现 Next.js 相关的入门中文资料太少，中文网站上翻译都不全。一个点击按钮调用后端接口获取数据的例子都很难找到，还是到了 stackoverflow 上才看到有人贴了英文官网的文档。国内各种博客文章上来就是服务端渲染、客户端渲染，难道 Next.js 做不了交互吗？留到后面再深入学习吧。此次需求先使用熟悉的 Vue.js 来实现。</p><h3 id="Vue-项目搭建"><a href="#Vue-项目搭建" class="headerlink" title="Vue 项目搭建"></a>Vue 项目搭建</h3><p>创建项目：</p><pre><code class="sh">vue init webpack shorturl-web</code></pre><h3 id="Axios-配置"><a href="#Axios-配置" class="headerlink" title="Axios 配置"></a>Axios 配置</h3><p>使用的 Vue.js 版本是 2.5.2，如果安装 axios 最新版本的话项目启动会报错：</p><pre><code>in ../node_modules/axios/lib/platform/index.js</code></pre><p>解决方法是将低 axios 版本，先删除 node_modules 目录，然后将 package.json 中 axios 版本改为 1.5.0，再重新 npm install。</p><p>参考：<a href="https://blog.csdn.net/AGLQYP/article/details/136199938">Vue引入axios报错</a></p><p>先修改 config&#x2F;index.js 中的跨域设置：</p><pre><code class="js">module.exports = &#123;  dev: &#123;    // Paths    assetsSubDirectory: &#39;static&#39;,    assetsPublicPath: &#39;/&#39;,    proxyTable: &#123;      &#39;^/api&#39;: &#123;        target: &#39;http://localhost:8000&#39;,        changeOrigin: true,        secure: false,        pathRewrite: &#123;          &#39;^/api&#39;: &#39;/api&#39;        &#125;      &#125;    &#125;,    ...  &#125;</code></pre><p>在 main.js 中引入 axios</p><pre><code class="js">import axios from &#39;axios&#39;Vue.prototype.$axios = axios</code></pre><h3 id="页面代码实现"><a href="#页面代码实现" class="headerlink" title="页面代码实现"></a>页面代码实现</h3><p>主要代码：</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;content&quot;&gt;    &lt;div class=&quot;main-content&quot;&gt;      &lt;h2&gt;Lozhu 的在线短链服务&lt;/h2&gt;      &lt;h4&gt;累计生成短链: &#123;&#123; historyData.length &#125;&#125;&lt;/h4&gt;      &lt;div class=&quot;input-group mb-3&quot; style=&quot;margin-top: 40px;&quot;&gt;        &lt;input v-model=&quot;URL&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;请输入链接，一次一个哦～&quot;&gt;        &lt;button v-on:click=&quot;shortenURL&quot; class=&quot;btn btn-outline-secondary&quot; type=&quot;button&quot; id=&quot;button-addon2&quot;&gt;🚀          生成短链&lt;/button&gt;      &lt;/div&gt;      &lt;div v-if=&quot;errorMessage&quot; class=&quot;alert alert-danger fade show&quot; role=&quot;alert&quot;&gt;        &#123;&#123; errorMessage &#125;&#125;      &lt;/div&gt;      &lt;div v-if=&quot;warningMessage&quot; class=&quot;alert alert-warning fade show&quot; role=&quot;alert&quot;&gt;        &#123;&#123; warningMessage &#125;&#125;      &lt;/div&gt;      &lt;div style=&quot;margin-top: 50px;&quot;&gt;        &lt;table class=&quot;table table-hover&quot;&gt;          &lt;thead&gt;            &lt;tr&gt;              &lt;th&gt;序号&lt;/th&gt;              &lt;th&gt;原始链接&lt;/th&gt;              &lt;th&gt;短链&lt;/th&gt;              &lt;th&gt;生成时间&lt;/th&gt;            &lt;/tr&gt;          &lt;/thead&gt;          &lt;tbody&gt;            &lt;tr v-for=&quot;(item, index) in historyData&quot; :key=&quot;index&quot;&gt;              &lt;td&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/td&gt;              &lt;td&gt;                &lt;a :href=item.URL target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;&#123;&#123; item.URL &#125;&#125;&lt;/a&gt;              &lt;/td&gt;              &lt;td&gt;                &lt;a :href=item.shortURL target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;&#123;&#123; item.shortURL &#125;&#125;&lt;/a&gt;              &lt;/td&gt;              &lt;td&gt;&#123;&#123; item.generateTime &#125;&#125;&lt;/td&gt;            &lt;/tr&gt;          &lt;/tbody&gt;        &lt;/table&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;footer&quot;&gt;      &lt;p&gt;        &lt;span&gt;          📝 &lt;a :href=&quot;documentURL&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt; 项目文档&lt;/a&gt;        &lt;/span&gt;        |        &lt;span&gt;          &lt;a :href=&quot;sourceCodeURL&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;源码&lt;/a&gt;        &lt;/span&gt;      &lt;/p&gt;      &lt;p&gt;        &lt;span&gt;          &lt;div class=&quot;heart&quot;&gt;&lt;/div&gt;        &lt;/span&gt;        &lt;span&gt;已勉强运行 &#123;&#123; runningDays &#125;&#125; 天&lt;/span&gt;      &lt;/p&gt;      &lt;p&gt;©️ 2024 lozhu 保留所有权利&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Home&#39;,  data() &#123;    return &#123;      URL: &#39;&#39;,      shortURL: &#39;&#39;,      errorMessage: &#39;&#39;,      warningMessage: &#39;&#39;,      totalCount: 0,      runningDays: 0,      historyData: [],      documentURL: &#39;https://lozhu.happy365.day&#39;,      sourceCodeURL: &#39;https://lozhu.happy365.day&#39;    &#125;  &#125;,  created() &#123;    let nowTime = new Date().getTime() / 1000    // 开始运行时间: 2024-04-12    let startTime = new Date(2024, 3, 12).getTime() / 1000    let days = (nowTime - startTime) / (60 * 60 * 24)    this.runningDays = parseInt(days + &#39;&#39;)  &#125;,  methods: &#123;    shortenURL() &#123;      this.warningMessage = &#39;&#39;      this.errorMessage = &#39;&#39;      if (this.URL === &#39;&#39;) &#123;        this.warningMessage = &#39;请先输入链接哦～&#39;        return false      &#125;      this.$axios.get(&#39;/api/v1/shortenURL&#39;, &#123;        params: &#123;          URL: this.URL,          sign: &#39;&#39;        &#125;      &#125;).then((res) =&gt; &#123;        if (res.data &amp;&amp; res.data.code === 0) &#123;          let tableRow = &#123;            URL: this.URL,            shortURL: res.data.data,            generateTime: this.formatDateTime(new Date())          &#125;          this.historyData.push(tableRow)        &#125; else &#123;          this.errorMessage = res.data.message        &#125;        this.URL = &#39;&#39;      &#125;).catch((err) =&gt; &#123;        this.errorMessage = &#39;当前服务不可用&#39;        this.warningMessage = &#39;&#39;      &#125;)    &#125;,    formatDateTime(date) &#123;      const year = date.getFullYear();      const month = date.getMonth() + 1;      const day = date.getDate();      const hour = date.getHours();      const minute = date.getMinutes();      const second = date.getSeconds();      return `$&#123;year&#125;-$&#123;this.pad(month)&#125;-$&#123;this.pad(day)&#125; $&#123;this.pad(hour)&#125;:$&#123;this.pad(minute)&#125;:$&#123;this.pad(second)&#125;`;    &#125;,    pad(num) &#123;      return num.toString().padStart(2, &#39;0&#39;);    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>样式直接引入 Bootstrap 实现。CSS 代码省略。</p><h3 id="打包部署至-nginx"><a href="#打包部署至-nginx" class="headerlink" title="打包部署至 nginx"></a>打包部署至 nginx</h3><p>打包：</p><pre><code class="sh">npm run build</code></pre><p>打包完成之后，将 dist 路径下的 index.html 和 static 两个文件拷贝至 docker nginx 映射的宿主机 html 目录下，访问宿主机 80 端口，即可看到页面。</p><h3 id="Docker-镜像生成"><a href="#Docker-镜像生成" class="headerlink" title="Docker 镜像生成"></a>Docker 镜像生成</h3><pre><code class="dockerfile">FROM nginx:1.22EXPOSE 80COPY /dist /usr/share/nginx/htmlENTRYPOINT nginx -g &quot;daemon off;&quot;</code></pre><p>可能是我自己电脑性能比较低的原因，打包比较慢，要好几分钟才能跑完。</p><pre><code class="sh">docker build -t chenxii81/shorturl-web-image:v1.1.0 .</code></pre><p>打包完成后推送至 Docker Hub：</p><pre><code class="sh">docker push chenxii81/shorturl-web-image:v1.1.0</code></pre><p>运行容器：</p><pre><code class="sh">docker run -dp 3000:80 --name shorturl-web --network postgresqlnet --ip 172.12.0.10 chenxii81/shorturl-web-image:v1.1.0</code></pre><p>访问 <a href="http://localhost:3000/">http://localhost:3000</a> 可以看到首页。</p><p>nginx 转发配置参考下文。</p><h2 id="Springboot-MyBatis-多数据源配置"><a href="#Springboot-MyBatis-多数据源配置" class="headerlink" title="Springboot + MyBatis 多数据源配置"></a>Springboot + MyBatis 多数据源配置</h2><p>首先引入数据库配置相关依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 使用 aop + 注解 的方式动态切换数据源 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>实体类定义：</p><pre><code class="java">@Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class UrlMapping &#123;    private String id;    private String url;    private String shortUrl;    private Date expireTime;    private int status = 0;    private Date createTime = new Date();    private String createBy = &quot;system&quot;;    private Date updateTime = new Date();    private String updateBy = &quot;system&quot;;&#125;</code></pre><p>数据库访问接口：</p><pre><code class="java">@Mapperpublic interface UrlMappingDao &#123;    int insert(UrlMapping urlMapping);    UrlMapping selectByShortUrl(String shortURL);    /**     * 更新过期链接的有效性     *     * @return 被更新的短链数量     */    int updateStatusByExpireTime();&#125;</code></pre><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;day.happy365.shorturlservice.dao.UrlMappingDao&quot;&gt;    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;day.happy365.shorturlservice.entity.UrlMapping&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result property=&quot;url&quot; column=&quot;url&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result property=&quot;shortUrl&quot; column=&quot;short_url&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result property=&quot;expireTime&quot; column=&quot;expire_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;        &lt;result property=&quot;status&quot; column=&quot;status&quot; jdbcType=&quot;INTEGER&quot;/&gt;        &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;        &lt;result property=&quot;createBy&quot; column=&quot;create_by&quot; jdbcType=&quot;VARCHAR&quot;/&gt;        &lt;result property=&quot;updateTime&quot; column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot;/&gt;        &lt;result property=&quot;updateBy&quot; column=&quot;update_by&quot; jdbcType=&quot;VARCHAR&quot;/&gt;    &lt;/resultMap&gt;    &lt;sql id=&quot;Base_Column_List&quot;&gt;        id,url,short_url,        expire_time,status,create_time,        create_by,update_time,update_by    &lt;/sql&gt;    &lt;insert id=&quot;insert&quot; parameterType=&quot;day.happy365.shorturlservice.entity.UrlMapping&quot;&gt;        insert into public.t_url_mapping(url, short_url, expire_time, create_by, update_by)        values (#&#123;url&#125;,                #&#123;shortUrl&#125;,                #&#123;expireTime&#125;,                #&#123;createBy&#125;,                #&#123;updateBy&#125;);    &lt;/insert&gt;    &lt;update id=&quot;updateStatusByExpireTime&quot;&gt;        update public.t_url_mapping        set status = 1,            update_time = now(),            update_by = &#39;ExpiredURLCheckJob&#39;        where expire_time &lt;![CDATA[ &lt;= ]]&gt; now()::timestamp    &lt;/update&gt;    &lt;select id=&quot;selectByShortUrl&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select        &lt;include refid=&quot;Base_Column_List&quot;/&gt;        from public.t_url_mapping        where short_url = #&#123;shortURL&#125;        order by create_time desc        limit 1    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>数据库配置：</p><pre><code class="yaml">spring:  application:    name: shorturl-service  datasource:    # 主库，用于写    shorturl00:      jdbc-url: jdbc:postgresql://vm1:5440/shorturl      username: postgres      password: *******      driver-class-name: org.postgresql.Driver    # 从库1，用于读    shorturl01:      jdbc-url: jdbc:postgresql://vm1:5441/shorturl      username: postgres      password: *******      driver-class-name: org.postgresql.Driver    # 从库2，用于读    shorturl02:      jdbc-url: jdbc:postgresql://vm1:5442/shorturl      username: postgres      password: *******      driver-class-name: org.postgresql.Driver</code></pre><p>数据源配置类：</p><pre><code class="java">/** * 主从数据源配置 */@Configuration@EnableTransactionManagement@MapperScan(basePackages = &quot;day.happy365.shorturlservice.dao&quot;, sqlSessionFactoryRef = &quot;sqlSessionFactory&quot;)public class DataSourceConfig &#123;    @Bean(name = &quot;masterDataSource&quot;)    @Primary    @ConfigurationProperties(prefix = &quot;spring.datasource.shorturl00&quot;)    public DataSource masterDataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    @Bean(name = &quot;slaveDataSource1&quot;)    @ConfigurationProperties(prefix = &quot;spring.datasource.shorturl01&quot;)    public DataSource slaveDataSource1() &#123;        return DataSourceBuilder.create().build();    &#125;    @Bean(name = &quot;slaveDataSource2&quot;)    @ConfigurationProperties(prefix = &quot;spring.datasource.shorturl02&quot;)    public DataSource slaveDataSource2() &#123;        return DataSourceBuilder.create().build();    &#125;    @Primary    @Bean(&quot;dynamicDataSource&quot;)    public DynamicRoutingDataSource dynamicDataSource(@Qualifier(value = &quot;masterDataSource&quot;) DataSource masterDataSource,                                                      @Qualifier(value = &quot;slaveDataSource1&quot;) DataSource slaveDataSource1,                                                      @Qualifier(value = &quot;slaveDataSource2&quot;) DataSource slaveDataSource2) &#123;        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(3);        targetDataSources.put(DynamicRoutingDataSourceContext.MASTER, masterDataSource);        targetDataSources.put(DynamicRoutingDataSourceContext.SLAVE1, slaveDataSource1);        targetDataSources.put(DynamicRoutingDataSourceContext.SLAVE2, slaveDataSource2);        DynamicRoutingDataSource dynamicRoutingDataSource = new DynamicRoutingDataSource();        // 设置数据源        dynamicRoutingDataSource.setTargetDataSources(targetDataSources);        // 设置默认选择的数据源        dynamicRoutingDataSource.setDefaultTargetDataSource(masterDataSource);        dynamicRoutingDataSource.afterPropertiesSet();        return dynamicRoutingDataSource;    &#125;    @Bean(name = &quot;sqlSessionFactory&quot;)    @Primary    public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dynamicDataSource&quot;) DataSource dynamicDataSource) throws Exception &#123;        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();        bean.setDataSource(dynamicDataSource);        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:**/*.xml&quot;));        return bean.getObject();    &#125;&#125;</code></pre><p>维护一个数据源 Map：</p><pre><code class="java">public class DynamicRoutingDataSourceContext &#123;    public static final String MASTER = &quot;master&quot;;    public static final String SLAVE1 = &quot;slave1&quot;;    public static final String SLAVE2 = &quot;slave2&quot;;    private static final ThreadLocal&lt;String&gt; THREAD_LOCAL_DATA_SOURCE = new ThreadLocal&lt;&gt;();    public static void setRoutingDataSource(String dataSource) &#123;        if (dataSource == null) &#123;            throw new NullPointerException();        &#125;        THREAD_LOCAL_DATA_SOURCE.set(dataSource);    &#125;    public static String getRoutingDataSource() &#123;        String dataSourceType = THREAD_LOCAL_DATA_SOURCE.get();        if (dataSourceType == null) &#123;            THREAD_LOCAL_DATA_SOURCE.set(DynamicRoutingDataSourceContext.MASTER);            return getRoutingDataSource();        &#125;        return dataSourceType;    &#125;    public static void removeRoutingDataSource() &#123;        THREAD_LOCAL_DATA_SOURCE.remove();    &#125;&#125;</code></pre><p>继承 AbstractRoutingDataSource 类实现 determineCurrentLookupKey 方法：</p><pre><code class="java">public class DynamicRoutingDataSource extends AbstractRoutingDataSource &#123;    @Override    protected Object determineCurrentLookupKey() &#123;        String routingDataSource = DynamicRoutingDataSourceContext.getRoutingDataSource();        log.info(&quot;【动态数据源】本次使用数据库: &#123;&#125;&quot;, routingDataSource);        return routingDataSource;    &#125;&#125;</code></pre><p>增加一个 TargetDataSource 注解，在执行数据库操作时指定数据库，使用起来更方便：</p><pre><code class="java">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(value = RetentionPolicy.RUNTIME)@Documentedpublic @interface TargetDataSource &#123;    String value();&#125;</code></pre><p>根据自定义注解的值切换数据源：</p><pre><code class="java">@Order(0)@Aspect@Componentpublic class DataSourceRoutingAopAspect &#123;    @Around(&quot;@annotation(targetDataSource)&quot;)    public Object routingWithDataSource(ProceedingJoinPoint joinPoint, TargetDataSource targetDataSource) throws Throwable &#123;        try &#123;            String value = targetDataSource.value();            if (&quot;slave&quot;.equals(value)) &#123;                if (new Random(7).nextInt() % 2 == 0) &#123;                    DynamicRoutingDataSourceContext.setRoutingDataSource(DynamicRoutingDataSourceContext.SLAVE1);                &#125; else &#123;                    DynamicRoutingDataSourceContext.setRoutingDataSource(DynamicRoutingDataSourceContext.SLAVE2);                &#125;            &#125; else &#123;                DynamicRoutingDataSourceContext.setRoutingDataSource(value);            &#125;            return joinPoint.proceed();        &#125; finally &#123;            DynamicRoutingDataSourceContext.removeRoutingDataSource();        &#125;    &#125;&#125;</code></pre><p>⚠️ 最后还有最重要的一步，从启动类上排除 SpringBoot 的数据源相关的自动配置，否则会报找不到数据库配置的错误。没意识到这点，在这里卡了半个小时。</p><pre><code class="java">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class&#125;)@EnableScheduling@EnableAsyncpublic class ShorturlServiceApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ShorturlServiceApplication.class, args);    &#125;&#125;</code></pre><h2 id="Docker-部署后端服务"><a href="#Docker-部署后端服务" class="headerlink" title="Docker 部署后端服务"></a>Docker 部署后端服务</h2><h3 id="jar-包生成"><a href="#jar-包生成" class="headerlink" title="jar 包生成"></a>jar 包生成</h3><pre><code class="sh">mvn cleanmvn package -DskipTests</code></pre><h3 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h3><pre><code class="dockerfile">FROM openjdk:17-oracleADD target/shorturl-service-v1.1.0.jar /shorturl-service-v1.1.0.jarRUN bash -c &#39;touch /shorturl-service-v1.1.0.jar&#39;ENV dataSource1Url=&quot;&quot;ENV dataSource2Url=&quot;&quot;ENV dataSource3Url=&quot;&quot;ENV dataSourceUsername=&quot;&quot;ENV dataSourcePassword=&quot;&quot;ENV sysConfigDomain=&quot;&quot;EXPOSE 8000MAINTAINER chenxii81ENTRYPOINT [&quot;java&quot;, &quot;-Dspring.datasource.shorturl00.jdbc-url=$&#123;dataSource1Url&#125;&quot;, &quot;-Dspring.datasource.shorturl00.username=$&#123;dataSourceUsername&#125;&quot;, &quot;-Dspring.datasource.shorturl00.password=$&#123;dataSourcePassword&#125;&quot;,  &quot;-Dspring.datasource.shorturl01.jdbc-url=$&#123;dataSource2Url&#125;&quot;, &quot;-Dspring.datasource.shorturl01.username=$&#123;dataSourceUsername&#125;&quot;, &quot;-Dspring.datasource.shorturl01.password=$&#123;dataSourcePassword&#125;&quot;, &quot;-Dspring.datasource.shorturl02.jdbc-url=$&#123;dataSource3Url&#125;&quot;, &quot;-Dspring.datasource.shorturl02.username=$&#123;dataSourceUsername&#125;&quot;, &quot;-Dspring.datasource.shorturl02.password=$&#123;dataSourcePassword&#125;&quot;, &quot;-Dsys.config.domain=$&#123;sysConfigDomain&#125;&quot;, &quot;-jar&quot;, &quot;/shorturl-service-v1.1.0.jar&quot;]</code></pre><p><strong>要注意 ENTRYPOINT 括号内不能有换行。</strong></p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><pre><code class="sh">docker build -t chenxii81/shorturl-service-app:v1.1.0 .</code></pre><p>推送至 Docker Hub：</p><pre><code class="sh">docker push chenxii81/shorturl-service-app:v1.1.0   </code></pre><p>运行镜像：</p><pre><code class="sh">docker run -d \--name shorturl-service \--network postgresqlnet \--ip 172.12.0.10 \-e dataSource1Url=&quot;jdbc:postgresql://pg:172.12.0.2:5440/shorturl&quot; \-e dataSource2Url=&quot;jdbc:postgresql://pg:172.12.0.3:5441/shorturl&quot; \-e dataSource3Url=&quot;jdbc:postgresql://pg:172.12.0.4:5442/shorturl&quot; \-e dataSourceUsername=&quot;postgres&quot; \-e dataSourcePassword=&quot;12345678&quot; \-e sysConfigDomain=&quot;http://localhost:9000/&quot; \-p 9000:8000 \chenxii81/shorturl-service-app:v1.1.0</code></pre><h2 id="nginx-转发配置"><a href="#nginx-转发配置" class="headerlink" title="nginx 转发配置"></a>nginx 转发配置</h2><p>配置 nginx 请求后端接口：</p><p>nginx.conf 文件</p><pre><code>user nginx;worker_processes auto;error_log /var/log/nginx/error.log notice;pid /var/run/nginx.pid;events &#123;  worker_connections 1024;&#125;http &#123;  include /etc/nginx/mime.types;  default_type application/octet-stream;  log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot;&#39;                  &#39;$status $body_bytes_sent &quot;$http_referer&quot;&#39;                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;  access_log /var/log/nginx/access.log main;  sendfile on;  #tcp_nopush on;  keepalive_timeout 65;  #gzip on;  upstream www_server_pools &#123;    server 192.168.1.20:8000 weight=1;    server 192.168.1.21:8000 weight=1;  &#125;  include /etc/nginx/conf.d/*.conf;&#125;</code></pre><p>conf.d &#x2F; default.conf 文件：</p><pre><code>server &#123;  listen 80;  listen [::]:80;  server_name localhost;  # access_log /var/log/nginx/host.access.log main;  location = / &#123;    root /usr/share/nginx/html;    index index.html index.htm;  &#125;  location = /index.html &#123;    root /usr/share/nginx/html;  &#125;  location / &#123;    proxy_pass http://www_server_pools;    proxy_set_header Host $host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Proto $scheme;  &#125;  # redirect server error pages to the static page /50x.html  #  error_page 500 502 503 504 /50x.html;  location = /50x.html &#123;    root /usr/share/nginx/html;  &#125;&#125;</code></pre><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>报错1：</p><pre><code>***************************APPLICATION FAILED TO START***************************Description:Failed to configure a DataSource: &#39;url&#39; attribute is not specified and no embedded datasource could be configured.Reason: Failed to determine a suitable driver classAction:Consider the following:    If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.    If you have database settings to be loaded from a particular profile you may need to activate it (the profiles dev are currently active).Process finished with exit code 1</code></pre><p>确认数据库配置无误，但是启动一直报错找不到数据库相关的配置。可参考：<a href="https://blog.csdn.net/qq_39629277/article/details/97782030">Spring boot遇坑之配置数据源启动报错</a></p><p>需要从启动类上排除数据库自动配置。</p><pre><code class="java">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class&#125;)@EnableScheduling@EnableAsyncpublic class ShorturlServiceApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ShorturlServiceApplication.class, args);    &#125;&#125;</code></pre><p>报错2：</p><pre><code>Caused by: java.io.FileNotFoundException: class path resource [**/*.xml] cannot be opened because it does not exist</code></pre><p>可参考 <a href="https://www.cnblogs.com/jev-0987/p/12839193.html">Springboot 项目 无法读取resources下的mapper文件夹的.xml文件</a> 中的说明：</p><blockquote><p>关于PathMatchingResourcePatternResolver : <a href="https://www.cnblogs.com/loveLands/articles/9863195.html">https://www.cnblogs.com/loveLands/articles/9863195.html</a><br>果然getResource 和 getResources不同</p><p>getResource()：<br>1.从类的根路径下获取文件<br>getResources():<br>1.获取所有类路径下的指定文件<br>可以通过classpath<em>前缀指定，从所有的类路径下获取指定文件，与classpath前缀的区别是classpath前缀只能获取当类路径下的资源文件，而classpath</em>前缀可以获取所有类路径下的资源文件，包括jar包中的。</p></blockquote><p>报错3：项目正常启动后访问接口报 404</p><p>检查了 Controller 类上 RequestMapping 路径和方法上的 RequestMapping 路径都没问题，启动日志里的启动端口正常，确认 context-path&#x3D;’’。排查了半天之后发现，是刚才在解决数据源启动报错时在 Application 类上加了 @ComponentScan，并且只指向了 dao 的路径，导致其他 controller bean 没有加载到容器里，删除启动类上的 @ComponentScan 之后重启项目，就能正常访问到接口了。</p><p>报错4：通过 Docker Desktop 推送前端项目 docker 镜像至镜像仓库时报错：</p><pre><code>denied: requested access to the resource is denied</code></pre><p>在 stackoverflow 找到解决方案：镜像名称需要包含自己的 docker id 才能推送。改一下镜像名称，重新打包推送即可。</p><pre><code>docker build -t your-docker-id/image-name:tag .</code></pre><h2 id="其他问题记录"><a href="#其他问题记录" class="headerlink" title="其他问题记录"></a>其他问题记录</h2><h3 id="hashcode-可能为负数"><a href="#hashcode-可能为负数" class="headerlink" title="hashcode 可能为负数"></a>hashcode 可能为负数</h3><p>数据量较大的场景下，不同的长链接生成的 hashcode 可能会重复，进而导致生成的短链接重复。为了避免这种情况，在发现短链接重复时，需要进行重试，我采用的方案是发现重复时直接在原始链接后面拼接一个当前时间戳的参数，再重新生成。这里有个坑，就是生成的短链接 hashcode 可能为负数，导致 base62 转换时数组越界。</p><p>解决方案也很简单，就是在进行 base62 转码时，先将负的 hashcode 转为正的。本来想简单直接取绝对值，后来发现有更好的实现方式：直接用位操作去掉负号。参考 <a href="https://www.cnblogs.com/k-class/p/13773161.html">hashcode返回值可能为负数</a></p><pre><code>long hash = key.hashCode() &amp; Integer.MAX_VALUE; // caution, make value not minus</code></pre><h3 id="Async-失效问题"><a href="#Async-失效问题" class="headerlink" title="@Async 失效问题"></a>@Async 失效问题</h3><p>开发过程中想把每个短链接访问次数记录下来，于是又加了一个字段：visit_count。每个短链接被访问时就将此值加 1。想把更新操作放在主库中异步去更新，遇到了这个问题。</p><p>这算是一个老生常谈的问题了，先排查以下几点：</p><ul><li>启动类上是否加了 @EnableAsync</li><li>异步方法的返回值只能是 void 或 Future</li><li>没有走 Spring 的代理类</li></ul><p>3 个问题中两个 😭</p><p>参考：<a href="https://blog.csdn.net/YoungLee16/article/details/88398045">Spring boot 注解@Async无效,不起作用</a></p><h3 id="Value-取到错误的配置值"><a href="#Value-取到错误的配置值" class="headerlink" title="@Value 取到错误的配置值"></a>@Value 取到错误的配置值</h3><p>配置为：</p><pre><code>sys.config.sign-check: ON</code></pre><p>但是调试中发现程序中对应的变量值为 true。尝试将 ON 删除，保持配置为空再重启之后发现取到的值为 null。最后将配置改为：</p><pre><code>sys.config.sign-check: &quot;ON&quot;</code></pre><p>之后，可以正常读取到 ON 了。</p>]]></content>
      
      
      <categories>
          
          <category> 项目日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Vue.js </tag>
            
            <tag> 短链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime常用快捷键操作</title>
      <link href="/2024/04/08/4eabab8dbb84/"/>
      <url>/2024/04/08/4eabab8dbb84/</url>
      
        <content type="html"><![CDATA[<p>平时虽然用 sublime 比较多，但只记住文本选择的几个实用快捷键，还是在 Windows 平台上。这两天用 sublime 改代码，发现很多操作的快捷键都要现查，特意整理一下。</p><span id="more"></span><table><thead><tr><th>快捷键</th><th>操作</th></tr></thead><tbody><tr><td>⌘ + T</td><td>查询指定文件</td></tr><tr><td>⌘ + W</td><td>关闭当前文件</td></tr><tr><td>⌘ + ⇧ + T</td><td>重新打开最新关闭的文件</td></tr><tr><td>⌘ + 数字</td><td>切换 tab 页</td></tr><tr><td>⌘ + L</td><td>选中当前行</td></tr><tr><td>⌘ + D</td><td>选中下一个相同的词</td></tr><tr><td>⌘ + ⌃ + g</td><td>选中当前文件中所有相同的词</td></tr><tr><td>⌃ + ⇧ + K</td><td>删除当前行</td></tr><tr><td>⌘ + K + U</td><td>转为大写</td></tr><tr><td>⌘ + K + L</td><td>转为小写</td></tr><tr><td>⌃ + G</td><td>转到指定行</td></tr><tr><td>⌘ + ⇧ + ↩</td><td>在当前行前插入新行</td></tr><tr><td>⌘ + ↩</td><td>在当前行后插入新行</td></tr><tr><td>⌘ + K + K</td><td>删除当前行光标之后的内容</td></tr><tr><td>⌘ + K + ⌫</td><td>删除当前行光标之前的内容</td></tr><tr><td>⌘ + ⇧ + D</td><td>复制当前行</td></tr><tr><td>⌘ + J</td><td>合并多行</td></tr><tr><td>⌘ + ⌥ + [1 2 3 4]</td><td>按列拆分窗口</td></tr><tr><td>⌘ + ⌥ + 5</td><td>组成网格窗口</td></tr><tr><td>⌘ + ⌃ + 方向键</td><td>上下移动当前行</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-cactus主题再开发</title>
      <link href="/2024/04/04/1d8424548645/"/>
      <url>/2024/04/04/1d8424548645/</url>
      
        <content type="html"><![CDATA[<p>主题地址：<a href="https://github.com/lozhu20/hexo-theme-cactus">hexo-theme-cactus</a></p><span id="more"></span><p>之前用的是博客主题是 hexo-theme-aomori，一款比较简洁的主题，用了大半年。</p><p>正逢清明假期，想了解一下其他博客实现，如 typecho、solo、aurora、以及基于 Next.js 实现之类的。无意间看到两款比较喜欢的 Hexo 主题：<a href="https://blog.taire.de/">hexo-theme-quiet</a> 和 <a href="https://github.com/lozhu20/hexo-theme-cactus">hexo-theme-cactus</a>。<br>原文链接：<a href="https://blog.lixiaomu.fun/posts/43857/">Hexo 10款好看的主题｜新手建站必备！</a></p><p>本来开始想切换成 quite 的，简洁大方，记录一下生活、发点照片之类的应该效果很好，但是把 quite 主题拉到本地之后，发现和作者的 Demo 样式不太一致，使用文档也不是很详细，就放弃了。</p><p>cactus 主题的设计给人眼前一亮的感觉，有 dark、white、light、classic 4 种样式可以选择，非常棒！制作一款优秀的主题，不光要有技术，能投入大量的时间，前期的设计也很重要，quite 主题下最多的 issues 就是：能不能给文章详情添加目录？作者的答复是因为前期设计就没考虑目录，要修改的话会比较麻烦，需要时间，到现在过去了很久还没更新。</p><p>可能是强迫症吧，cactus 主题切换之前改了一些小细节：</p><ol><li>💄 默认的黑色主题下字体比较小，看起来比较费劲，将默认主题切换为了 white</li><li>💄 logo 尺寸调整为 55</li><li>💄 nav 靠网站标题太近，调整 nav margin-top&#x3D;5px</li><li>💄 去掉社交网络中间的逗号</li><li>💄 移除文章详情页标签信息的下划线</li><li>💄 将文章详情页的标签信息颜色从红色修改为绿色</li><li>💄 修改默认的 content-width&#x3D;52</li><li>💄 移除默认的网站图标 hover 效果，默认非 hover 网站图标是灰色，不好看</li></ol><p>优化后的主题：<a href="https://github.com/lozhu20/hexo-theme-cactus">hexo-theme-cactus</a></p><p>添加了 Disqus 评论，Github 图床，后面努力更新吧。</p><hr><p>✅ 2024-04-07 更新</p><ol><li>⚙️ 觉得 Disqus 评论不够简约，了解了 utterances，外观简约和页面风格更搭，基于 GitHub 更方便管理，正好 utterances 评论也是 cactus 主题默认支持的两个评论系统之一。</li><li>💄 删除 utterances 评论默认的 margin-left 和 margin-right。</li><li>🐛 Friends 页面的 avatar 高度样式被覆盖，导致变成了长方形，给高度属性加了 <code>!important</code>。</li><li>✨ 给 Friends 页面添加评论，方便添加友链。</li><li>🍺 文章详情页的图片上下左右都有留白，需要去掉留白，<del>未解决</del>。(调了好久，发现只有 Mac 截图产生的图片才有此问题，平板截图、照片均无此问题，原因不明)</li><li>💄 修改文章 url 路径为 hash: permalink: :year&#x2F;:month&#x2F;:day&#x2F;:hash&#x2F;，默认使用 :title，当 ttile 中包含中文时会导致 utterances label 乱码。</li></ol><hr><p>✅ 2024-04-14 更新</p><ol><li>✨ 底部增加 moe icp 萌国 ICP 备案展示</li><li>✨ 导航增加开往​</li><li>✨ 新增文章详情页图片弹窗展示​</li><li>💄 将默认字体大小从 14px 调整 为 16px，方便阅读</li><li>💄 文章分享按钮从纵向改为横向展示​</li><li>🐛 修复主页 Copyright 信息与右侧导航未水平对齐的问题​</li><li>🐛 修复小尺寸屏幕设备上页面内容与底部导航栏重叠问题</li><li>🌍 优化部分中文翻译​</li><li>🔖 发布 Release​</li></ol><hr><p>✅ 2024-04-16 更新</p><ol><li>✨ 增加 RSS 订阅动态展示</li></ol><hr><p>❌ 目前发现的 bug</p><p>🐛目前发现的 bug：文章分享按钮重复打开、关闭之后，按钮上方会有莫名其妙的空白产生，随着点击次数增加，空白区域逐渐增大。</p>]]></content>
      
      
      <categories>
          
          <category> 博客维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客主题 </tag>
            
            <tag> hexo-theme-cactus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-cactus主题再开发</title>
      <link href="/2024/04/04/12612b16a42c/"/>
      <url>/2024/04/04/12612b16a42c/</url>
      
        <content type="html"><![CDATA[<p>主题地址：<a href="https://github.com/lozhu20/hexo-theme-cactus">hexo-theme-cactus</a></p><p>之前用的是博客主题是 hexo-theme-aomori，一款比较简洁的主题，用了大半年。</p><p>正逢清明假期，想了解一下其他博客实现，如 typecho、solo、aurora、以及基于 Next.js 实现之类的。无意间看到两款比较喜欢的 Hexo 主题：<a href="https://blog.taire.de/">hexo-theme-quiet</a> 和 <a href="https://github.com/lozhu20/hexo-theme-cactus">hexo-theme-cactus</a>。<br>原文链接：<a href="https://blog.lixiaomu.fun/posts/43857/">Hexo 10款好看的主题｜新手建站必备！</a></p><p>本来开始想切换成 quite 的，简洁大方，记录一下生活、发点照片之类的应该效果很好，但是把 quite 主题拉到本地之后，发现和作者的 Demo 样式不太一致，使用文档也不是很详细，就放弃了。</p><p>cactus 主题的设计给人眼前一亮的感觉，有 dark、white、light、classic 4 种样式可以选择，非常棒！制作一款优秀的主题，不光要有技术，能投入大量的时间，前期的设计也很重要，quite 主题下最多的 issues 就是：能不能给文章详情添加目录？作者的答复是因为前期设计就没考虑目录，要修改的话会比较麻烦，需要时间，到现在过去了很久还没更新。</p><p>可能是强迫症吧，cactus 主题切换之前改了一些小细节：</p><ol><li>💄 默认的黑色主题下字体比较小，看起来比较费劲，将默认主题切换为了 white</li><li>💄 logo 尺寸调整为 55</li><li>💄 nav 靠网站标题太近，调整 nav margin-top&#x3D;5px</li><li>💄 去掉社交网络中间的逗号</li><li>💄 移除文章详情页标签信息的下划线</li><li>💄 将文章详情页的标签信息颜色从红色修改为绿色</li><li>💄 修改默认的 content-width&#x3D;52</li><li>💄 移除默认的网站图标 hover 效果，默认非 hover 网站图标是灰色，不好看</li></ol><p>优化后的主题：<a href="https://github.com/lozhu20/hexo-theme-cactus">hexo-theme-cactus</a></p><p>添加了 Disqus 评论，Github 图床，后面努力更新吧。</p><hr><p>✅ 2024-04-07 更新</p><ol><li>⚙️ 觉得 Disqus 评论不够简约，了解了 utterances，外观简约和页面风格更搭，基于 GitHub 更方便管理，正好 utterances 评论也是 cactus 主题默认支持的两个评论系统之一。</li><li>💄 删除 utterances 评论默认的 margin-left 和 margin-right。</li><li>🐛 Friends 页面的 avatar 高度样式被覆盖，导致变成了长方形，给高度属性加了 <code>!important</code>。</li><li>✨ 给 Friends 页面添加评论，方便添加友链。</li><li>🍺 文章详情页的图片上下左右都有留白，需要去掉留白，<del>未解决</del>。(调了好久，发现只有 Mac 截图产生的图片才有此问题，平板截图、照片均无此问题，原因不明)</li><li>💄 修改文章 url 路径为 hash: permalink: :year&#x2F;:month&#x2F;:day&#x2F;:hash&#x2F;，默认使用 :title，当 ttile 中包含中文时会导致 utterances label 乱码。</li></ol><hr><p>✅ 2024-04-14 更新</p><ol><li>✨ 底部增加 moe icp 萌国 ICP 备案展示</li><li>✨ 导航增加开往​</li><li>✨ 新增文章详情页图片弹窗展示​</li><li>💄 将默认字体大小从 14px 调整 为 16px，方便阅读</li><li>💄 文章分享按钮从纵向改为横向展示​</li><li>🐛 修复主页 Copyright 信息与右侧导航未水平对齐的问题​</li><li>🐛 修复小尺寸屏幕设备上页面内容与底部导航栏重叠问题</li><li>🌍 优化部分中文翻译​</li><li>🔖 发布 Release​</li></ol><hr><p>✅ 2024-04-16 更新</p><ol><li>✨ 增加 RSS 订阅动态展示</li></ol><hr><p>❌ 目前发现的 bug</p><p>🐛目前发现的 bug：文章分享按钮重复打开、关闭之后，按钮上方会有莫名其妙的空白产生，随着点击次数增加，空白区域逐渐增大。</p>]]></content>
      
      
      <categories>
          
          <category> 博客维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客主题 </tag>
            
            <tag> hexo-theme-cactus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署PostgreSQL主从</title>
      <link href="/2024/03/14/9538cc617188/"/>
      <url>/2024/03/14/9538cc617188/</url>
      
        <content type="html"><![CDATA[<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><h3 id="创建-Docker-网络"><a href="#创建-Docker-网络" class="headerlink" title="创建 Docker 网络"></a>创建 Docker 网络</h3><p>因为只有一台机器，本例中主库和从库都部署在同一个机器中，为了主库和从库之间能通信，需要在同一个网络中固定主库和从库容器的 IP。</p><p>主库地址：172.12.0.2</p><p>从库地址：172.12.0.3</p><span id="more"></span><p>创建 Docker 网络：</p><pre><code class="sh"># 创建docker network create --driver bridge --subnet 172.12.0.0/16 --gateway 172.12.0.1 postgresqlnet# 查看docker network lsdocker network inspect postgresqlnet</code></pre><h3 id="数据库安装"><a href="#数据库安装" class="headerlink" title="数据库安装"></a>数据库安装</h3><p>拉取最新版 pg  docker镜像：</p><pre><code class="sh">docker pull postgres</code></pre><p>启动容器：</p><pre><code class="sh"># 主库docker run -id --name=shorturl00 --network postgresqlnet --network-alias shorturl00 --ip 172.12.0.2 -v shorturl00:/var/lib/postgresql/data -p 5440:5440 -e POSTGRES_PASSWORD=12345678 -e LANG=C.UTF-8 postgres# 从库docker run -id --name=shorturl01 --network postgresqlnet --network-alias shorturl01 --ip 172.12.0.3 -v shorturl01:/var/lib/postgresql/data -p 5441:5441 -e POSTGRES_PASSWORD=12345678 -e LANG=C.UTF-8 postgres</code></pre><p>查看容器运行情况：</p><pre><code class="sh">docker ps -a</code></pre><h2 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h2><p>因为没有使用默认的5432端口，先修改主库的连接端口为5440。进入主库容器，编辑 <code>/var/lib/postgresql/data/postgresql.conf</code> 文件：</p><pre><code>port=5440</code></pre><p>进入主库创建同步用户：</p><pre><code class="sh">create role replicate with login password &#39;12345678&#39; replication;</code></pre><p>返回 “CREATE ROLE” 表示创建成功。</p><p>修改文件 <code>/var/lib/postgresql/data/pg_hba.conf</code> 文件，修改 IPv4 和 replication 部分：</p><pre><code># IPv4 local connections:host    all             all             0.0.0.0/0               trust# replication privilege.host    replication     all             0.0.0.0/0               trust</code></pre><p>trust 表示不需要密码即可连接，不可用于生产环境！！</p><p>主库开启归档模式，在数据库中执行：</p><pre><code class="sh">ALTER SYSTEM SET archive_command = ON ;ALTER SYSTEM SET archive_command = &#39;cp -i %p /home/%f &lt;/dev/null&#39;;</code></pre><p>完成以上配置，重启主库。</p><h2 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h2><p>进入从库容器先删除 <code>/var/lib/postgresql/data</code> 目录，然后进行首次同步，在终端执行：</p><pre><code class="sh">pg_basebackup -h 172.12.0.2 -p 5440 -U replicate -w -Fp -Xs -Pv -R -D /var/lib/postgresql/data/ -l postgresqlbackup20240313</code></pre><p>成功执行完之后，编辑从库 <code>/var/lib/postgresql/data/postgresql.conf</code> 文件，修改启动端口：</p><pre><code>port=5441</code></pre><p>设置从库 primary_conninfo：</p><pre><code class="sh">ALTER SYSTEM SET  primary_conninfo = &#39;user=replicate host=172.12.0.2 port=5440 sslmode=prefer sslcompression=0 gssencmode=prefer krbsrvname=postgres target_session_attrs=any&#39;;ALTER SYSTEM SET max_connections =&#39;300&#39;;</code></pre><p>配置完之后重启从库。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在主库中增删数据，在从库中可以查询到数据变化。</p><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="从库启动报错"><a href="#从库启动报错" class="headerlink" title="从库启动报错"></a>从库启动报错</h3><p>报错信息：</p><pre><code>2024-03-13 15:09:52.321 UTC [47] FATAL:  could not connect to the primary server: connection to server at &quot;172.12.0.2&quot;, port 5400 failed: Connection refused        Is the server running on that host and accepting TCP/IP connections?</code></pre><p>配置完从库 primary_conninfo 信息之后，从库重启报错提示无法连接 172.12.0.2:5400 ，后来排查发现是端口写错了，应该是5440才对，可以到 &#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&#x2F;postgresql.auto.conf 中修改这个配置，修改为正确的端口重启，该错误消失。</p><h3 id="主库从库数据版本不一致"><a href="#主库从库数据版本不一致" class="headerlink" title="主库从库数据版本不一致"></a>主库从库数据版本不一致</h3><p>从库配置完之后重启报错：</p><pre><code>2024-03-13 15:30:09.331 UTC [31] FATAL:  database system identifier differs between the primary and standby2024-03-13 15:30:09.331 UTC [31] DETAIL:  The primary&#39;s identifier is 7344380814831386663, the standby&#39;s identifier is 7344385460223520808.</code></pre><p>网上查资料发现是主库数据与从库数据不一致导致，<strong>从库初始化时删除 &#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data 目录</strong>。参考：<a href="https://blog.csdn.net/fct2001140269/article/details/102782442">docker搭建postgresql9.4主从同步复制集群</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zspwf/p/16130201.html">Docker部署PostgreSQL主从</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot3+PageHelper分页不生效问题</title>
      <link href="/2023/12/22/8f8f5be5738d/"/>
      <url>/2023/12/22/8f8f5be5738d/</url>
      
        <content type="html"><![CDATA[<p>今天在做一个小项目，引入 PageHelper 时踩了一个坑，记录一下。</p><p>解决方案参考：<a href="https://blog.csdn.net/pjymyself/article/details/119203900">SpringBoot+MyBatis使用pagehelper分页插件及其注意事项（含解决分页不生效问题）</a></p><span id="more"></span><p>环境：</p><ul><li>SpringBoot 3.2.0</li><li>JDK 17</li><li>Postgresql 15</li><li>PageHelper 1.2.12</li></ul><p>依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>使用</p><pre><code class="java">     public Response&lt;PageInfo&lt;User&gt;&gt; queryAllUser(int pageNum, int pageSize) &#123;        PageHelper.startPage(pageNum, pageSize);        List&lt;User&gt; userList = userMapper.selectAll();        return ResponseUtil.success(new PageInfo&lt;&gt;(userList));    &#125;</code></pre><p>全部数据返回到前端，没有产生分页的效果。</p><p>看了大多数不生效的情况就是以下几种：</p><ol><li>分页和真正的数据查询之间夹杂了其他操作</li><li>先执行了查询然后再设置的分页</li><li>依赖导入错误，导入的不是 <code>pagehelper-spring-boot-starter</code></li></ol><p>但是从自己的代码确认不是这类问题。</p><p>找了好久，看到 <a href="https://blog.csdn.net/pjymyself/article/details/119203900">SpringBoot+MyBatis使用pagehelper分页插件及其注意事项（含解决分页不生效问题）</a> 这篇博客末尾提到了使用分页拦截器，抱着试试看的心态，加了个一个配置类，确实生效了，原因未知。</p><pre><code class="java">@Configurationpublic class PageHelperConfig &#123;    @Bean    public Interceptor[] plugins() &#123;        return new Interceptor[]&#123;new PageInterceptor()&#125;;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PageHelper </tag>
            
            <tag> 分页失效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在MacOS上编译jdk12</title>
      <link href="/2023/12/19/b55c9b0679f2/"/>
      <url>/2023/12/19/b55c9b0679f2/</url>
      
        <content type="html"><![CDATA[<p>最近在跟着《深入理解Java虚拟机》复习 JVM 相关的知识，想再编译一下 JDK。因为之前有编译过 JDK8，因为版本较老，踩坑比较多；并且现在 Java 每半年一个大版本，新版本还没来得及了解就过时了，更别提去使用了，所以这次打算用 JDK11 来编译 OpenJDK12。</p><p>环境信息：</p><ul><li>系统版本：MacOS 13.6.1 (22G313)</li><li>boot jdk：idk-11.0.21</li><li>Xcode 版本：15.0</li></ul><span id="more"></span><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>要编译 JDK，肯定要先有源码才能编译。源码从 Oracle 官网下载：<a href="https://hg.openjdk.org/jdk/jdk12%EF%BC%8C%E5%B7%A6%E8%BE%B9%E8%8F%9C%E5%8D%95%E9%80%89%E6%8B%A9%E6%96%B9%E4%BE%BF%E7%9A%84%E6%A0%BC%E5%BC%8F%E4%B8%8B%E8%BD%BD%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%BC%80%E5%A7%8B%E6%88%91%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%98%AF">https://hg.openjdk.org/jdk/jdk12，左边菜单选择方便的格式下载即可，开始我下载的是</a> zip，但是解压的时候总是会提示意料之外的文件结尾，解压不出来，所以就换了 tar 格式下载。</p><h2 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h2><h3 id="freetype"><a href="#freetype" class="headerlink" title="freetype"></a>freetype</h3><p>OpenJDK 中用到 freetype 渲染，所以需要先安装好 freetype。</p><pre><code class="sh">brew install freetype</code></pre><h3 id="ccache"><a href="#ccache" class="headerlink" title="ccache"></a>ccache</h3><p>ccache，是一个编译器缓存，该工具会高速缓存编译生成的信息，并在编译的特定部分使用高速缓存的信息。</p><pre><code class="sh">brew install ccache</code></pre><h3 id="安装-JDK11"><a href="#安装-JDK11" class="headerlink" title="安装 JDK11"></a>安装 JDK11</h3><p>要得到梯子，首先要有个梯子。同样的道理，要编译出 JDK，首先得有个 JDK。只能通过低版本的 JDK 编译出高版本的 JDK，不能反过来。下载 JDK11 ，配置好环境变量，就不多赘述了。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>接下来就可以开始编译了，如果有过编译记录，先运行 <code>make clean</code> 和 <code>make clean-dist</code> 清空相关目录，然后在根目录运行 <code>configure</code></p><pre><code class="sh">./configure --disable-warnings-as-errors --with-debug-level=slowdebug --with-jvm-variants=server --enable-ccache</code></pre><p>顺利的话会输出以下内容</p><pre><code>====================================================The existing configuration has been successfully updated in/Users/lozhu/Documents/projects/jdk12-06222165c35f/build/macosx-x86_64-server-slowdebugusing configure arguments &#39;--disable-warnings-as-errors --with-debug-level=slowdebug --with-jvm-variants=server --enable-ccache&#39;.Configuration summary:* Debug level:    slowdebug* HS debug level: debug* JVM variants:   server* JVM features:   server: &#39;aot cds cmsgc compiler1 compiler2 dtrace epsilongc g1gc graal jfr jni-check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm-structs&#39;* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64* Version string: 12-internal+0-adhoc.root.jdk12-06222165c35f (12-internal)Tools summary:* Boot JDK:       openjdk version &quot;11.0.21&quot; 2023-10-17 LTS OpenJDK Runtime Environment Microsoft-8519785 (build 11.0.21+9-LTS) OpenJDK 64-Bit Server VM Microsoft-8519785 (build 11.0.21+9-LTS, mixed mode)  (at /opt/java/jdk-11.0.21+9/Contents/Home)* Toolchain:      clang (clang/LLVM from Xcode 15.0.1)* C Compiler:     Version 15.0.0 (at /usr/bin/clang)* C++ Compiler:   Version 15.0.0 (at /usr/bin/clang++)Build performance summary:* Cores to use:   8* Memory limit:   16384 MB* ccache status:  Active (4.8.3)WARNING: The result of this configuration has overridden an olderconfiguration. You *should* run &#39;make clean&#39; to make sure you get aproper build. Failure to do so might result in strange build problems.</code></pre><p>然后运行 <code>make images</code> 进行编译，根据机器配置编译时间长短会有较大差异，2020款MacBook pro编译了15分钟。</p><pre><code>Stopping sjavac serverFinished building target &#39;images&#39; in configuration &#39;macosx-x86_64-server-slowdebug&#39;</code></pre><p>出现这个提示就说明编译成功了！编译出的 JDK 位于：.&#x2F;build&#x2F;macosx-x86_64-server-slowdebug&#x2F;jdk&#x2F;bin 下，运行 <code>./java -version</code> 可以看到自己编译出的 JDK 版本：</p><pre><code>openjdk version &quot;12-internal&quot; 2019-03-19OpenJDK Runtime Environment (slowdebug build 12-internal+0-adhoc.root.jdk12-06222165c35f)OpenJDK 64-Bit Server VM (slowdebug build 12-internal+0-adhoc.root.jdk12-06222165c35f, mixed mode)</code></pre><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>.&#x2F;jdk12-06222165c35f&#x2F;src&#x2F;java.base&#x2F;macosx&#x2F;native&#x2F;libosxsecurity&#x2F;KeystoreImpl.m note: did not find header ‘JavaNativeFoundation.h’ in framework ‘JavaNativeFoundation’ (loaded from ‘&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX14.0.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks’)</p><p><strong>解决</strong></p><p>这个问题很明显，就是系统路径的问题，但是一直苦于不知道 JavaNativeFoundation 在哪里引入的，在这里卡了两三个小时，搜索了很多国内外的网站也没找到解决方案。最后是关掉电脑后用手机搜这个问题，在 CSDN 上搜到了一些之前没搜到的资料，虽然说问题不完全相同，但是算是同一个问题，提供了很大的帮助。</p><p>参考：<a href="https://www.jianshu.com/p/885c718df9de">macOS Catalina + Xcode 12 编译OpenJDK 14 错误解决</a></p><p>系统版本升级，一部分文件路径有变化。新的路径：&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX14.sdk。</p><p>在 .&#x2F;build&#x2F;macosx-x86_64-server-slowdebug&#x2F;spec.gmk 中搜索 <code>SYSROOT_CFLAGS</code> 和 <code>SYSROOT_LDFLAGS</code> ，注释掉这两个变量，新增下面的内容</p><pre><code>SYSROOT_CFLAGS := -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk -iframework /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks -F /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks/JavaNativeFoundation.frameworkSYSROOT_LDFLAGS := -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk -iframework /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks -F /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks/JavaNativeFoundation.frameworkBUILD_SYSROOT_CFLAGS:=-isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk -iframework /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks -F /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks/JavaNativeFoundation.frameworkBUILD_SYSROOT_LDFLAGS:=-isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk -iframework /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks -F /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks/JavaNativeFoundation.framework</code></pre><p>在 .&#x2F;build&#x2F;macosx-x86_64-server-slowdebug&#x2F;buildjdk-spec.gmk 中搜索 <code>SYSROOT_CFLAGS</code> 和 <code>SYSROOT_LDFLAGS</code> ，注释掉这两个变量，新增下面的内容</p><pre><code>BUILD_SYSROOT_CFLAGS:=-isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk -iframework /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks -F /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks/JavaNativeFoundation.frameworkBUILD_SYSROOT_LDFLAGS:=-isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk -iframework /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks -F /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks/JavaNativeFoundation.frameworkBUILD_SYSROOT_CFLAGS:=-isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk -iframework /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks -F /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks/JavaNativeFoundation.frameworkBUILD_SYSROOT_LDFLAGS:=-isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk -iframework /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks -F /Library/Developer/CommandLineTools/SDKs/MacOSX13.1.sdk/System/Library/Frameworks/JavaNativeFoundation.framework</code></pre><hr><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>assert 未定义</p><p><strong>解决</strong></p><p>直接将报错文件中有 assert 的行删除或者注释掉即可，只涉及一个文件，不到十行代码。</p><hr><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>clang: error: SDK does not contain ‘libarclite’ at the path ‘&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;lib&#x2F;arc&#x2F;libarclite_macosx.a’; try increasing the minimum deployment target</p><p><strong>解决</strong></p><p>参考：<a href="https://blog.csdn.net/u013712343/article/details/134262640">iOS Xcode 升级Xcode15报错: SDK does not contain ‘libarclite‘ at the path ‘&#x2F;Applications&#x2F;Xcode.app&#x2F;Con…</a></p><p>文件缺失，从 <a href="GitHub">https://codeload.github.com/kamyarelyasi/Libarclite-Files/zip/refs/heads/main</a> 下载 <code>libarclite_macosx.a</code> 文件，复制到 <code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/</code> 路径下。这里有个问题就是，arc 路径需要自己创建，但是受系统权限限制，sudo 权限也创建不了这个目录，只能更改系统设置关闭 SIP。重启电脑，按住 ⌘ + R，进入保护模式后打开终端，输入命令：<code>crsutil disable</code> ，重启即可。要重新开启 SIP，命令为：<code>crsutil enable</code></p><p>参考的链接里单词写错了，是 <code>crsutil</code> 不是 <code>csrutil</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 MacOS 上编译 OpenJDK</title>
      <link href="/2023/12/06/b4d39a195904/"/>
      <url>/2023/12/06/b4d39a195904/</url>
      
        <content type="html"><![CDATA[<p>在 MacOS 系统上编译 OpenJDK 遇到的一些问题及对应的解决方案的记录。因为 Java8 发布时间已经比较久，到现在各个操作系统很多地方都已经发生很大变化，所以小问题比较多，建议编译更好版本的 JDK，坑应该会少一些。</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1、Mac 上安装 Mercurial 总是报错，没找到什么原因，所以用不了 <code>hg clone <a href="http://hg.openjdk.java.net/jdk8">http://hg.openjdk.java.net/jdk8</a></code> 这种方式。</p><p>jdk8 源码地址：<a href="http://jdk.java.net/java-se-ri/8-MR3">jdk8u41源码下载</a>  <a href="https://download.java.net/openjdk/openjdk/jdk8/promoted/b132/openjdk-8-src-b132-03_mar_2014.zip">zip文件下载</a></p><p>2、安装 freetype 和 ccache：</p><p><code>brew install freetype</code></p><p><code>brew install ccache</code></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>运行 configure：</p><pre><code class="bash">./configure --with-freetype-include=/usr/local/include/freetype2 --with-freetype-lib=/usr/local/lib/</code></pre><p><em>遇到的报错及解决方案</em></p><p>1、The C compiler (located as &#x2F;usr&#x2F;bin&#x2F;gcc) does not seem to be the required GCC compiler.</p><pre><code>打开文件common/autoconf/generated-configure.sh，搜索compiler is required注释或把报错命令改为echo即可。</code></pre><p>比较顺利，只遇到上面一个错误。</p><p>成功输出：</p><pre><code>........config.status: creating /Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-release/spec.shconfig.status: creating /Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-release/Makefileconfig.status: creating /Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-release/config.h====================================================A new configuration has been successfully created in/Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/build/macosx-x86_64-normal-server-releaseusing configure arguments &#39;--with-freetype-include=/usr/local/include/freetype2 --with-freetype-lib=/usr/local/lib/&#39;.Configuration summary:* Debug level:    release* JDK variant:    normal* JVM variants:   server* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64Tools summary:* Boot JDK:       openjdk version &quot;1.8.0_292&quot; OpenJDK Runtime Environment (Zulu 8.54.0.21-CA-macosx) (build 1.8.0_292-b10) OpenJDK 64-Bit Server VM (Zulu 8.54.0.21-CA-macosx) (build 25.292-b10, mixed mode)  (at /opt/java/zulu8.54.0.21-ca-jdk8.0.292-macosx_x64)* C Compiler:      version  (at /usr/bin/gcc)* C++ Compiler:    version  (at /usr/bin/g++)Build performance summary:* Cores to use:   4* Memory limit:   16384 MB* ccache status:  installed, but disabled (version older than 3.1.4)Build performance tip: ccache gives a tremendous speedup for C++ recompilations.You have ccache installed, but it is a version prior to 3.1.4. Try upgrading.</code></pre><p>运行 <code>make all</code></p><p>报错及解决：</p><p>1、clang: error: include path for libstdc++ headers not found; pass ‘-stdlib&#x3D;libc++’ on the command line to use the libc++ standard library instead [-Werror,-Wstdlibcxx-not-found]</p><p><a href="https://blog.csdn.net/quantum7/article/details/108466760">MAC编译OpenJDK8：clang: error: include path for libstdc++ headers not found</a></p><p><a href="https://github.com/quantum6/xcode-missing-libstdcpp.git">The missing libstdc++ headers and libraries for Xcode 10 or above.</a></p><p>2、</p><pre><code>l-op-parentheses]    if ( instr-&gt;is_ideal_branch() &amp;&amp; instr-&gt;label_position() == -1 ||         ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~/Users/chenxii/Documents/Java/jdk8/openjdk8u41/openjdk/hotspot/src/share/vm/adlc/archDesc.cpp:336:35: note: place parentheses around the &#39;&amp;&amp;&#39; expression to silence this warning    if ( instr-&gt;is_ideal_branch() &amp;&amp; instr-&gt;label_position() == -1 ||                                  ^         (                                                        )</code></pre><h2 id="其他可能遇到的错误"><a href="#其他可能遇到的错误" class="headerlink" title="其他可能遇到的错误"></a>其他可能遇到的错误</h2><p>.&#x2F;configure –with-freetype-include&#x3D;&#x2F;usr&#x2F;local&#x2F;include&#x2F;freetype2 –with-freetype-lib&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;</p><p>报错：The C compiler (located as &#x2F;usr&#x2F;bin&#x2F;gcc) does not seem to be the required GCC compiler.<br>打开文件common&#x2F;autoconf&#x2F;generated-configure.sh，搜索compiler is required<br>注释或把报错命令改为echo即可。</p><hr><p>(base) ➜  jdk8 make<br>Building OpenJDK for target ‘default’ in configuration ‘macosx-x86_64-normal-server-release’</p><p>Starting langtools</p><p>&#x2F;bin&#x2F;sh: line 0: cd: &#x2F;Users&#x2F;chenxii&#x2F;Documents&#x2F;Java&#x2F;jdk8&#x2F;jdk8&#x2F;langtools&#x2F;make: No such file or directory<br>make: *** [langtools-only] Error 1</p><p>解决方案参考：<a href="https://stackoverflow.com/questions/34703703/jdk8-build-error-langtools">https://stackoverflow.com/questions/34703703/jdk8-build-error-langtools</a></p><hr><p>执行：.&#x2F;get_source.sh</p><p>(base) ➜  jdk8 .&#x2F;get_source.sh</p><p>Repositories:  corba jaxp jaxws langtools jdk hotspot nashorn</p><pre><code>            corba:   hg clone http://hg.openjdk.java.net/jdk8/jdk8/corba corba             jaxp:   hg clone http://hg.openjdk.java.net/jdk8/jdk8/jaxp jaxp            corba:   requesting all changes</code></pre><p>Waiting 5 secs before spawning next background command.</p><p>lcm.cpp:52:35: error: ordered comparison between pointer and zero (‘address’ (aka ‘unsigned char *’) and ‘int’) </p><p>解决：编辑&#x2F;hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;opto&#x2F;lcm.cpp:52 原：if (Universe::narrow_oop_base() &gt; 0) 修改后： if (Universe::narrow_oop_base()!&#x3D; NULL) { &#x2F;&#x2F; Implies UseCompressedOops.</p><hr><p>error: ordered comparison between pointer and zero</p><p>修改openjdk&#x2F;hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;virtualspace.cpp<br>　　修改331行为<br>　　if (base() !&#x3D; 0) {</p><hr><p>fatal error: ‘JavaNativeFoundation&#x2F;JavaNativeFoundation.h’ file not found<br>#import &lt;JavaNativeFoundation&#x2F;JavaNativeFoundation.h&gt;</p><p>(base) ➜  openjdk  sudo find &#x2F; -name “<em>JavaNativeFoundation.h</em>“<br>Password:<br>find: &#x2F;Library&#x2F;Application Support&#x2F;com.apple.TCC: Operation not permitted<br>&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX11.1.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaNativeFoundation.framework&#x2F;Versions&#x2F;A&#x2F;Headers&#x2F;JavaNativeFoundation.h<br>&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX10.15.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Versions&#x2F;A&#x2F;Frameworks&#x2F;JavaNativeFoundation.framework&#x2F;Versions&#x2F;A&#x2F;Headers&#x2F;JavaNativeFoundation.h</p><p>编辑：<br>vim hotspot&#x2F;make&#x2F;bsd&#x2F;makefiles&#x2F;saproc.make 61行：<br>SALIBS &#x3D; -g -framework Foundation -F&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX10.15.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Frameworks -framework JavaNativeFoundation -framework Security -framework CoreFoundation</p><p>105行：<br>-I&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX10.15.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;JavaVM.framework&#x2F;Headers</p><hr><p>执行：make CONF&#x3D;macosx-x86_64-normal-server-release clean<br>make CONF&#x3D;macosx-x86_64-normal-server-release install</p><p>—– Build times ——-<br>Start 2021-07-11 10:50:45<br>End   2021-07-11 10:59:52<br>00:00:16 corba<br>00:00:50 demos<br>00:01:24 docs<br>00:02:10 hotspot<br>00:01:01 images<br>00:00:09 jaxp<br>00:00:14 jaxws<br>00:02:35 jdk<br>00:00:18 langtools<br>00:00:08 nashorn</p><p>00:09:07 TOTAL</p><p>Finished building OpenJDK for target ‘all’</p><p>WARNING: You have the following ALT_ variables set:<br>ALT_PARALLEL_COMPILE_JOBS&#x3D;2<br>ALT_ variables are deprecated and will be ignored. Please clean your environment.</p><p>[1]    90140 bus error  build&#x2F;macosx-x86_64-normal-server-release&#x2F;jdk&#x2F;bin&#x2F;java -version</p><p>&#x2F;Users&#x2F;chenxii&#x2F;Documents&#x2F;Java&#x2F;jdk8&#x2F;openjdk&#x2F;build&#x2F;macosx-x86_64-normal-server-release&#x2F;jdk&#x2F;bin</p><p>？</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023浏览器从A到Z</title>
      <link href="/2023/12/03/21e964fb706d/"/>
      <url>/2023/12/03/21e964fb706d/</url>
      
        <content type="html"><![CDATA[<p>昨天晚上在看一篇关于博客主题的文章的时候，觉得写得很好，就进主页浏览了一下，看到一个有意思的博客标题“2022浏览器从A到Z”，用来浏览器的自动填充网址来回顾过去一年。确实，天晴下雨、寒来暑往，无论是工作还是娱乐，每天打开浏览器逛几个网站是雷打不动的。还没怎么意识到，转眼2023年只剩下不到30天了，想想最后一次做核酸检测都过去一整年了，时间过得很快，我也学着用浏览器从A到Z回顾一下过去的一年。</p><span id="more"></span><p><strong>A</strong></p><p><a href="http://adoptium.net/">http://adoptium.net</a></p><p>在 MacOS 安装 JDK 8的时候发现在 Oracle官网上没有二进制包，个人比较喜欢二进制包安装，不想要了直接删除文件夹就可以，干净纯粹，于是找到了这个网站，不需要注册登陆就可以免费下载各个平台及版本的 OpenJDK 二进制包，墙裂推艰，不得不吐槽一下 Oracle 官网的下载需登陆。</p><p><strong>B</strong></p><p><a href="http://bing.com/">http://bing.com/</a></p><p>必应搜索，从学生时代开始一直在用，除了前两年偶尔有几次页面打不开之外，用得很顺心。搜索主页的每日一图也很赞，每天都能看到世界各地的美丽风景、节假日风俗，前端时间好像是中秋的时候还看到圆月下的甲秀楼。还有一个专门的网站可以看到历史的图片：<a href="https://dailybing.com/">必应每日壁纸</a></p><p><strong>C</strong></p><p><a href="http://cn.bing.com/">http://cn.bing.com</a></p><p>同上。</p><p><strong>D</strong></p><p><a href="http://docs.docker.com/">http://docs.docker.com</a></p><p>docker 文档地址，前几个月重新学习了 docker，把官方文档重新阅读了一遍。从去年年底开始，公司在搞国产化、容器化改造，工作中接触到了 K8S，在学习 K8S 之前重新系统学习了一下 docker。</p><p><strong>E</strong></p><p><a href="http://enread.com/">http://enread.com</a></p><p>英语阅读网，一个还不错的英语阅读网站，已经收藏了六七年的网站，访问次数不超过10次，检讨自己。</p><p><strong>F</strong></p><p><a href="https://fbaff20230901.fyb-aff02.com/">https://fbaff20230901.fyb-aff02.com/</a></p><p>付费机场。</p><p><strong>G</strong></p><p><a href="http://github.com/">http://github.com</a></p><p>GitHub，世界上最大的代码托管平台，已加入404清单。今年的 commit 也少得可怜。</p><p><strong>H</strong></p><p><a href="https://hadoopdoc.com/">https://hadoopdoc.com</a></p><p>大象教程，一个大数据学习网站，Hadoop、Hive、Spark、Flink相关的教程在这里都可以找到。说好今年学习一下 Flink，还没开始。</p><p><strong>I</strong></p><p><a href="https://ionic.io/">https://ionic.io</a></p><p>？啥网站，全英文，看起来像是移动端开发相关的，可能是学习 SwiftUI 的时候无意间点进去的。</p><p><strong>J</strong></p><p>无</p><p><strong>K</strong></p><p>无</p><p><strong>L</strong></p><p>无</p><p><strong>M</strong></p><p>无</p><p><strong>N</strong></p><p><a href="https://www.nhk.or.jp/">https://www.nhk.or.jp</a></p><p>NHK官网，有时候无聊就点进去看看日本新闻，里面按地域、领域划分了很多细分模块，可以看自己关心的部分，很不错。还有一个 <a href="https://www.nhk.or.jp/radionews/">NHK Radio News</a> NHK新闻广播，也是不错的日语听力学习素材。</p><p><strong>O</strong></p><p>无</p><p><strong>P</strong></p><p><a href="https://www.parsevideo.com/">https://www.parsevideo.com</a></p><p>一个 m3u8 格式视频下载工具网站。</p><p><strong>Q</strong></p><p>无</p><p><strong>R</strong></p><p><a href="https://www.runoob.com/">https://www.runoob.com</a></p><p>菜鸟教程，各种各样的编程语言教程仓库，适合新手入门，讲得比较浅显，看看评论区往往有意想不到的收获。</p><p><strong>S</strong></p><p><a href="https://www.spaceship.com/">https://www.spaceship.com</a></p><p>一个国外的域名注册网站，常见的域名后缀价格都还比较便宜，以前用 Godaddy，现在狗叠被墙了，就常用 spaceship 了。</p><p><strong>T</strong></p><p><a href="https://www.typingclub.com/">https://www.typingclub.com</a></p><p>打字俱乐部，一个不错的教打字的网站，开了电脑又无事可干的时候，不如去这里玩一玩。</p><p><strong>U</strong></p><p>无</p><p><strong>V</strong></p><p><a href="http://vm1:8088/">http://vm1:8088</a></p><p>虚拟机上 yarn 集群 web ui 页面，可以查看 yarn 集群节点状态、队列资源分配、资源占用情况、任务状态以及任务日志等信息。</p><p><strong>W</strong></p><p><a href="http://www.bing.com/">http://www.bing.com</a></p><p>又是必应。</p><p><strong>X</strong></p><p><a href="https://xbeibeix.com/api/bilibili/">https://xbeibeix.com/api/bilibili/</a></p><p>一个根据B站视频链接下载B站视频的工具网站。六七月份在B站上看到一个 早見沙織 3rd 专辑《白と花束》的视频，视频中 1st 《Ordinary》这首歌很好听，就通过这个网站下载到本地听了，</p><p><strong>Y</strong></p><p>无</p><p><strong>Z</strong></p><p>无</p>]]></content>
      
      
      <categories>
          
          <category> 日志随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览记录 </tag>
            
            <tag> 年终回顾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack+React项目搭建</title>
      <link href="/2023/11/24/e92bafd74220/"/>
      <url>/2023/11/24/e92bafd74220/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Webpack 是一个使用比较广泛的前端项目打包工具，可以帮我们处理一些诸如 typescript、es6+、Vue、tsx 之类浏览器无法直接支持的问题，将项目打包成各个浏览器都可以直接支持的 js 文件。类似的工具还有 Vite 等。</p></blockquote><span id="more"></span><p>参考资料</p><ul><li><a href="https://juejin.cn/post/7228845572618371133#heading-4">手把手教你搭建 Webpack 5 + React 项目</a></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>entry: 使用哪个模块来作为构建的起始入口。</li><li>output: 最终打包后的文件放在哪里，以及如何命名这些文件。</li><li>loader: 是处理文件的转换器，用于对模块源码进行转换，webpack 只能识别 js、json 文件，像 css 、ts 、jsx等文件都需要通过 loader 进行转换。</li><li>plugin: 是一种可扩展的机制，可以打包过程中添加额外的功能。比如打包优化，资源管理，注入环境变量等。</li><li>mode: 对于不同的环境，我们往往需要不同的配置，通过设置 mode 参数来选择环境。</li></ul><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>略过 node.js 安装之类的前置步骤。</p><pre><code class="sh">// 创建项目文件夹mkdir start-react// 初始化npm init</code></pre><h2 id="typescript及React配置"><a href="#typescript及React配置" class="headerlink" title="typescript及React配置"></a>typescript及React配置</h2><p>引入 typescript及React</p><pre><code class="sh">// reactnpm add -D react react-domnpm add -D @types/react @types/react-dom// typescriptnpm add -D typescript// 初始化 typesript 配置，生成 tsconfig.js 文件tsc --init</code></pre><p>tsconfig.js 文件配置：</p><pre><code class="js">&#123;  &quot;compilerOptions&quot;: &#123;    /* Visit https://aka.ms/tsconfig.json to read more about this file */    /* Basic Options */    // &quot;incremental&quot;: true,                   /* Enable incremental compilation */    &quot;target&quot;: &quot;ESNEXT&quot;,                          /* Specify ECMAScript target version: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;, &#39;ES2018&#39;, &#39;ES2019&#39;, &#39;ES2020&#39;, or &#39;ESNEXT&#39;. */    &quot;module&quot;: &quot;ESNext&quot;,                     /* Specify module code generation: &#39;none&#39;, &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39;, &#39;es2015&#39;, &#39;es2020&#39;, or &#39;ESNext&#39;. */    // &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */    // &quot;allowJs&quot;: true,                       /* Allow javascript files to be compiled. */    // &quot;checkJs&quot;: true,                       /* Report errors in .js files. */    &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: &#39;preserve&#39;, &#39;react-native&#39;, or &#39;react&#39;. */    // &quot;declaration&quot;: true,                   /* Generates corresponding &#39;.d.ts&#39; file. */    // &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding &#39;.d.ts&#39; file. */    &quot;sourceMap&quot;: true,                     /* Generates corresponding &#39;.map&#39; file. */    // &quot;outFile&quot;: &quot;./&quot;,                       /* Concatenate and emit output to single file. */    // &quot;outDir&quot;: &quot;./&quot;,                        /* Redirect output structure to the directory. */    &quot;rootDir&quot;: &quot;./src&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */    // &quot;composite&quot;: true,                     /* Enable project compilation */    // &quot;tsBuildInfoFile&quot;: &quot;./&quot;,               /* Specify file to store incremental compilation information */    // &quot;removeComments&quot;: true,                /* Do not emit comments to output. */    &quot;noEmit&quot;: true,                        /* Do not emit outputs. */    &quot;importHelpers&quot;: true,                 /* Import emit helpers from &#39;tslib&#39;. */    // &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in &#39;for-of&#39;, spread, and destructuring when targeting &#39;ES5&#39; or &#39;ES3&#39;. */    // &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to &#39;ts.transpileModule&#39;). */    /* Strict Type-Checking Options */    &quot;strict&quot;: true,                           /* Enable all strict type-checking options. */    // &quot;noImplicitAny&quot;: true,                 /* Raise error on expressions and declarations with an implied &#39;any&#39; type. */    // &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */    // &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */    // &quot;strictBindCallApply&quot;: true,           /* Enable strict &#39;bind&#39;, &#39;call&#39;, and &#39;apply&#39; methods on functions. */    // &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */    // &quot;noImplicitThis&quot;: true,                /* Raise error on &#39;this&#39; expressions with an implied &#39;any&#39; type. */    // &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */    /* Additional Checks */    &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */    &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */    &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */    &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */    /* Module Resolution Options */    &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: &#39;node&#39; (Node.js) or &#39;classic&#39; (TypeScript pre-1.6). */    &quot;baseUrl&quot;: &quot;./&quot;,                       /* Base directory to resolve non-absolute module names. */    &quot;paths&quot;: &#123;      &quot;common/*&quot;: [        &quot;src/common/*&quot;      ],      &quot;@/*&quot;: [        &quot;src/*&quot;      ]    &#125;,                           /* A series of entries which re-map imports to lookup locations relative to the &#39;baseUrl&#39;. */    // &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */    // &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */    // &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */    // &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */    &quot;esModuleInterop&quot;: true,                  /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#39;allowSyntheticDefaultImports&#39;. */    // &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */    // &quot;allowUmdGlobalAccess&quot;: true,          /* Allow accessing UMD globals from modules. */    /* Source Map Options */    // &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */    // &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */    // &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */    // &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires &#39;--inlineSourceMap&#39; or &#39;--sourceMap&#39; to be set. */    /* Experimental Options */    // &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */    // &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */    /* Advanced Options */    &quot;skipLibCheck&quot;: true,                     /* Skip type checking of declaration files. */    &quot;forceConsistentCasingInFileNames&quot;: true  /* Disallow inconsistently-cased references to the same file. */  &#125;,  &quot;include&quot;: [&quot;src&quot;]&#125;</code></pre><p>创建 src 目录，在该目录下创建文件 App.tsx 及 index.tsx，文件内容如下：</p><pre><code class="react">// App.tsximport * as React from &#39;react&#39;const App: React.FC = () =&gt; &#123;    return (        &lt;div&gt;            &lt;h1&gt;Hello lozhu!&lt;/h1&gt;        &lt;/div&gt;    )&#125;export default App</code></pre><pre><code class="react">import * as React from &#39;react&#39;import * as ReactDOM from &#39;react-dom/client&#39;import App from &#39;./App&#39;const root = ReactDOM.createRoot(document.getElementById(&#39;app&#39;)!)root.render(&lt;App /&gt;)</code></pre><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><h3 id="引入-webpack"><a href="#引入-webpack" class="headerlink" title="引入 webpack"></a>引入 webpack</h3><pre><code class="sh">npm add -D webpack webpack-cli webpack-dev-server webpack-merge</code></pre><h3 id="开发、生产环境配置"><a href="#开发、生产环境配置" class="headerlink" title="开发、生产环境配置"></a>开发、生产环境配置</h3><p>引入 cross-env</p><pre><code class="sh">npm add -D cross-env</code></pre><p>创建 scripts 文件夹及 webpack.base.js、webpack.dev.js、webpack.prod.js 文件</p><pre><code class="js">// webpack.base.jsconst path = require(&#39;path&#39;)module.exports = &#123;    entry: path.resolve(__dirname, &#39;../src/index.tsx&#39;),    output: &#123;        path: path.resolve(__dirname, &#39;../dist&#39;),  // 打包后的文件存放地址        filename: &#39;[name].[hash:8].js&#39;  // 打包的文件名    &#125;&#125;</code></pre><pre><code class="js">// webpack.dev.jsconst &#123; merge &#125; = require(&#39;webpack-merge&#39;)const base = require(&#39;./webpack.base.js&#39;)module.exports = merge(base, &#123;    mode: &#39;development&#39;,    devServer: &#123;        open: true,  // 编译完自动打开浏览器        port: 8080    &#125;&#125;)</code></pre><pre><code class="js">// webpack.prod.jsconst &#123; merge &#125; = require(&#39;webpack-merge&#39;)const base = require(&#39;./webpack.base.js&#39;)module.exports = merge(base, &#123;    mode: &#39;production&#39;  // 生产模式&#125;)</code></pre><h3 id="修改启动脚本"><a href="#修改启动脚本" class="headerlink" title="修改启动脚本"></a>修改启动脚本</h3><p>修改 package.json</p><pre><code class="json">&#123;  &quot;name&quot;: &quot;start-react&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;no description&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    // 启动开发环境    &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack serve -c scripts/webpack.dev.js&quot;,    // 生产打包    &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack -c scripts/webpack.prod.js&quot;  &#125;,  ...&#125; </code></pre><h3 id="Babel配置"><a href="#Babel配置" class="headerlink" title="Babel配置"></a>Babel配置</h3><p>Babel 是一个 JavaScript 编译器。主要用于将高版本的JavaScript代码转为向后兼容的JS代码，从而能让我们的代码运行在更低版本的浏览器或者其他的环境中。</p><p>由于 webpack 只能识别js、json 文件， 无法识别 jsx&#x2F;tsx 文件，此时如果我们尝试启动项目肯定会报错。如何让 webpack 能识别呢？此时我们就需要使用<code>babel-loader</code> 来转换代码，babel-loader 可以让 webpack 在构建的时候借助 Babel 对JS代码进行转译。</p><p>引入依赖</p><pre><code class="sh">npm add -D babel-loader @babel/core @babel/preset-env @babel/preset-react @babel/preset-typescript</code></pre><p>修改 webpack.base.js 配置</p><pre><code class="js">const path = require(&#39;path&#39;)module.exports = &#123;    entry: path.resolve(__dirname, &#39;../src/index.tsx&#39;),    output: &#123;        path: path.resolve(__dirname, &#39;../dist&#39;),  // 打包后的文件存放地址        filename: &#39;[name].[hash:8].js&#39;  // 打包的文件名    &#125;,    resolve: &#123;        extensions: [&#39;.ts&#39;, &#39;.tsx&#39;, &#39;.mjs&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.jsx&#39;],        alias: &#123;            &#39;@&#39;: path.resolve(__dirname, &#39;../&#39;)        &#125;    &#125;,    module: &#123;        rules: [            &#123;                test: /.(jsx?)|(tsx?)$/,                use: &#123;                    loader: &#39;babel-loader&#39;,                    options: &#123;                        presets: [                            [&#39;@babel/preset-env&#39;],                            [&#39;@babel/preset-typescript&#39;],                            [&#39;@babel/preset-react&#39;]                        ]                    &#125;                &#125;            &#125;        ]    &#125;&#125;</code></pre><p>运行打包命令</p><pre><code class="sh">npm run build</code></pre><p>打包完成后，会生成 dist 目录，但是还需要 index.html 文件才能访问。</p><h3 id="HtmlWebpackPlugin配置"><a href="#HtmlWebpackPlugin配置" class="headerlink" title="HtmlWebpackPlugin配置"></a>HtmlWebpackPlugin配置</h3><p>可以使用 HtmlWebpackPlugin 在每次打包时自动生成 index.html 入口文件。</p><pre><code class="sh">npm add -D html-webpack-plugin</code></pre><p>修改 webpack.base.js 文件内容</p><pre><code class="js">const path = require(&#39;path&#39;)const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)module.exports = &#123;    entry: path.resolve(__dirname, &#39;../src/index.tsx&#39;),    output: &#123;        path: path.resolve(__dirname, &#39;../dist&#39;),  // 打包后的文件存放地址        filename: &#39;[name].[hash:8].js&#39;  // 打包的文件名    &#125;,    resolve: &#123;        extensions: [&#39;.ts&#39;, &#39;.tsx&#39;, &#39;.mjs&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.jsx&#39;],        alias: &#123;            &#39;@&#39;: path.resolve(__dirname, &#39;../&#39;)        &#125;    &#125;,    module: &#123;        rules: [            &#123;                test: /.(jsx?)|(tsx?)$/,                use: &#123;                    loader: &#39;babel-loader&#39;,                    options: &#123;                        presets: [                            [&#39;@babel/preset-env&#39;],                            [&#39;@babel/preset-typescript&#39;],                            [&#39;@babel/preset-react&#39;]                        ]                    &#125;                &#125;            &#125;        ]    &#125;,    plugins: [        new HtmlWebpackPlugin(&#123;            template: path.resolve(__dirname, &#39;../src/index.html&#39;)  // 使用自定义模板        &#125;)    ]&#125;</code></pre><p>在 src 目录下创建 index.html 文件</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;hello webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>再次运行打包命令后，dist 目录下产生了 index.html 文件，浏览器打开就能看到 App.tsx 中定义的内容。</p><h2 id="各种loader配置"><a href="#各种loader配置" class="headerlink" title="各种loader配置"></a>各种loader配置</h2><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><p>引入依赖 url-loader 及 file-loader</p><pre><code class="sh">npm add -D file-loader url-loader</code></pre><p>在根目录下创建图片文件夹 assets&#x2F;images，引入图片 img1.jpg 和 img2.jpg</p><p>在 App.tsx 中引入图片</p><pre><code class="tsx">import * as React from &#39;react&#39;import img1 from &#39;../assets/images/img1.jpg&#39;const App: React.FC = () =&gt; &#123;    return (        &lt;div&gt;            &lt;h1&gt;Hello lozhu!&lt;/h1&gt;            &lt;div&gt;                &lt;img src=&#123;img1&#125; /&gt;            &lt;/div&gt;        &lt;/div&gt;    )&#125;export default App</code></pre><p>修改 webpack.base.js 配置</p><pre><code class="js">const path = require(&#39;path&#39;)const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)module.exports = &#123;    entry: path.resolve(__dirname, &#39;../src/index.tsx&#39;),    output: &#123;        path: path.resolve(__dirname, &#39;../dist&#39;),  // 打包后的文件存放地址        filename: &#39;[name].[hash:8].js&#39;  // 打包的文件名    &#125;,    resolve: &#123;        extensions: [&#39;.ts&#39;, &#39;.tsx&#39;, &#39;.mjs&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.jsx&#39;],        alias: &#123;            &#39;@&#39;: path.resolve(__dirname, &#39;../&#39;)        &#125;    &#125;,    module: &#123;        rules: [            &#123;                test: /.(jsx?)|(tsx?)$/,                use: &#123;                    loader: &#39;babel-loader&#39;,                    options: &#123;                        presets: [                            [&#39;@babel/preset-env&#39;],                            [&#39;@babel/preset-typescript&#39;],                            [&#39;@babel/preset-react&#39;]                        ]                    &#125;                &#125;            &#125;,            &#123;                test: /\.(jpg|png)$/,                use: [                    &#123;                        loader: &#39;url-loader&#39;,                        options: &#123;                            limit: 2000                        &#125;                    &#125;                ]            &#125;        ]    &#125;,    plugins: [        new HtmlWebpackPlugin(&#123;            template: path.resolve(__dirname, &#39;../src/index.html&#39;)  // 使用自定义模板        &#125;)    ]&#125;</code></pre><p>重新打包即可看到图片加载出来了:eyes:</p><h3 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h3><p>css-loader 只能帮我们将 css 解析成 js，但不能挂载到元素上。style-loader 可以帮我们实现将样式挂载到元素上，它负责将 css 样式通过 style 标签插入到 DOM 中。通过 style-loader 实现样式挂载，自动添加 style 标签到 head 中。</p><p>使用 postcss 处理 css</p><pre><code class="sh">npm add -D style-loader css-loader postcss postcss-loader postcss-preset-env</code></pre><p>新建 src&#x2F;assets&#x2F;style&#x2F;mystyle.css 样式文件</p><pre><code class="css">// mystyle.css/* 标准图片样式 */.standard-img &#123;    width: 100px;    height: 60px;    border-radius: 8px;&#125;</code></pre><p>修改 App.tsx 文件引入 css</p><pre><code class="tsx">import * as React from &#39;react&#39;import img1 from &#39;./src/assets/images/img1.jpg&#39;import &#39;./assets/style/mystyle.css&#39;const App: React.FC = () =&gt; &#123;    return (        &lt;div&gt;            &lt;h1&gt;Hello lozhu!&lt;/h1&gt;            &lt;div&gt;                &lt;img src=&#123;img1&#125; className=&quot;standard-img&quot; /&gt;            &lt;/div&gt;        &lt;/div&gt;    )&#125;export default App</code></pre><p>修改 webpack.base.js 文件</p><pre><code class="js">const path = require(&#39;path&#39;)const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)module.exports = &#123;    entry: path.resolve(__dirname, &#39;../src/index.tsx&#39;),    output: &#123;        path: path.resolve(__dirname, &#39;../dist&#39;),  // 打包后的文件存放地址        filename: &#39;[name].[hash:8].js&#39;  // 打包的文件名    &#125;,    resolve: &#123;        extensions: [&#39;.ts&#39;, &#39;.tsx&#39;, &#39;.mjs&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.jsx&#39;],        alias: &#123;            &#39;@&#39;: path.resolve(__dirname, &#39;../&#39;)        &#125;    &#125;,    module: &#123;        rules: [            &#123;                test: /.(jsx?)|(tsx?)$/,                use: &#123;                    loader: &#39;babel-loader&#39;,                    options: &#123;                        presets: [                            [&#39;@babel/preset-env&#39;],                            [&#39;@babel/preset-typescript&#39;],                            [&#39;@babel/preset-react&#39;]                        ]                    &#125;                &#125;            &#125;,            &#123;                test: /\.(jpg|png)$/,                use: [                    &#123;                        loader: &#39;url-loader&#39;,                        options: &#123;                            limit: 2000                        &#125;                    &#125;                ]            &#125;,            &#123;                test: /\.css$/,                use: [                    &#39;style-loader&#39;,                    &#39;css-loader&#39;,                    &#123;                        loader: &#39;postcss-loader&#39;,                        options: &#123;                            postcssOptions: &#123;                                plugins: [[&#39;postcss-preset-env&#39;, &#123;&#125;]]                            &#125;                        &#125;                    &#125;                ]            &#125;        ]    &#125;,    plugins: [        new HtmlWebpackPlugin(&#123;            template: path.resolve(__dirname, &#39;../src/index.html&#39;)  // 使用自定义模板        &#125;)    ]&#125;</code></pre><p>重新打包之后可以看到图片的大小变为想要的样式了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memos数据迁移</title>
      <link href="/2023/11/12/8c7a85ccc982/"/>
      <url>/2023/11/12/8c7a85ccc982/</url>
      
        <content type="html"><![CDATA[<p>去年年底时腾讯云轻量应用服务器做活动，2C2G配置13个月才80块钱不到，就将Memos部署在腾讯云上。公网IP随时随地都可以访问，但是服务器续费太贵，不准备续费，需要将数据迁移到本地。找了一圈，没找到现成的迁移工具。</p><p>因为数据存储方式选择的是sqlite，所以想着直接将服务器上的memos_prod.db数据库文件和assets文件夹拷贝到本地，再docker中运行memos镜像时挂载这个目录就可以，但是不知道什么原因，挂上之后数据不完整，比如用户信息是可以在页面展示的，而memo以及resource在页面加载时直接出现红色报错信息。</p><p>于是改了方案，先在本地将memos跑起来，再将数据用SQL复制到表中。这样做的缺点就是费时费力，并且有点坑的是，两次docker镜像的版本还不一致，表结构有变更，导致写SQL的时候还要对字段。</p><span id="more"></span><p>操作步骤：</p><ol><li><p>从服务器上将挂载目录中的文件 memos_prod_db 和 assets 目录拷贝至本地存档</p></li><li><p>本地先将memos跑起来，确保能正常发布：</p><pre><code class="sh"># 创建 volumedocker volume create memosdata# 拉取镜像docker pull neosmemo/memos:latest# 运行镜像docker run -d --name memos -p 5230:5230 -v memosdata:/var/opt/memos neosmemo/memos:latest</code></pre></li><li><p>安装sqlite：</p><pre><code class="sh">sudo apt install sqlite3</code></pre></li><li><p>打开两个数据库并拷贝数据：</p><pre><code class="sh"># 查看 memosdata 位置docker volume inspect memosdata# 打开 sqlite3sqlite3.open memosdata/memos_prod.db.open bak/memos_prod.db as db1# 查看表select * from sqlite_master where type = &#39;table&#39;;# 查看表结构PRAGMA table_info(memo);# 拷贝数据，主要有 memo, resource, tag， 其中 memo 表和 tag 表直接拷贝insert into memoselect * from db1.memo where 1 = 1;insert into tagselect * from db1.tag where 1 = 1;# resource 表原本 10 个字段，更新后多了一个字段，拷贝 SQL 需要做一下表连接insert into resourceselect a.id,       a.creator_id,       a.created_ts,       a.updated_ts,       a.filename,       a.blob,       a.external_link,       a.type,       a.size,       a.internal_path,       b.memo_id  -- 多出来的字段from db1.resource as a    left join db1.memo_resource b        on a.id = b.resource_idwhere 1 = 1;</code></pre><p> 现在刷新页面，应该是 memos 的文字正常展示。</p></li><li><p>最后，将 assets 目录一整个拷贝至 memosdata 目录下，再刷新页面验证即可。</p></li><li><p>其他的表没做处理，目前看起来应该是没用到。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Memos </tag>
            
            <tag> 数据迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oh-my-zsh国内配置</title>
      <link href="/2023/11/12/b362c85f73a8/"/>
      <url>/2023/11/12/b362c85f73a8/</url>
      
        <content type="html"><![CDATA[<p>因为在国内网络环境的原因，github经常无法访问，并且速度很慢。有大佬已经仓库同步到gitee上，用gitee速度会快很多。</p><p>gitee仓库地址：<a href="https://gitee.com/unrogue007/zsh-syntax-highlighting.git">https://gitee.com/unrogue007/zsh-syntax-highlighting.git</a></p><span id="more"></span><h2 id="安装zsh和oh-my-zsh"><a href="#安装zsh和oh-my-zsh" class="headerlink" title="安装zsh和oh-my-zsh"></a>安装zsh和oh-my-zsh</h2><p>需要先确保 git 已经安装，安装过程中需要使用 git 。</p><p>Macos默认已经安装zsh，但是Linux默认还是bash。</p><p>查看当前shell：</p><pre><code class="sh">echo $SHELL</code></pre><p>安装zsh：</p><pre><code class="sh">sudo apt install zsh</code></pre><p>切换zsh：</p><pre><code class="sh">chsh -s /bin/zsh</code></pre><p>也可以先不切换，安装oh-my-zsh之后会提示是否切换默认shell为zsh。</p><p>安装oh-my-zsh：</p><pre><code class="sh">wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh</code></pre><p>下载完之后给脚本添加执行权限：</p><pre><code class="sh">chomd +x install.sh</code></pre><p>脚本中默认的安装地址是GitHub仓库，先修改为gitee：</p><p>找到如下：</p><pre><code class="sh"># Default settingsREPO=REMOTE=</code></pre><p>将这两行替换为gitee仓库地址：</p><pre><code class="sh"># Default settingsREPO=$&#123;REPO:-mirrors/oh-my-zsh&#125;REMOTE=$&#123;REMOTE:-https://gitee.com/$&#123;REPO&#125;.git&#125;</code></pre><p>执行安装：</p><pre><code class="sh">./install.sh</code></pre><p>安装之后出现彩色的oh-my-zsh banner表示安装成功。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改 ~&#x2F;.zshrc 配置文件：</p><pre><code class="sh"># 主题配置，个人喜欢设置为随机主题ZSH_THEME=&quot;random&quot;</code></pre><p>修改保存并重新加载配置即可在终端输出里看到主题加载的提示信息：</p><pre><code class="sh">source ~/.zshrc</code></pre><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h4><p>历史命令提示插件，可以提高很多效率，尤其是长命令。clone 插件：</p><pre><code class="sh">git clone https://gitee.com/unrogue007/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></pre><h4 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h4><p>高亮插件，clone 命令：</p><pre><code class="sh">git clone https://gitee.com/unrogue007/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></pre><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>插件 clone 完之后修改配置 ~&#x2F;.zshrc ，找到 plugins&#x3D;(git) 配置，修改为：</p><pre><code class="sh">plugins=(git zsh-syntax-highlighting zsh-autosuggestions)</code></pre><p>重新加载配置：</p><pre><code class="sh">source ~/.zshrc</code></pre><p>配置完毕。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7023578642156355592">oh-my-zsh 国内安装及配置</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oh my zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何确定线程池大小</title>
      <link href="/2023/09/29/afc9322c79df/"/>
      <url>/2023/09/29/afc9322c79df/</url>
      
        <content type="html"><![CDATA[<p>硬件资源、资源预算、任务类型都会影响线程池的理想大小。应用程序运行的环境会改变（机器扩容、缩容，资源使用率调整，其他可利用资源调整等），最好<strong>不要在代码中固定线程池的大小</strong>，而是动态的根据当前应用运行的环境进行调整。</p><p>过大或者过小的线程池都会导致系统吞吐率降低。线程池大小设置过大，大量的线程将竞争有限的 CPU 资源，导致性能下降；如果线程池设置过小，会有许多 CPU 空闲无法参与执行任务，从而导致吞吐率降低。</p><span id="more"></span><p>任务类型也影响线程池大小的设置。如果是计算密集型任务，将线程池大小设置为 CPU 个数 + 1 时，可以获得最优的利用率；多余的 1 个线程可以确保因为其他故障而阻塞的线程的时钟周期不被浪费。</p><p>获取当前环境的 CPU 个数：</p><pre><code class="java">int cpuCount = Runtime.getRuntime().availableProcessors();</code></pre><p>《Java 并发编程实战》中给出的线程池大小计算方法：</p><p><strong>N(线程数) &#x3D; N(cpu个数) * U(cpu利用率) * (1 + 任务等待时间&#x2F;任务执行)</strong></p><p>除了 CPU 个数、任务类型之外，比如任务所依赖的数据库连接池大小、系统内存大小等因素也会制约线程池的大小，需要不断的尝试观察，才能得到一个相对理想的线程池大小。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原码and反码and补码</title>
      <link href="/2023/09/20/934f874691f1/"/>
      <url>/2023/09/20/934f874691f1/</url>
      
        <content type="html"><![CDATA[<h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><h3 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h3><p>原码的首位表示其符号位，整数为0，负数为1，因此表示数据的有效为 7 位，两个字节最多能表示的数据范围是：-128~128。</p><p>正数的原码是其本身。假如整数占用两个字节，5 的二进制表示为：<code>0000 0101</code>，其原码为：<code>0000 0101</code>。</p><p>0000 0000 和 1000 0000 分别表示 +0 和 -0。</p><p>负数的原码首位为1，其余位为其原本的二进制表示。-3 的原码 <code>1000 0011</code>。</p><span id="more"></span><h3 id="原码计算"><a href="#原码计算" class="headerlink" title="原码计算"></a>原码计算</h3><p>如果基于原码进行计算会是什么结果呢？</p><p>正数的情况：5 + 3</p><pre><code>5 + 3  0000 0101+ 0000 0011= 0000 1000 (8)</code></pre><p>正数的情况下结果正确。</p><p>加上负数的情况：5 - 3 &#x3D; 5 + (-3)</p><pre><code>5 + (-3)  0000 0101+ 1000 0011= 1000 1000 (-8)</code></pre><p>5 - 3 &#x3D; -8，结果错误，原码不能对负数直接进行计算。</p><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>正数的反码是其本身。5 的反码 &#x3D; 0000 0101。</p><p>负数的反码符号位不变，其余位取反。-3 的反码 &#x3D; 1111 1100。</p><p>0000 0000 和 1000 0000 分别表示 +0 和 -0。</p><p>负数 t 的反码 &#x3D; 1111 1111 - t（符号位不变）。</p><p>使用反码进行计算：</p><p>正数的情况显然结果与原码一致，结果正确。</p><p>负数的情况：5 - 3</p><pre><code>5 - 3 = 5 + (-3)  0000 0101+ 1111 1100= 0000 0001 (1)</code></pre><pre><code>10 - 5  0000 1010+ 1111 1010= 0000 0100 (4)    </code></pre><p>负数的场景结果与正确结果差1。</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>正数的补码是其本身。5 的补码 &#x3D; 0000 0101</p><p>负数的补码是其反码 +1。-3 的补码 &#x3D; 1111 1101</p><p>使用补码进行运算，正数的场景与之前一致，结果正确。</p><pre><code>5 - 3 = 5 + (-3)  0000 0101+ 1111 1101= 0000 0010 (2)</code></pre><pre><code>10 - 5  0000 1010+ 1111 1011= 0000 0101 (5) </code></pre><p>使用补码时刚好多减去反码计算中的差值1，所以结果是正确的。</p><h2 id="负数的补码等于反码-1-的解释"><a href="#负数的补码等于反码-1-的解释" class="headerlink" title="负数的补码等于反码 +1 的解释"></a>负数的补码等于反码 +1 的解释</h2><p>看网上的解释都是从时间的计算考虑。时钟每12个小时循环一次，假设当前时间为9点，要将时针调到1点，可以将时间“往前”增加 4 个小时，也可以将时间“往后”拨 8 个小时。即：</p><pre><code>9 + 4 = 9 - 8</code></pre><p>意思就是说在这个运算中 -8 的运算等价于 +4，每一个负数都可以找到一个对应的正数，使计算结果不变。</p><pre><code>10 - 5 = 10 + 710 - 6 = 10 + 6</code></pre><p>这两个等价数的绝对值和等于 12。</p><p>考虑更普遍的场景，假设当前时间为 a 点，将时间往回调 t 小时，等价于将时间往前拨 12 - t 小时：</p><pre><code>a - t = a + 12 - t</code></pre><p>以公式a - b &#x3D; a + mod - b 为例，</p><p>设: -b &#x3D; 10000101 (-5的二进制)，</p><p>模(mod) &#x3D; 11111111</p><p>a - b &#x3D; a + (-b的补数) &#x3D; a + (mod - b) &#x3D; a + (11111111 - 10000101)</p><p>由于二进制的特性，11111111减去10000101得到补数11111010，实际就等于 10000101 各位取反——也就是反码，如下对应关系：</p><p>11111111 #模(mod)</p><p>10000101 # -5二进制</p><p>11111010 #-5二进制补数（即反码）</p><p>（这里要注意第一位符号位是不变的）</p><p>但是在实际计算中补数（反码）还必须加1——即：</p><p>11111010 +1（00000001）&#x3D; 11111011</p><p>这是因为在8位二进制系统中，模&#x3D;2^8&#x3D;256，表示为二进制是100000000，是九位二进制数，在8位二进制系统中实际产生溢出位无法计算，而8位二进制系统计量范围是0<del>2^n-1，也就是0</del>257，最大值是257，也就是我们上面计算中模的取值二进制11111111，也就是说为了便于计算，我们是用257的二进制11111111，代替了模256的实际值100000000，那么在实际计算中取得补数后，必须加上这个差值1才不会出错，即：</p><p>补数（反码）+1&#x3D;补码</p><p>这就是为什么补码加1的原因。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原码 </tag>
            
            <tag> 反码 </tag>
            
            <tag> 补骂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift中的可选类型</title>
      <link href="/2023/09/14/a3e4269ebef9/"/>
      <url>/2023/09/14/a3e4269ebef9/</url>
      
        <content type="html"><![CDATA[<h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>在 swift 中可以使用 <strong>可选类型</strong>（Optional）来处理值不存在的情况，变量存在值时可以对其进行解析。</p><span id="more"></span><p>比如对数字进行类型转换：</p><pre><code class="swift">var numberStr = &quot;10&quot;// value 类型推断为 Int?// 相当于 var value: Int? = Int(numberStr)var value = Int(numberStr)</code></pre><p>当 numberStr 可以转换时，value 包含 Int 类型的值；当 numberStr 无法转换时，value 不包含值。</p><p>Int? 可以被赋值 nil，但是不能用于非可选的变量赋值，如果程序中变量或常量可能包含空值时，需要声明为对应类型的可选类型。</p><pre><code class="swift">var statusCode: Int? = 400// 可选类型可以赋值为 nilstatusCode = nil</code></pre><p>可以使用 if 和 ! 来处理可选类型：</p><pre><code class="swift">var number: String = &quot;10&quot;var value: Int? = Int(number)if value != nil &#123;    print(&quot;value is \(value!)&quot;)&#125; else &#123;    print(&quot;value is nil&quot;)&#125;</code></pre><p>如果确定可选类型变量存在值，则可以使用 ! 解析可选类型的值，注意：使用 ! 解析一个不存在的值会报错。</p><h2 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h2><p>还可以使用 <strong>可选绑定</strong>（Optional binding）来判断可选类型是否包含值，如果存在值则将值赋值给一个变量。</p><pre><code class="swift">var age: Int = 10var gift: String?if age &lt;= 10 &#123;    gift = &quot;糖果🍬&quot;&#125;if let myGift = gift &#123;    print(&quot;myGift is \(myGift)&quot;)&#125; else &#123;    print(&quot;myGift is nil&quot;)&#125;</code></pre><h2 id="隐式解析可选类型"><a href="#隐式解析可选类型" class="headerlink" title="隐式解析可选类型"></a>隐式解析可选类型</h2><p>如果可以确定一个变量一定存在值，则可以将变量声明为隐式解析可选类型，避免每次取值时的判断。</p><pre><code class="swift">let message1: String? = &quot;message content 1&quot;// 需要 ! 解析let messageContent1: String = message1!print(&quot;message content 1: \(messageContent1)&quot;)let message2: String! = &quot;message content 2&quot;// 不需要 ! 解析let messageContent2: String = message2print(&quot;message content 2: \(messageContent2)&quot;)</code></pre><p>但是如果隐式解析可选类型不存在值，也会和使用普通可选类型一样报错。可以把隐式解析可选类型当做一个可以自动解析的可选类型。</p><p>⚠️ 如果一个变量之后可能变成 <code>nil</code> 的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是 <code>nil</code> 的话，请使用普通可选类型。</p><h2 id="空合运算符"><a href="#空合运算符" class="headerlink" title="空合运算符"></a>空合运算符</h2><p>空合运算符 ?? 先对一个可选类型进行判断 <code>result != nil</code>，如果 result 的值不为 nil，则对可选类型 result 进行取值返回 result!，否则返回默认值，默认值与可选类型包含的值必须是同一类型。</p><pre><code class="swift">let defaultNum = 10let randomNum: Int?// 等价于 randomNum != nil ? randomNum! : defaultNumlet result = randomNum ?? defaultNum</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 可选类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Debian12上安装Kubernetes</title>
      <link href="/2023/09/02/2208f957f610/"/>
      <url>/2023/09/02/2208f957f610/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes-概述"><a href="#Kubernetes-概述" class="headerlink" title="Kubernetes 概述"></a>Kubernetes 概述</h2><p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。<strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。</p><span id="more"></span><h3 id="容器化部署的优势"><a href="#容器化部署的优势" class="headerlink" title="容器化部署的优势"></a>容器化部署的优势</h3><p>应用程序经历了 传统部署 &gt; 虚拟化部署 &gt; 容器部署。容器化部署的优势：</p><ul><li>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li><li>持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性）， 提供可靠且频繁的容器镜像构建和部署。</li><li>关注开发与运维的分离：在构建、发布时创建应用程序容器镜像，而不是在部署时， 从而将应用程序与基础架构分离。</li><li>可观察性：不仅可以显示 OS 级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li><li>跨开发、测试和生产的环境一致性：在笔记本计算机上也可以和在云中运行一样的应用程序。</li><li>跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。</li><li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li><li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</li><li>资源隔离：可预测的应用程序性能。</li><li>资源利用：高效率和高密度。</li></ul><p>容器是打包和运行应用程序的好方式。在生产环境中， 你需要管理运行着应用程序的容器，并确保服务不会下线。 例如，如果一个容器发生故障，则你需要启动另一个容器。 如果此行为交由给系统处理，是不是会更容易一些？这就是 Kubernetes 要来做的事情！Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移你的应用、提供部署模式等。</p><h3 id="Kubernetes-能做什么"><a href="#Kubernetes-能做什么" class="headerlink" title="Kubernetes 能做什么"></a>Kubernetes 能做什么</h3><p>Kubernetes 为你提供：</p><ul><li><p><strong>服务发现和负载均衡</strong></p><p>  Kubernetes 可以使用 DNS 名称或自己的 IP 地址来暴露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p><strong>存储编排</strong></p><p>  Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</p></li><li><p><strong>自动部署和回滚</strong></p><p>  你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p></li><li><p><strong>自动完成装箱计算</strong></p><p>  你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。</p></li><li><p><strong>自我修复</strong></p><p>  Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。</p></li><li><p><strong>密钥与配置管理</strong></p><p>  Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p></li></ul><h3 id="Kubernetes-不做什么"><a href="#Kubernetes-不做什么" class="headerlink" title="Kubernetes 不做什么"></a>Kubernetes 不做什么</h3><p>Kubernetes：</p><ul><li><strong>不限制支持的应用程序类型。</strong> Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。</li><li><strong>不部署源代码，也不构建你的应用程序。</strong> 持续集成（CI）、交付和部署（CI&#x2F;CD）工作流取决于组织的文化和偏好以及技术要求。</li><li><strong>不提供应用程序级别的服务作为内置服务，</strong>例如中间件（例如消息中间件）、 数据处理框架（例如 Spark）、数据库（例如 MySQL）、缓存、集群存储系统 （例如 Ceph）。这样的组件可以在 Kubernetes 上运行，并且&#x2F;或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如<a href="https://openservicebrokerapi.org/">开放服务代理</a>）来访问。</li><li>**不是日志记录、监视或警报的解决方案。 **它集成了一些功能作为概念证明，并提供了收集和导出指标的机制。</li><li>不提供也不要求配置用的语言、系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。</li><li><strong>不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。</strong></li><li>此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 而 Kubernetes 包含了一组独立可组合的控制过程，可以持续地将当前状态驱动到所提供的预期状态。 你不需要在乎如何从 A 移动到 C，也不需要集中控制，这使得系统更易于使用且功能更强大、 系统更健壮，更为弹性和可扩展。</li></ul><p><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/">Kubernetes 概述</a></p><h2 id="Kubernetes-安装"><a href="#Kubernetes-安装" class="headerlink" title="Kubernetes 安装"></a>Kubernetes 安装</h2><h3 id="关闭-Debian-交换分区"><a href="#关闭-Debian-交换分区" class="headerlink" title="关闭 Debian 交换分区"></a>关闭 Debian 交换分区</h3><p>先准备3台虚拟机，关闭交换分区（一个是性能问题，开启swap会严重影响性能（包括内存和I&#x2F;O）；另一个是管理问题，开启swap后通过cgroups设置的内存上限就会失效。有的时候可用内存很多也会swap，这时候关闭是为了避免swap带来的性能问题）。</p><ol><li>编辑 &#x2F;etc&#x2F;fstab 文件，注释掉 swap 分区</li><li>修改 systemd 相关配置</li></ol><pre><code class="sh"># 查看与 swap 分区相关的 systemd 项sudo systemctl --type swap --all# 关闭相关项，保证重启之后 swap 分区不会被重新挂载sudo systemctl mask dev-xxx.swap</code></pre><p>参考：<a href="https://blog.csdn.net/Elko_265/article/details/126342412">Debian 11 关闭 swap 遇到的问题和解决方案 - CSDN</a></p><h3 id="修改-etc-daemon-json"><a href="#修改-etc-daemon-json" class="headerlink" title="修改 &#x2F;etc&#x2F;daemon.json"></a>修改 &#x2F;etc&#x2F;daemon.json</h3><pre><code class="json">&#123;    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],    &quot;storage-driver&quot;: &quot;overlay2&quot;,    &quot;log-driver&quot;: &quot;json-file&quot;,    &quot;log-opts&quot;: &#123;        &quot;max-size&quot;: &quot;100m&quot;    &#125;,    &quot;ip-forward&quot;: true,    &quot;registry-mirrors&quot;: [   &quot;https://mirror.ccs.tencentyun.com&quot;  ]&#125;</code></pre><h3 id="添加软件源并安装（所有节点都要操作）"><a href="#添加软件源并安装（所有节点都要操作）" class="headerlink" title="添加软件源并安装（所有节点都要操作）"></a>添加软件源并安装（所有节点都要操作）</h3><pre><code class="sh">sudo apt-get update &amp;&amp; apt-get install -y apt-transport-httpssudo curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -sudo cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOFsudo apt updatesudo apt install -y kubelet=1.23.0-00 kubeadm=1.23.0-00 kubectl=1.23.0-00</code></pre><h3 id="初始化（仅在-Master-节点操作）"><a href="#初始化（仅在-Master-节点操作）" class="headerlink" title="初始化（仅在 Master 节点操作）"></a>初始化（仅在 Master 节点操作）</h3><pre><code class="sh"># --apiserver-advertise-address: apiserver监听的IP地址# --control-plane-endpoint: 控制平面的IP或域名# --pod-network-cidr: 指定pod网络可以使用的IP地址段# --service-cidr: 指定service的虚拟网络IP段# --token-ttl: 令牌过期时间，默认24小时，0表示永不过期。生产环境中最好设置一定的过期时间kubeadm init \--apiserver-advertise-address=192.168.31.150 \--image-repository registry.aliyuncs.com/google_containers \--kubernetes-version v1.23.0 \--control-plane-endpoint 192.168.31.150 \--service-cidr=10.100.0.0/16 \--token-ttl 0 \--pod-network-cidr=10.244.0.0/16</code></pre><pre><code class="sh">mkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config</code></pre><p>开机自启动 master</p><pre><code class="sh">sudo systemctl enable kubelet</code></pre><p>查看 kubelet 节点信息</p><pre><code class="sh">sudo kubectl get nodes# 只能看到 master 节点，状态为 NotReadyNAME      STATUS     ROLES                  AGE    VERSIONsatur01   NotReady   control-plane,master   2d3h   v1.23.0</code></pre><h3 id="加入节点"><a href="#加入节点" class="headerlink" title="加入节点"></a>加入节点</h3><ol><li>在工作节点执行初始化完成后的提示操作（注意替换为实际的提示操作）</li></ol><pre><code class="sh"># 获取 tokensudo kubeadm token list-- bes778.t843utru84j9mxnw# 获取 shaopenssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed &#39;s/^.* //&#39;-- 1ec9fabfa84ef1f3f3a4c024720632b6af1d3085fcaa80fd4608792051f431f9--sha256:1ec9fabfa84ef1f3f3a4c024720632b6af1d3085fcaa80fd4608792051f431f9sudo kubeadm join 192.168.31.150:6443 --token bes778.t843utru84j9mxnw --discovery-token-ca-cert-hash sha256:1ec9fabfa84ef1f3f3a4c024720632b6af1d3085fcaa80fd4608792051f431f9</code></pre><ol start="2"><li>查看节点列表</li></ol><pre><code class="sh">sudo kubectl get nodes# 因为网络插件没装，所以NotReadykubectl get componentstatuskubectl get cskubectl get pods -n kube-system</code></pre><h2 id="安装Flannel网络插件（需要上github下载flanneld）"><a href="#安装Flannel网络插件（需要上github下载flanneld）" class="headerlink" title="安装Flannel网络插件（需要上github下载flanneld）"></a>安装Flannel网络插件（需要上github下载flanneld）</h2><pre><code class="sh"># 访问https://github.com/flannel-io/flannel#deploying-flannel-manually下载flanneld# 将下载后的flanneld二进制文件放到/opt/bin目录，没可执行权限的话记得授权# 执行以下命令，kube-flannel.yml内容见“附录 -&gt; kube-flannel.yml”sudo kubectl apply -f kube-flannel.yml# 安装完成后再执行一遍kubectl get nodes，查看状态是否为Ready</code></pre><h2 id="安装-calico"><a href="#安装-calico" class="headerlink" title="安装 calico"></a>安装 calico</h2><p><a href="https://docs.projectcalico.org/manifets/calico.yaml">获取 calico.yaml</a> 到 &#x2F;opt&#x2F;k8s 下 : calico.yaml 并修改 docker.io 为 calico，使用 <code>grep image calico.yaml</code>查看并下载镜像。</p><pre><code class="sh">再查看应该没有 Pending 状态的容器kubectl get pods -n kube-system</code></pre><p>参考：<a href="https://www.cnblogs.com/XY-Heruo/p/16369023.html">debian11使用kubeadm安装k8s</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debian12 </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2023/09/02/5157cf948645/"/>
      <url>/2023/09/02/5157cf948645/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-学习笔记"><a href="#Docker-学习笔记" class="headerlink" title="Docker 学习笔记"></a>Docker 学习笔记</h2><p>Docker 是一个为开发、分发、运行应用程序而生的开放平台，Docker 可以让我们将基础环境和应用程序分离开来，以便可以快速交付软件。有了 Docker，我们可以在管理软件的同时管理基础环境。基于 Docker 分发、测试、部署的方法论，可以极大的降低编码与交付运行之间的延迟。</p><p>使用 Docker 可以很轻松的保证程序运行环境的一致性，减少因环境不一致导致的各种问题。各个 Docker 容器之间相互隔离，可以在一个宿主机上运行多个容器，各个容器都包含了应用程序需要的所有资源，可以很轻松的保证同一个容器在每个地方运行的结果都一致。</p><span id="more"></span><h2 id="Debian12-安装-Docker"><a href="#Debian12-安装-Docker" class="headerlink" title="Debian12 安装 Docker"></a>Debian12 安装 Docker</h2><p>卸载旧版本</p><pre><code class="sh">sudo apt remove docker docker-engine docker.io</code></pre><p>安装 gpg 并添加 gpg 密钥</p><pre><code class="sh">sudo apt install gnupgcurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</code></pre><p>添加软件源并更新</p><pre><code class="sh">echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt update</code></pre><p>安装</p><pre><code class="sh">sudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin</code></pre><p>设置开机自启动并启动</p><pre><code class="sh">sudo systemctl enable dockersudo systemctl start docker</code></pre><p>验证</p><pre><code class="sh">sudo docker run --rm hello-world</code></pre><p>输出下面的内容则表示安装成功</p><pre><code>Unable to find image &#39;hello-world:latest&#39; locallylatest: Pulling from library/hello-world719385e32844: Pull completeDigest: sha256:dcba6daec718f547568c562956fa47e1b03673dd010fe6ee58ca806767031d1cStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/</code></pre><p>使用国内 docker 镜像源，创建 &#x2F;etc&#x2F;daemon.json 文件并写入下面的内容：</p><pre><code class="json">&#123;   &quot;registry-mirrors&quot;: [   &quot;https://mirror.ccs.tencentyun.com&quot;  ]&#125;</code></pre><p>参考：<a href="https://docker-practice.github.io/zh-cn/install/debian.html#">Debian 安装 Docker</a></p><h2 id="Dockerfile-生成镜像"><a href="#Dockerfile-生成镜像" class="headerlink" title="Dockerfile 生成镜像"></a>Dockerfile 生成镜像</h2><p>Docker 入门文档中的 Dockerfile：</p><pre><code class="dockerfile"># syntax=docker/dockerfile:1FROM node:18-alpine # 构建镜像时使用的基础镜像WORKDIR /appCOPY . . # 复制当前路径下的文件到 WORKDIRRUN yarn install --productionCMD [&quot;node&quot;, &quot;src/index.js&quot;] # 从镜像启动容器时默认执行的命令EXPOSE 3000</code></pre><p>镜像构建命令：</p><pre><code class="sh"># . 代表 Dockerfile 文件所在路径# -t 构建出来的镜像的可读名称docker build -t getting-started .</code></pre><p>从镜像启动容器：</p><pre><code class="sh"># -d 后台运行# -p 指定容器端口与宿主机端口的映射，宿主机端口:容器端口docker run -dp 3000:3000 getting-started</code></pre><p>查看容器的日志：</p><pre><code class="sh">docker logs &lt;container id&gt;</code></pre><p>查看所有的镜像：</p><pre><code class="sh">docker image lsdocker images</code></pre><p>查看所有的容器：</p><pre><code class="sh">docker ps -a</code></pre><p>停止容器：</p><pre><code class="sh">docker stop &lt;container-id-1&gt; &lt;container-id-2&gt;</code></pre><p>删除容器：</p><pre><code class="sh">docker rm [-f] &lt;container-id-1&gt; &lt;container-id-2&gt;</code></pre><h2 id="Docker-Hub-共享镜像"><a href="#Docker-Hub-共享镜像" class="headerlink" title="Docker Hub 共享镜像"></a>Docker Hub 共享镜像</h2><p>Docker Hub 是一个 Docker 镜像仓库，可以通过 Docker Hub注册 Docker 账号：<a href="https://hub.docker.com/">docker hub</a>，获取 Docker ID 并创建 Docker Repository（Public 类型） 后将自己生成的镜像推送到 Docker Hub 从而与他人共享镜像。</p><p>CLI 登陆 Docker Hub：</p><pre><code class="sh">docker login -u &lt;docker id&gt;</code></pre><p>生成镜像：</p><pre><code class="sh">docker build -t &lt;docker id&gt;/&lt;image name&gt;:[tag name] .</code></pre><p>将镜像推送到 Docker Hub：</p><pre><code class="sh"># docker push &lt;docker id&gt;/&lt;image-name&gt;:[tag name]docker push chenxii81/getting-started:v1.1.0</code></pre><p>问题记录：</p><pre><code>The push refers to repository [docker.io/library/getting-started]cdc22a9416c1: Preparing1455e46f1ebf: Preparingb81bc62fafca: Preparing885a5d40fc11: Preparing1b6c3782871e: Preparingb0e46d71a47b: Waitingf1417ff83b31: Waitingdenied: requested access to the resource is denied</code></pre><blockquote><p>因为 build image 的时候镜像名未添加 docker id。参考： <a href="https://qiita.com/shundayo/items/4ae35930fe9f85f535b0">【備忘録】docker pushしたら拒否された</a></p></blockquote><p>运行容器：</p><pre><code class="sh">docker run -dp 0.0.0.0:3000:3000 &lt;docker id&gt;/getting-started</code></pre><p>映射到 0.0.0.0:3000 可以从外部网络访问，如果写成 <code>-p 3000:3000</code> 也是相同的效果。</p><p>访问：<a href="http://localhost:3000/">http://localhost:3000</a> 可以看到 todo list.</p><h2 id="DB-持久化"><a href="#DB-持久化" class="headerlink" title="DB 持久化"></a>DB 持久化</h2><h3 id="volume-持久化数据"><a href="#volume-持久化数据" class="headerlink" title="volume 持久化数据"></a>volume 持久化数据</h3><p>在一个容器中创建&#x2F;更新&#x2F;删除的文件，对于从同一个镜像来的容器是不可见的。Volumes 可以实现将宿主机文件系统和容器文件系统的关联，容器对挂载的文件所做的操作会保存在宿主机文件系统中，如果将宿主机文件系统挂载到多个容器，那么各个容器可以看到相同的数据。</p><pre><code class="sh">docker volume create &lt;volume name&gt;</code></pre><p>查看卷：</p><pre><code class="sh">docker volume ls</code></pre><p>查看卷详细信息：</p><pre><code class="sh">docker volume inspect &lt;volume name&gt;</code></pre><p>删除卷：</p><pre><code class="sh">docker volume rm &lt;volume name&gt;</code></pre><p>启动容器时使用 <code>--mount</code> 指定挂载的卷：</p><pre><code class="sh">docker run -dp 0.0.0.0:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos chenxii81/getting-started</code></pre><ul><li>type: volume</li><li>src: volume name</li><li>target: 挂载到容器的位置</li></ul><p>查看 volume 中的数据存储位置：</p><pre><code class="sh">docker volume inspect &lt;volume name&gt;</code></pre><pre><code class="json">[    &#123;        &quot;CreatedAt&quot;: &quot;2023-09-02T11:29:50+08:00&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: &#123;&#125;,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/todo-db/_data&quot;,  // 数据存储位置        &quot;Name&quot;: &quot;todo-db&quot;,        &quot;Options&quot;: &#123;&#125;,        &quot;Scope&quot;: &quot;local&quot;    &#125;]</code></pre><p><strong>如果 volume 为空，docker 会将容器中的文件拷贝至 volume，如果 volume不为空，则将 volume 中的内容拷贝至容器中。</strong></p><h3 id="bind-持久化数据"><a href="#bind-持久化数据" class="headerlink" title="bind 持久化数据"></a>bind 持久化数据</h3><p>bind 挂载是除 volume 之外将宿主机文件系统共享到容器的另一种方式。</p><p><strong>如果宿主机中为空，则会清空容器中的目录。如果宿主机有文件，不要使用 bind，容器目录会被清空。</strong></p><p>bind 和 volume 的区别：</p><table><thead><tr><th></th><th>Named volumes</th><th>Bind mounts</th></tr></thead><tbody><tr><td>Host location</td><td>Docker chooses</td><td>You decide</td></tr><tr><td>Mount example (using <code>--mount</code>)</td><td>type&#x3D;volume,src&#x3D;my-volume,target&#x3D;&#x2F;usr&#x2F;local&#x2F;data</td><td>type&#x3D;bind,src&#x3D;&#x2F;path&#x2F;to&#x2F;data,target&#x3D;&#x2F;usr&#x2F;local&#x2F;data</td></tr><tr><td>Populates new volume with container contents</td><td>Yes</td><td>No</td></tr><tr><td>Supports Volume Drivers</td><td>Yes</td><td>No</td></tr></tbody></table><p>bind 使用：</p><pre><code class="sh">docker run -it --mount type=bind,src=&quot;$(pwd)&quot;,target=/src/getting-started ubuntu bash</code></pre><p>在宿主机目录中创建&#x2F;删除文件，docker 容器中能即时看到文件变化。</p><p>Using bind mounts is common for local development setups. The advantage is that the development machine doesn’t need to have all of the build tools and environments installed. With a single docker run command, Docker pulls dependencies and tools.</p><p>将本地源码挂载到 Docker 开发环境中：</p><pre><code class="sh">docker run -dp 127.0.0.1:3000:3000 \-w /app \--mount type=bind,src=&quot;$(pwd)&quot;,target=/app \node:18-alpine \sh c &quot;yarn install &amp;&amp; yarn run dev&quot;</code></pre><p>-w: 指定指定容器工作路径。</p><p>当挂载目录文件有变化时 nodemon 进程会自动重启容器内应用，修改源码可以在应用中即使看到。</p><h2 id="多容器应用"><a href="#多容器应用" class="headerlink" title="多容器应用"></a>多容器应用</h2><h3 id="创建-查看-删除-Docker-网络"><a href="#创建-查看-删除-Docker-网络" class="headerlink" title="创建&#x2F;查看&#x2F;删除 Docker 网络"></a>创建&#x2F;查看&#x2F;删除 Docker 网络</h3><p>考虑到系统的可扩展性、组件隔离、降低容器复杂度，最好在一个容器中只运行一个应用。多个容器之间通过 Docker 网络进行通信。</p><p>创建 Docker 网络</p><pre><code class="sh">docker network create todo-app</code></pre><p>查看 Docker 网络</p><pre><code class="sh">docker network ls</code></pre><p>查看具体的网络详情</p><pre><code class="sh">docker network inspect todo-app</code></pre><p>删除网络</p><pre><code class="sh">docker network rm todo-app</code></pre><p>启动容器时创建网络</p><pre><code class="sh">docker run -d --network todo-app --network-alias mysql -v todo-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=secret -e MYSQL_DATABASE=todos mysql</code></pre><h3 id="nicolaka-netshoot"><a href="#nicolaka-netshoot" class="headerlink" title="nicolaka&#x2F;netshoot"></a>nicolaka&#x2F;netshoot</h3><p>nicolaka&#x2F;netshoot 实际上是一个工具集提供了很多方便的网络问题解决工具，可以加速我们对于日常docker 以及k8s 网络问题的解决。</p><p>参考：<a href="https://github.com/nicolaka/netshoot">nicolaka&#x2F;netshoot - GitHub</a></p><p>运行 nicolaka&#x2F;netshoot 容器</p><pre><code class="sh">docker run -it --network todo-app nicolaka/netshoot</code></pre><p>使用 DNS 工具 dig 命令查看具体容器的网络信息</p><pre><code class="sh">dig mysql</code></pre><pre><code>; &lt;&lt;&gt;&gt; DiG 9.18.13 &lt;&lt;&gt;&gt; mysql;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64589;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;mysql.INA;; ANSWER SECTION:mysql.600INA172.18.0.2 # 容器 IP;; Query time: 16 msec;; SERVER: 127.0.0.11#53(127.0.0.11) (UDP);; WHEN: Sun Sep 03 03:13:12 UTC 2023;; MSG SIZE  rcvd: 44</code></pre><p>将应用加入网络</p><pre><code class="sh">docker run -dp 0.0.0.0:3000:3000 -w /app --mount type=bind,src=&quot;$(pwd)&quot;,target=/app --network todo-app -e MYSQL_HOST=mysql -e MYSQL_USER=root -e MYSQL_PASSWORD=secret -e MYSQL_DB=todos node:18-alpine sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</code></pre><h3 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h3><p>docker compose 是一个用 YAML 文件来定义和分享多容器应用的工具。</p><p>启动单个容器时</p><pre><code class="sh"># nodedocker run -dp 0.0.0.0:3000:3000 -w /app -v &quot;$(pwd)&quot;:/app --network mysql -e MYSQL_HOST=mysql -e MYSQL_DB=todos -e MYSQL_USER=root -e MYSQL_PASSWORD=secret sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; node:18-alpine# mysqldocker run -d --network todo-app --network-alias mysql -v todo-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=secret -e MYSQL_DB=todos mysql:8.0</code></pre><p>在 compose.yaml 文件中定义</p><pre><code class="yaml">services:  app:    image: node:18-alpine    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;    ports:       - 0.0.0.0:3000:3000    working_dir: /app    volumes:      - ./:/app    environment:      MYSQL_DB: todos      MYSQL_USER: root      MYSQL_PASSWORD: secret      MYSQL_HOST: mysql  mysql:    image: mysql:8.0    volumes:      - todo-mysql-data:/var/lib/mysql    environment:      MYSQL_ROOT_PASSWORD: secret      MYSQL_DATABASE: todosvolumes:  todo-mysql-data: </code></pre><p>按照 compose.yaml 定义启动容器（<em>不能按照依赖关系顺序启动，可能导致部分容器启动失败</em>）</p><pre><code class="sh">docker compose up -d</code></pre><p>查看日志</p><pre><code class="sh">docker compose logs -f</code></pre><p>docker 会自动创建 network 和 volume。</p><p>删除相关的容器（不会删除创建的 volume，如果要删除 volume，需要加 –volumes）</p><pre><code class="sh">docker compose down --volumes</code></pre><h2 id="镜像构建最佳实践"><a href="#镜像构建最佳实践" class="headerlink" title="镜像构建最佳实践"></a>镜像构建最佳实践</h2><h3 id="只像镜像中复制必要的文件有助于缩小镜像的大小"><a href="#只像镜像中复制必要的文件有助于缩小镜像的大小" class="headerlink" title="只像镜像中复制必要的文件有助于缩小镜像的大小"></a>只像镜像中复制必要的文件有助于缩小镜像的大小</h3><pre><code class="dockerfile"># syntax=docker/dockerfile:1FROM node:18-alpineWORKDIR /app# 仅复制必要的文件COPY package.json yarn.lock ./RUN yarn install --productionCOPY . .CMD [&quot;node&quot;, &quot;src/index.js&quot;]</code></pre><p>可以使用 .dockerignore 文件</p><h3 id="Multi-stage-builds"><a href="#Multi-stage-builds" class="headerlink" title="Multi-stage builds"></a>Multi-stage builds</h3><p>Multi-stage builds are an incredibly powerful tool to help use multiple stages to create an image. There are several advantages for them:</p><ul><li>Separate build-time dependencies from runtime dependencies</li><li>Reduce overall image size by shipping only what your app needs to run</li></ul><p>构建 Maven&#x2F;Tomcat 应用时，分离编译文件和运行时文件</p><pre><code class="dockerfile"># syntax=docker/dockerfile:1FROM maven AS buildWORKDIR /appCOPY . .RUN mvn packageFROM tomcatCOPY --from=build /app/target/file.war /usr/local/tomcat/webapps</code></pre><p>分两个阶段构建，build 阶段打包，第二阶段复制第一阶段 build 中需要的文件，最终的镜像中不会包含 build 阶段。</p><h2 id="特定场景最佳实践"><a href="#特定场景最佳实践" class="headerlink" title="特定场景最佳实践"></a>特定场景最佳实践</h2><p><a href="https://docs.docker.com/language/nodejs/">Node.js 使用 Docker</a></p><p><a href="https://docs.docker.com/language/java/">Java 使用 Docker</a></p><p>参考资料：</p><ul><li><a href="https://docs.docker.com/get-started/">Getting started - Docker</a></li><li><a href="%5Bhttps://cn.bing.com/search?q=docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8&search=&form=QBLH&sp=-1&lq=0&pq=docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8&sc=10-12&qs=n&sk=&cvid=EE8D6718F27C4A828C93F5E48222F419&ghsh=0&ghacc=0&ghpl=">Docker 常用操作-知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu22.04上安装Postgresql</title>
      <link href="/2023/09/01/832a97d93df3/"/>
      <url>/2023/09/01/832a97d93df3/</url>
      
        <content type="html"><![CDATA[<h2 id="切换到清华源"><a href="#切换到清华源" class="headerlink" title="切换到清华源"></a>切换到清华源</h2><p>最初使用的是阿里云的源，apt 找不到 libllvm 包。</p><p>写入 &#x2F;etc&#x2F;apt&#x2F;sources.list</p><span id="more"></span><pre><code># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to# newer versions of the distribution.deb http://cn.archive.ubuntu.com/ubuntu jammy main restricted# deb-src http://cn.archive.ubuntu.com/ubuntu jammy main restricted## Major bug fix updates produced after the final release of the## distribution.deb http://cn.archive.ubuntu.com/ubuntu jammy-updates main restricted# deb-src http://cn.archive.ubuntu.com/ubuntu jammy-updates main restricted## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu## team. Also, please note that software in universe WILL NOT receive any## review or updates from the Ubuntu security team.deb http://cn.archive.ubuntu.com/ubuntu jammy universe# deb-src http://cn.archive.ubuntu.com/ubuntu jammy universedeb http://cn.archive.ubuntu.com/ubuntu jammy-updates universe# deb-src http://cn.archive.ubuntu.com/ubuntu jammy-updates universe## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu## team, and may not be under a free licence. Please satisfy yourself as to## your rights to use the software. Also, please note that software in## multiverse WILL NOT receive any review or updates from the Ubuntu## security team.deb http://cn.archive.ubuntu.com/ubuntu jammy multiverse# deb-src http://cn.archive.ubuntu.com/ubuntu jammy multiversedeb http://cn.archive.ubuntu.com/ubuntu jammy-updates multiverse# deb-src http://cn.archive.ubuntu.com/ubuntu jammy-updates multiverse## N.B. software from this repository may not have been tested as## extensively as that contained in the main release, although it includes## newer versions of some applications which may provide useful features.## Also, please note that software in backports WILL NOT receive any review## or updates from the Ubuntu security team.deb http://cn.archive.ubuntu.com/ubuntu jammy-backports main restricted universe multiverse# deb-src http://cn.archive.ubuntu.com/ubuntu jammy-backports main restricted universe multiversedeb http://cn.archive.ubuntu.com/ubuntu jammy-security main restricted# deb-src http://cn.archive.ubuntu.com/ubuntu jammy-security main restricteddeb http://cn.archive.ubuntu.com/ubuntu jammy-security universe# deb-src http://cn.archive.ubuntu.com/ubuntu jammy-security universedeb http://cn.archive.ubuntu.com/ubuntu jammy-security multiverse# deb-src http://cn.archive.ubuntu.com/ubuntu jammy-security multiverse</code></pre><h2 id="安装-libllvm14"><a href="#安装-libllvm14" class="headerlink" title="安装 libllvm14"></a>安装 libllvm14</h2><p>执行：</p><pre><code class="shell">sudo apt updatesudo apt install postgresql postgresql-contrib</code></pre><p>提示 libllvm14 包找不到，先安装改包：</p><pre><code class="shell">sudo apt install libllvm14</code></pre><h2 id="安装-ssl-cert-snakeoil-pem"><a href="#安装-ssl-cert-snakeoil-pem" class="headerlink" title="安装 ssl-cert-snakeoil.pem"></a>安装 ssl-cert-snakeoil.pem</h2><p>再执行安装命令，成功安装，但是启动失败：</p><pre><code>● postgresql.service - PostgreSQL RDBMS     Loaded: loaded (/lib/systemd/system/postgresql.service; enabled; vendor preset: enabled)     Active: active (exited) since Fri 2023-03-31 15:42:45 UTC; 2s ago    Process: 9793 ExecStart=/bin/true (code=exited, status=0/SUCCESS)   Main PID: 9793 (code=exited, status=0/SUCCESS)        CPU: 3msMar 31 15:42:45 xingzii-vm systemd[1]: Starting PostgreSQL RDBMS...Mar 31 15:42:45 xingzii-vm systemd[1]: Finished PostgreSQL RDBMS.</code></pre><p>到 &#x2F;var&#x2F;log&#x2F;postgresql 查看日志，提示：</p><pre><code>2023-03-31 15:37:02.316 UTC [9453] FATAL:  could not load server certificate file &quot;/etc/ssl/certs/ssl-cert-snakeoil.pem&quot;: SSL error code 21474836612023-03-31 15:37:02.316 UTC [9453] LOG:  database system is shut downpg_ctl: could not start serverExamine the log output.</code></pre><p>网上看了一下，安装这个就好：</p><pre><code class="shell">sudo apt install ssl-cert &amp;&amp; sudo make-ssl-cert generate-default-snakeoil</code></pre><p>安装好记得修改一下 &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;ssl-cert-snakeoil.pem 的权限：</p><pre><code class="shell">sudo chmod 755 /etc/ssl/certs/ssl-cert-snakeoil.pem</code></pre><p>再启动 postgresql 就好了。</p><p>验证：</p><pre><code class="shell">sudo -u postgres psql -c &quot;SELECT version();&quot;</code></pre><pre><code>perl: warning: Setting locale failed.perl: warning: Please check that your locale settings:    LANGUAGE = (unset),    LC_ALL = (unset),    LC_CTYPE = &quot;UTF-8&quot;,    LC_TERMINAL = &quot;iTerm2&quot;,    LANG = &quot;en_US.UTF-8&quot;    are supported and installed on your system.perl: warning: Falling back to a fallback locale (&quot;en_US.UTF-8&quot;).                                                                version---------------------------------------------------------------------------------------------------------------------------------------- PostgreSQL 12.14 (Ubuntu 12.14-0ubuntu0.20.04.1) on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0, 64-bit(1 row)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 组件动态样式传值</title>
      <link href="/2022/11/17/38ae9b797575/"/>
      <url>/2022/11/17/38ae9b797575/</url>
      
        <content type="html"><![CDATA[<h2 id="前端问题"><a href="#前端问题" class="headerlink" title="前端问题"></a>前端问题</h2><p>最近在做数字化合规项目，做前端页面时遇到一个需求：展示各个状态的任务数量统计，大概是左侧图标、右侧数字的样式。由于很多地方都要展示同样的内容，就将这小块写了一个组件出来。</p><span id="more"></span><p>在页面上引入这个组件之后，数据展示没有问题，但是从父组件传过来图标的颜色会在后端数据返回后消失，展示成默认的黑色。</p><pre><code class="vue">&lt;!-- 父组件 --&gt;&lt;template&gt;    &lt;div&gt;        &lt;my-component :title=&quot;title&quot; :dataList=&quot;dataList&quot;&gt;&lt;/my-component&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    data() &#123;        return &#123;            title: &#39;XX 任务总览&#39;,            dataList: [                &#123;                    name: &#39;待办&#39;,                    value: &#39;todo&#39;,                    icon: &#39;el-file-outline&#39;,                    // 字体图标的颜色                    color: &#39;rgb(10, 10, 10)&#39;                &#125;            ]        &#125;    &#125;&#125;&lt;/script&gt;</code></pre><pre><code class="vue">&lt;!-- 自组件 --&gt;&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;        &lt;div v-for=&quot;(index, item) in dataList&quot;&gt;            &lt;div :style=&quot;&#123;&#39;color&#39;: &#39;item.color&#39;&#125;&quot;&gt;                &lt;span&gt;&lt;i :class=&quot;[iconList[index]]&quot;&gt;&lt;/i&gt;&lt;/span&gt;                &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    props: [&#39;title&#39;, &#39;dataList&#39;],    data() &#123;        return &#123;            iconList: []        &#125;    &#125;    created: &#123;        this.iconList = this.dataList.map(e =&gt; e.icon)    &#125;&#125;&lt;/script&gt;</code></pre><p>用上面这种写法，图标可以展示，父组件请求后端接口报错时图标颜色展示正常，但是正常返回数据之后，颜色会一闪而过。</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>将 v-for 循环里的颜色值打印出来，发现是 undefined，但是其他属性是有值的，开始怀疑是 dom 加载和数据请求的顺序问题或者是自组件监听父组件值变化的问题，看到这个结果之后不确定问题是什么了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在网上搜了一些类似的问题，但是好像都只是传单个样式进去，不涉及到 v-for 循环里取动态样式的。</p><p>博客园上有一个解决方案：<a href="https://www.cnblogs.com/chopin-1990/p/14500338.html">vue动态设置组件样式</a>，通过 css var(–myStyle) 来解决，但是仅限于样式数量确定的情况，排除。</p><p>最后意识到既然 icon 可以正常取到，换成和 color 一样的写法不就可以了吗？于是改了一下自组件的写法：</p><pre><code class="vue">...&lt;div :style=&quot;&#123;&#39;color&#39;: &#39;[colorList[index]]&#39;&#125;&quot;&gt;    &lt;span&gt;&lt;i :class=&quot;[iconList[index]]&quot;&gt;&lt;/i&gt;&lt;/span&gt;    &lt;/div&gt;...&lt;script&gt;export default &#123;    props: [&#39;title&#39;, &#39;dataList&#39;],    data() &#123;        return &#123;            iconList: [],            colorList: []        &#125;    &#125;    created: &#123;        this.iconList = this.dataList.map(e =&gt; e.icon)        this.colorList = this.dataList.map(e =&gt; e.color)    &#125;&#125;&lt;/script&gt;</code></pre><p>刷新一下缓存重新加载页面，颜色可以正常展示了。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 组件传值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop集群升级</title>
      <link href="/2022/08/14/e3805f6785ac/"/>
      <url>/2022/08/14/e3805f6785ac/</url>
      
        <content type="html"><![CDATA[<p>Hadoop 集群升级</p><span id="more"></span><p>1、备份 Namenode 的元数据：</p><pre><code class="sh">hdfs dfsadmin -fetchImage fsImage.back</code></pre><p>2、下载并安装新版本的 Hadoop，推荐从国内镜像站点下载，速度会快很多。</p><p>3、修改环境变量，将 HADOOP_HOME 指向新版本的路径，OLD_HADOOP_HOME 指向旧版本的路径，避免混淆。</p><p>4、复制旧版本的配置文件到新版本配置文件路径，并修改和路径相关的配置。</p><p>5、接下来将 ${HADOOP_HOME}&#x2F;etc&#x2F;hadoop&#x2F;hdfs-site.xml 中的 dfs.namenode.name.dir和dfs.datanode.data.dir 属性的值分别指向新版本 Hadoop 路径下的 hdfs-site.xml 的dfs.namenode.name.dir 和 dfs.datanode.data.dir 属性的值。</p><p>6、新版本 hdfs-site.xml 中添加配置：</p><pre><code class="xml">&lt;property&gt;      &lt;name&gt;dfs.namenode.duringRollingUpgrade.enable&lt;/name&gt;      &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;</code></pre><p>7、启动旧版本的 HADOOP 并进入安全模式：</p><pre><code class="sh"># 进入安全模式$ hdfs dfsadmin -safemode enter# 创建备份$ hdfs dfsadmin -rollingUpgrade prepare# 关闭 Namenode, Datanode, SecondaryNamenode$ stop-yarn.sh$ stop-hdfs.sh</code></pre><p>8、进入新版本的 Hadoop 目录，启动升级：</p><pre><code class="sh"># 启动升级，速度很快$ $HADOOP_HOME/bin/hdfs --daemon start namenode -rollingUpgrade started# 启动 secondaryNamemode$ $xHADOOP_HOME/bin/hdfs --daemon start secondarynamenode# 升级 datanode$ $HADOOP_HOME/bin/hdfs --daemon start datanode # 查看升级进度$ ./hdfs dfsadmin -upgrade query&gt; Upgrade finalized</code></pre><p>进入 HDFS web 页面会有提示：</p><blockquote><p>Rolling upgrade started at Sun Aug 14 18:42:03 +0800 2022.<br>Rollback image has been created. Proceed to upgrade daemons.</p></blockquote><p>进入 Datanodes 页面，每个节点最后一个字段也会提示当前 datanode 的版本升级到了新的版本。</p><p>9、确认升级成功</p><pre><code class="sh">$ ./hdfs dfsadmin -rollingUpgrade finalize</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>effective java</title>
      <link href="/2022/07/26/5a7d26b642c6/"/>
      <url>/2022/07/26/5a7d26b642c6/</url>
      
        <content type="html"><![CDATA[<h2 id="ch2-创建和销毁对象"><a href="#ch2-创建和销毁对象" class="headerlink" title="ch2 创建和销毁对象"></a>ch2 创建和销毁对象</h2><h3 id="考虑使用静态工厂方法代替构造器"><a href="#考虑使用静态工厂方法代替构造器" class="headerlink" title="考虑使用静态工厂方法代替构造器"></a>考虑使用静态工厂方法代替构造器</h3><h4 id="1、静态工厂方法相比构造方法来说，可以指定名称；"><a href="#1、静态工厂方法相比构造方法来说，可以指定名称；" class="headerlink" title="1、静态工厂方法相比构造方法来说，可以指定名称；"></a>1、静态工厂方法相比构造方法来说，可以指定名称；</h4><p>构造函数的名称必须和类名一致，丧失了灵活性。如果有构造方法重载，又存在多个构造参数的时候，这个问题更明显。</p><pre><code class="java">// 存在多个构造参数，不易读Date date0 = new Date();Date date1 = new Date(0L);Date date2 = new Date(&quot;0&quot;);Date date3 = new Date(1, 2, 1);Date date4 = new Date(1, 2, 1, 1, 1);Date date5 = new Date(1, 2, 1, 1, 1, 1);</code></pre><p>代码引用：<a href="https://www.jianshu.com/p/ceb5ec8f1174">关于 Java 的静态工厂方法，看这一篇就够了！</a></p><h4 id="2、静态工厂方法可以控制单例"><a href="#2、静态工厂方法可以控制单例" class="headerlink" title="2、静态工厂方法可以控制单例"></a>2、静态工厂方法可以控制单例</h4><p>如果只需要对外提供一个实例，无需关心是否是新实例，可以使用静态工厂控制单例。</p><pre><code class="java">public class SingletonItem &#123;    private int value;    private static SingletonItem singletonItem = null;    private SingletonItem() &#123;        this.value = new Random().nextInt(100);    &#125;    public static SingletonItem getInstance() &#123;        if (singletonItem != null) &#123;            return singletonItem;        &#125;        singletonItem = new SingletonItem();        return singletonItem;    &#125;    public int getValue() &#123;        return value;    &#125;    public void setValue(int value) &#123;        this.value = value;    &#125;&#125;</code></pre><h4 id="3、可以返回原返回类型的子类型"><a href="#3、可以返回原返回类型的子类型" class="headerlink" title="3、可以返回原返回类型的子类型"></a>3、可以返回原返回类型的子类型</h4><p>构造方法只能返回确定的类型，静态工厂方法可以更加灵活的返回其子类型。</p><pre><code class="java">// 使用静态工厂方法返回子类型public static Item newSubItem(float square) &#123;  SubItem subItem = new SubItem(square);  subItem.setName(&quot;test&quot;);  subItem.setWidth(0);  subItem.setLength(0);  return new SubItem(square);&#125;</code></pre><h3 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h3><p>静态工厂方法和构造方法都有一个缺点：不能很好的扩展到大量可选参数。有时候可能一个类涉及到的可选构造参数比较多，针对每种情况编写一个构造器，工作量非常大而且代码很难控制，调用也需要传许多原本不需要的可选字段。这时候使用构建器就能很好的解决这个问题，因为构造器是通过方法实现的，因此还可以对传入的构造参数进行校验，如果传入的参数不满足约束条件，可以抛出 IllegalState Exception 异常，显示该参数违反了哪个约束条件。</p><p>在内部类 Builder 中区分必须字段（final）和可选字段，并对其进行赋值，最后在 build 方法中返回需要的对象。</p><pre><code class="java">public class Product &#123;    private final String name;    private final String desc;    private final float price1;    private final float price2;    public static class Builder &#123;        // 必须字段        private final String name;        // 可选字段        private String desc;        private float price1;        private float price2;        public Builder(String name) &#123;            if (name == null || name.length() &lt; 5 || name.length() &gt; 8) &#123;                throw new IllegalArgumentException(&quot;产品名称只能由 5 至 8 个字符组成&quot;);            &#125;            this.name = name;        &#125;        public Builder desc(String desc) &#123;            this.desc = desc;            return this;        &#125;        public Builder price1(float price) &#123;            this.price1 = price;            return this;        &#125;        public Builder price2(float price) &#123;            this.price2 = price;            return this;        &#125;        public Product build() &#123;            return new Product(this);        &#125;    &#125;    public Product(Builder builder) &#123;        if ((builder.price1 + builder.price2) &lt; 5) &#123;            throw new IllegalStateException(&quot;价格 1 与价格 2 总和不能小于 5&quot;);        &#125;        this.name = builder.name;        this.desc = builder.desc;        this.price1 = builder.price1;        this.price2 = builder.price2;    &#125;&#125;Product product = new Product.Builder(&quot;product1&quot;)                .desc(&quot;desc1&quot;)                .price1(1.01F)                .price2(2.01F)                .build();</code></pre><p>使用构建器需要注意的点：</p><ul><li>为了创建对象必须先创建他的构建器，在某些注重性能的场景，要十分谨慎；</li><li>确实存在很多参数时才使用，否则使用更常规的方式会更简洁；</li><li>别等到字段扩展到很多时才使用，那时会导致旧的构造器和构建器混用，最好一开始就使用构建器。</li></ul><h3 id="用私有构造器和枚举强化-Singleton-类型"><a href="#用私有构造器和枚举强化-Singleton-类型" class="headerlink" title="用私有构造器和枚举强化 Singleton 类型"></a>用私有构造器和枚举强化 Singleton 类型</h3><p>Singleton：仅仅被实例化一次的类。</p><p>1、使用私有构造创建 Singleton</p><pre><code class="java">public class EnhanceSingleton &#123;    public static final EnhanceSingleton INSTANCE = new EnhanceSingleton();    private EnhanceSingleton() &#123;        System.out.println(&quot;new EnhanceSingleton&quot;);    &#125;    public static void main(String[] args) &#123;        EnhanceSingleton instance1 = EnhanceSingleton.INSTANCE;        EnhanceSingleton instance2 = EnhanceSingleton.INSTANCE;        System.out.println(instance1 == instance2);    &#125;&#125;// outputnew EnhanceSingletontrue</code></pre><p>2、使用静态工厂方法创建 Singleton</p><pre><code class="java">public class EnhanceSingleton &#123;    private static final EnhanceSingleton INSTANCE = new EnhanceSingleton();    private EnhanceSingleton() &#123;        System.out.println(&quot;new EnhanceSingleton&quot;);    &#125;    public static EnhanceSingleton getInstance() &#123;        return INSTANCE;    &#125;    public static void main(String[] args) &#123;        EnhanceSingleton instance3 = EnhanceSingleton.getInstance();        EnhanceSingleton instance4 = EnhanceSingleton.getInstance();        System.out.println(instance3 == instance4);    &#125;&#125;</code></pre><p>3、使用单个元素的枚举创建 Singleton</p><p>单个元素的枚举类型是实现 Singleton 最佳方法。</p><pre><code class="java">public enum TestEnum &#123;    INSTANCE;&#125;</code></pre><h3 id="通过私有构造方法强化不可实例化的能力"><a href="#通过私有构造方法强化不可实例化的能力" class="headerlink" title="通过私有构造方法强化不可实例化的能力"></a>通过私有构造方法强化不可实例化的能力</h3><p>有时候编写一些只包含静态属性和静态方法的通用工具类或者常量类，这些类实例化没有意义，可以通过显示定义一个私有的构造方法覆盖默认构造方法阻止这些类被实例化。</p><pre><code class="java">public class TestUtil &#123;    // 通过私有构造方法强化不可实例化的能力    private TestUtil() &#123;        throw new AssertionError(&quot;工具类不可实例化&quot;);    &#125;    public static String filterCharA(String str) &#123;        if (str == null || &quot;&quot;.equals(str)) &#123;            return str;        &#125;        return str.replaceAll(&quot;a&quot;, &quot;&quot;);    &#125;&#125;</code></pre><h3 id="避免创造不必要的对象"><a href="#避免创造不必要的对象" class="headerlink" title="避免创造不必要的对象"></a>避免创造不必要的对象</h3><h4 id="1、字符串"><a href="#1、字符串" class="headerlink" title="1、字符串"></a>1、字符串</h4><blockquote><p>一般来说，最好能重用对象而不是在每次需要的时候创建一个具有相同功能的新对象。</p><p>如果对象是不可变的（Immutable），那么它始终可以被重用。</p></blockquote><p>反例: <code>String str = new String(&quot;hello world!&quot;);</code></p><p>该语句每次执行的时候都会创建一个新的 String 实例，参数 “hello world!” 本身就是一个 String 实例，功能方面等同于构造器创建的所有对象。如果在循环中被调用，就会创建大量不必要的实例。</p><p>正例: <code>String str = &quot;hello world!&quot;;</code></p><h4 id="2、静态工厂方法优于构造器"><a href="#2、静态工厂方法优于构造器" class="headerlink" title="2、静态工厂方法优于构造器"></a>2、静态工厂方法优于构造器</h4><p><strong>对于同时提供静态工厂方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，可以避免创建不必要的对象。</strong></p><p>反例: <code>Boolean flag = new Boolean(&quot;true&quot;);</code></p><p>正例: <code>Boolean flag = Boolean.valueOf(&quot;true&quot;);</code></p><h4 id="3、静态属性"><a href="#3、静态属性" class="headerlink" title="3、静态属性"></a>3、静态属性</h4><p>已知不会被修改的对象也可以重用。</p><pre><code class="java">public class AvoidNewObj &#123;    private Date birthDate;    public AvoidNewObj(Date birthDate) &#123;        this.birthDate = birthDate;    &#125;    // 每次调用都会创建不必要的 Calenda, TimeZone 实例    public boolean isBabyBoomer() &#123;        Calendar gmt = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));        gmt.set(1946, Calendar.JANUARY, 1, 0, 0, 0);        Date startTime = gmt.getTime();        gmt.set(1965, Calendar.JANUARY, 1, 0, 0, 0);        Date endTime = gmt.getTime();        return birthDate.after(startTime) &amp;&amp; birthDate.before(endTime);    &#125;&#125;</code></pre><pre><code class="java">public class AvoidNewObj1 &#123;    private static final Date startTime;    private static final Date endTime;    private Date birthDate;    // 只需要创建一次 Calendar，TimeZone 实例    static &#123;        Calendar gmt = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));        gmt.set(1946, Calendar.JANUARY, 1, 0, 0, 0);        startTime = gmt.getTime();        gmt.set(1965, Calendar.JANUARY, 1, 0, 0, 0);        endTime = gmt.getTime();    &#125;    public AvoidNewObj1(Date birthDate) &#123;        this.birthDate = birthDate;    &#125;    public boolean isBabyBoomer() &#123;        return birthDate.after(startTime) &amp;&amp; birthDate.after(endTime);    &#125;&#125;</code></pre><p>在同一个机器上循环调用 一千万次 isBabyBoomer() 方法，优化钱耗时 3600 毫秒，优化后耗时 330 毫秒，相差十倍左右。</p><h4 id="4、基本类型与包装类"><a href="#4、基本类型与包装类" class="headerlink" title="4、基本类型与包装类"></a>4、基本类型与包装类</h4><p>优先使用基本类型而不是包装类，当心无意识的自动装箱。</p><pre><code class="java">// 计算所有 int 值的和// 使用包装类耗时 6000 毫秒public static void sum() &#123;    Long sum = 0L;    for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;      sum += i;    &#125;&#125;</code></pre><pre><code class="java">// 计算所有 int 值的和// 使用基本类型，耗时 630 毫秒public static void sum() &#123;    long startTime = System.currentTimeMillis();    long sum = 0L;    for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;      sum += i;    &#125;    long endTime = System.currentTimeMillis();    System.out.println(&quot;耗时(ms): &quot;);    System.out.println(endTime - startTime);&#125;</code></pre><h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><h4 id="1、一个类自己管理内存容易导致内存泄漏"><a href="#1、一个类自己管理内存容易导致内存泄漏" class="headerlink" title="1、一个类自己管理内存容易导致内存泄漏"></a>1、一个类自己管理内存容易导致内存泄漏</h4><blockquote><p>在支持垃圾回收的语言中，内存泄漏（无意识的对象保持）通常比较隐蔽。如果一个对象被无意识的保持下来，垃圾回收机制不仅不会处理这个对象，而且也不会处理这个对象所引用的其他对象。即便只有少量的对象被保持下来，也会导致许多对象被排除在垃圾回收之外，从而对性能造成影响。</p><p>这类问题的修复很简单：如果该引用已过期，手动清空该引用。</p></blockquote><pre><code class="java">public Object pop() &#123;    if (size == 0) &#123;        throw new EmptyStackException();    &#125;    Object result = elements[--size];    // 引用过期时，手动清空该引用    elements[size] = null;    return result;&#125;</code></pre><p>清空过期引用的另一个好处：如果以后又被错误的引用，程序会立即抛出异常，而不是悄悄的运行下去，可以提前检测出程序中的错误。</p><p><strong>清空对象引用应该是一种例外，而不是一种规范，不需要过分小心。</strong></p><h4 id="2、缓存容易导致内粗泄漏"><a href="#2、缓存容易导致内粗泄漏" class="headerlink" title="2、缓存容易导致内粗泄漏"></a>2、缓存容易导致内粗泄漏</h4><p>被放到缓存中的对象很容易被遗忘，从而导致对象过期相当长的一段时间，依然被保留在缓存中。</p><p>解决方案：</p><ol><li>使用 WeakHashMap；</li><li>每次添加新条目的同时，对超期或者无用的引用进行清理；</li><li>交给后台线程（Timer 或者 ScheduledThreadPoolExecutor）完成。</li></ol><h2 id="ch3-对于所有对象都通用的方法"><a href="#ch3-对于所有对象都通用的方法" class="headerlink" title="ch3 对于所有对象都通用的方法"></a>ch3 对于所有对象都通用的方法</h2><blockquote><p>尽管 Object 类是一个具体的类，但是设计它主要是为了扩展，它的所有非 final 方法 (equals(), hashCode(), toString(), clone() 和 finalize()) 都有明确的通用约定，它们被设计成要被覆盖的。如果覆盖这些方法的时候不遵守通用约定，那么对于其他依赖这些约定的类结合该类就不能正常工作。</p></blockquote><h3 id="覆盖-equals-的时候请遵守通用约定"><a href="#覆盖-equals-的时候请遵守通用约定" class="headerlink" title="覆盖 equals 的时候请遵守通用约定"></a>覆盖 equals 的时候请遵守通用约定</h3><h4 id="不需要覆盖-equals-方法的场景"><a href="#不需要覆盖-equals-方法的场景" class="headerlink" title="不需要覆盖 equals 方法的场景"></a>不需要覆盖 equals 方法的场景</h4><p>equals() 方法看起来简单，但是许多覆盖方式会导致很多意想不到的严重错误，最容易避免这类问题的方法就是不覆盖该方法，在这种情况下，类的每个实例都只与它自身相等。</p><ol><li>类的每个实例本质上都是唯一的；</li><li>不关心实例的逻辑相等；</li><li>超类已经覆盖了 equals 方法，从超类继承过来的行为对于子类也是适用的；</li><li>equals 用于不会被调用。</li></ol><p>如果类有自己想等的概念，并且父类没有实现相应的 equals 方法时，就需要进行覆盖。</p><p>如果实例是受控实例，如静态工厂方法控制的实例，最多只存在一个对象时，值相等与对象相等是同一个概念，这时不需要覆盖 equals 方法。</p><p>覆盖 equals 方法的通用约定：</p><ol><li>自反性；</li><li>对称性；</li><li>传递性；</li><li>一致性；</li><li>对于任何非 null 引用值 x，x.equals(null) 必须返回 false。</li></ol><h4 id="如何覆盖-equals-方法"><a href="#如何覆盖-equals-方法" class="headerlink" title="如何覆盖 equals 方法"></a>如何覆盖 equals 方法</h4><ol><li><p>使用 &#x3D;&#x3D; 检查参数是否为该对象的引用；</p></li><li><p>使用 instanceof 判断参数是否是正确的类型（包含了参数为 null 的判断）；</p></li><li><p>将参数转换成正确的类型；</p></li><li><p>逐个检查对象的关键属性，如果全部通过，返回 true ，否则返回 false；</p><p>对于既不是 float 又不是 double 的基本类型，可以使用 &#x3D;&#x3D; 进行比较。对于引用属性，可以递归调用 equals。如果是 float 或者是 double 类型，可以使用 Double.compare() 和 Float.compare() 进行比较。</p></li><li><p>编写完 equals 方法之后，重新审视 对称性、传递性和一致性。</p><p>最好编写单元测试进行检验。</p></li></ol><h4 id="覆盖-equals-方法的一些告诫"><a href="#覆盖-equals-方法的一些告诫" class="headerlink" title="覆盖 equals 方法的一些告诫"></a>覆盖 equals 方法的一些告诫</h4><ol><li>覆盖 equals 方法时总是要同时覆盖 hashCode() 防范；</li><li>不要企图让 equals 方法过于智能；</li><li>不要将 equals 方法中的参数声明外 Object 之外的类型。</li></ol><h3 id="覆盖-equals-方法时总是要覆盖-hashCode"><a href="#覆盖-equals-方法时总是要覆盖-hashCode" class="headerlink" title="覆盖 equals 方法时总是要覆盖 hashCode"></a>覆盖 equals 方法时总是要覆盖 hashCode</h3><p>一个很常见的错误在于没有覆盖 hashCode 方法。覆盖 equals 时一定要覆盖 hashCode，否则就会违反 Object.hashCode 的通用规则，从而导致该类无法结合所有基于散列的集合一起正常运作，包括 HashMap、HashSet、HashTable。</p><p>📃 hashCode 规范：</p><ul><li>在应用程序执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，那么对这个对象调用多次，hashCode 方法都必须始终返回同一个整数；</li><li>如果两个对象根据 equals 方法是相等的，那么这两个对象 hashCode 也必须一致；</li><li>如果两个对象根据 equals 方法是不相等的，则 hashCode 值不一定要相等；但是不相等的对象产生不同的 hashCode，可以提高散列表的性能。</li></ul><pre><code class="java">public class PhoneNumber &#123;    private final short areaCode;    private final short prefix;    private final short lineNumber;    public PhoneNumber(int areaCode, int prefix, int lineNumber) &#123;        this.areaCode = (short) areaCode;        this.prefix = (short) prefix;        this.lineNumber = (short) lineNumber;    &#125;    // 覆盖 equals 方法但是未覆盖 hashCode 方法    @Override    public boolean equals(Object o) &#123;        if (this == o) &#123;            return true;        &#125;        if (!(o instanceof PhoneNumber)) &#123;            return false;        &#125;        PhoneNumber that = (PhoneNumber) o;        return areaCode == that.areaCode                &amp;&amp; prefix == that.prefix                &amp;&amp; lineNumber == that.lineNumber;    &#125;&#125;</code></pre><pre><code class="java">Map&lt;PhoneNumber, String&gt; map = new HashMap&lt;&gt;();PhoneNumber phoneNumber = new PhoneNumber(1, 2, 3);map.put(phoneNumber, &quot;tony&quot;);// hashCode: 356573597System.out.println(&quot;hashCode: &quot; + phoneNumber.hashCode());PhoneNumber phoneNumber1 = new PhoneNumber(1, 2, 3);// hashCode: 1735600054System.out.println(&quot;hashCode: &quot; + phoneNumber1.hashCode());// 获取值String name = map.get(phoneNumber1);// return false// name: falseSystem.out.println(&quot;name: &quot; + &quot;tony&quot;.equals(name));</code></pre><p>虽然覆盖了 equals 方法，但是未覆盖 hashCode，三个属性相同的两个对象 equals 返回相等，hashCode 却是不相等的，违反了 hashCode 约定的第二点。在 HashMap 中因为有不同的 hashCode，所以返回结果不是 “tony” 而是 null。</p><p>覆盖 hashCode 方法可以解决上述问题。而且散列函数对散列表的性能影响很大，因此理想的散列函数，应当能将集合中不相等的实例均匀的分布到所有的散列值上。</p><p>📝 编写散列函数的方法：</p><ol><li>确定一个非零常数值（17），保存到 result 的 int 类型变量中；</li><li>对于对象中的每个域 f:<ol><li>计算该域的散列值 c: <ol><li>boolean类型: f ? 1 : 0</li><li>byte short int: (int) f</li><li>long: (int) (f ^ (f &gt;&gt;&gt; 32))</li><li>float: Float.floatToIntBits(f)</li><li>double: Double.doubleToLongBits(f)</li><li>对象引用: 递归调用 hashCode</li><li>数组: 对每个元素当作单独的域来处理</li></ol></li><li>计算 result &#x3D; 31 * result + c</li></ol></li><li>返回 result</li><li>编写单元测试用例，测试 <strong>相等的实例拥有相等的散列码。</strong></li></ol><p>⚠️ 注意点：</p><ul><li>必须排除 equals 中未使用的域</li><li>如果计算散列值开销较大，对于不变类，可以考虑缓存散列码；</li><li>让 hashCode 返回一个确定的数值并不是明智的做法，会限制将来改进散列函数的能力。</li></ul><h3 id="始终要覆盖-toString"><a href="#始终要覆盖-toString" class="headerlink" title="始终要覆盖 toString"></a>始终要覆盖 toString</h3><p>✅ 建议所有子类覆盖 toString 方法。</p><p>提供好的 toString 实现可以使类用起来更加舒适，对于调试有好处。toString 方法应该返回所有值得关注的域。</p><h3 id="谨慎的覆盖-clone"><a href="#谨慎的覆盖-clone" class="headerlink" title="谨慎的覆盖 clone"></a>谨慎的覆盖 clone</h3><blockquote><p>Cloneable 接口的目的是作为对象的一个 mixin 接口，表明这样的对象允许拷贝。遗憾的是，它没有达到这个目的，因为它缺少一个 clone 方法。Object 类的 clone 方法是受保护的，如果不借助反射，就不能仅仅因为一个类实现了 Cloneable 接口，就可以调用 clone 方法，即使使用反射，也有可能失败，因为不能保证该对象具有可访问的 clone 方法。</p></blockquote><pre><code class="java">// Object 类中受保护的 clone() 方法protected native Object clone() throws CloneNotSupportedException;</code></pre><pre><code class="java">// Cloneable 接口public interface Cloneable &#123;&#125;</code></pre><p>既然 Cloneable 没有包含任何方法，那它的作用是什么呢？它决定了 Object 类中受保护的 clone 方法的实现的行为，如果一个类实现了 Cloneable 接口，Object 类中的 clone 方法就返回该对象逐域拷贝，<strong>否则直接抛出 java.lang.CloneNotSupportedException 异常</strong>。</p><p><em>通常实现接口的目的，是为了表明类可以为它的客户做些什么。然而对于 Cloneable 接口，它改变了超类中受保护的方法的行为。</em></p><p>无需调用构造器就可以创建对象。</p><p>clone 方法的通用约定：</p><ul><li>x.clone() !&#x3D; x 为 true</li><li>x.clone.getClass() &#x3D;&#x3D; x.getClass 为true</li></ul><p>但是这些都不是绝对的要求。</p><p>实现了 Cloneable 接口的类，都应该提供一个公有的 clone 方法，此方法内部先调用 super.clone() ，然后修正任何需要修正的域。一般情况下，这意味着要拷贝任何包含内部<strong>深层结构</strong>的可变对象，并用指向新对象的引用代替原来指向这些对象的引用。</p><pre><code class="java">@Overridepublic Company clone() throws CloneNotSupportedException &#123;  Company clone = (Company) super.clone();  clone.numbers = numbers.clone();  return clone;&#125;</code></pre><p>另一个实现对象拷贝的好办法是提供一个拷贝构造器或拷贝工厂。拷贝构造器的唯一参数为该构造器的类，比如 new TreeSet&lt;&gt;() 。</p><pre><code class="java">public Company newInstance() &#123;    return new Company(name, numbers);&#125;</code></pre><p>拷贝构造器及静态工厂方法相对于 clone 的好处：</p><ol><li>不用遵守约定；</li><li>不会与 final 域冲突；</li><li>不会抛出不受检查的异常；</li><li>不需要进行类型转换。</li></ol><p>建议：<strong>不应该扩展、实现 Cloneable 接口，也不应该覆盖、调用 clone 方法。</strong></p><h3 id="考虑实现-Comparable-接口"><a href="#考虑实现-Comparable-接口" class="headerlink" title="考虑实现 Comparable 接口"></a>考虑实现 Comparable 接口</h3><p>compareTo 方法是 Comparable 接口中唯一的方法，且是一个范型方法。一个类实现了 Comparable 接口，则表明它的实例具有内在的排序关系（大小、状态等）。而且，实现 Comparable 接口之后，它就可以和许多范型算法以及依赖于该接口实现的集合进行协作，付出很小的努力就可以获得强大的功能。Java 平台类库中所有值类都实现了这个接口。如果你正在编写一个值类，其具有明显的内在排序关系，比如按字母、数值、年代等排序，则应坚决考虑实现这个接口。</p><pre><code class="java">public interface Comparable&lt;T&gt; &#123;&#125;</code></pre><p>编写 compareTo 方法与编写 equals 方法不同之处：Comparable 接口是范型接口，而且是静态类型，因此不必进行类型检查，也不用进行类型转换。如果参数为 null，则会抛出 NullPointerException。</p><p>compareTo 方法是对于顺序的比较，比较对象引用域可以通过递归调用 compareTo 方法实现。比较整形基本类型数据，可以使用 &lt; 或 &gt; 来实现；比较浮点数可以使用 Double.compareTo 或 Float.compareTo 来实现；对于数组，则要对每个元素进行比较。</p><pre><code class="java">public class Task implements Comparable&lt;Task&gt; &#123;    public static List&lt;String&gt; TASK_STATUS_LIST = Arrays.asList(&quot;草稿&quot;, &quot;待审批&quot;, &quot;审批通过&quot;, &quot;归档&quot;);    private String name;    private String taskStatus;    public Task(String name, String taskStatus) &#123;        this.name = name;        this.taskStatus = taskStatus;    &#125;    @Override    public String toString() &#123;        return &quot;Task&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, taskStatus=&#39;&quot; + taskStatus + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    @Override    public int compareTo(Task o) &#123;        int index = getStatusIndex(this);        int index1 = getStatusIndex(o);        return Integer.compare(index, index1);    &#125;    private static int getStatusIndex(Task task) &#123;        for (int i = 0; i &lt; TASK_STATUS_LIST.size(); i++) &#123;            if (TASK_STATUS_LIST.get(i).equals(task.getTaskStatus())) &#123;                return i;            &#125;        &#125;        System.out.println(&quot;任务状态不合法&quot;);        return 99;    &#125;&#125;// dataTask task1 = new Task(&quot;task1&quot;, &quot;草稿&quot;);Task task2 = new Task(&quot;task2&quot;, &quot;待审批&quot;);Task task3 = new Task(&quot;task3&quot;, &quot;审批通过&quot;);Task task4 = new Task(&quot;task4&quot;, &quot;归档&quot;);Task task5 = new Task(&quot;task5&quot;, &quot;其他&quot;);// output[task1 -&gt; 草稿][task2 -&gt; 待审批][task3 -&gt; 审批通过][task4 -&gt; 归档][task5 -&gt; 其他]</code></pre><p>因为 compareTo 方法没有指定返回值的大小，只是指定了符号，因此可以利用这一点简化对多个域进行比较时的代码。但是使用这种方法时，要特别考虑结果溢出的情况，溢出会导致 compareTo 返回错误的结果，并且这样的错误很难调试。</p><h2 id="ch4-类和接口"><a href="#ch4-类和接口" class="headerlink" title="ch4 类和接口"></a>ch4 类和接口</h2><h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><p>信息隐藏可以使各系统各模块之间解耦，使得这些模块可以独立的开发、测试、优化和使用。</p><p>信息隐藏的规则：</p><ol><li><p>尽可能的使每个类或成员不被外界访问；</p></li><li><p>实例域绝不能公有；如果域是非 final 的，或者指向可变对象的 final 引用，这个域一旦公有，将对它失去控制。静态域也不能公有，除非要通过 public static final 来暴露一些常量。通常用大写字母加上下划线来表示，很重要的一点是，这些域要么是包含基本类型的值，要么指向不可变对象的引用。如果 final 域包含可变对象的引用，它便具有非 final 域所有的缺点。虽然引用本身不能被修改，但是引用它引用的对象却是可以被修改的。</p><p><strong>长度非 0 的数组总是可变的。</strong>所以，具有 public static final 数组域，或者返回这种域的访问方法，几乎总是错误的！因为这种域可以被任意修改。</p><pre><code class="java">public static String[] TASK_STATUS_LIST = &#123;&quot;草稿&quot;, &quot;待审批&quot;, &quot;审批通过&quot;, &quot;归档&quot;&#125;;// 修改长度非 0 的公有静态数组域Task.TASK_STATUS_LIST[0] = &quot;修改后的内容&quot;;// 解决方案1// 将公有变为私有，并增加一个公有的不可变列表private static String[] TASK_STATUS_LIST = &#123;&quot;草稿&quot;, &quot;待审批&quot;, &quot;审批通过&quot;, &quot;归档&quot;&#125;;public static String[] getTaskStatusList() &#123;    return Collections.unmodifiableList(TASK_STATUS_LIST);&#125;// 解决方案2// 将数组变为私有，并且添加一个公有方法，返回一个数组的备份public static String[] getTaskStatusList() &#123;    return TASK_STATUS_LIST.clone();&#125;</code></pre></li></ol><p>总而言之：<strong>应当始终降低可访问性且防止将散乱的类、接口或成员变成 API 的一部分，除了公有静态 final 域特殊情况外，公有类不应包含公有域，并且要确保公有静态 final 引用的对象都是不可变的。</strong></p><h3 id="在公有类中使用公有方法而非公有域"><a href="#在公有类中使用公有方法而非公有域" class="headerlink" title="在公有类中使用公有方法而非公有域"></a>在公有类中使用公有方法而非公有域</h3><p>有时候可能会编写一些退化类，这种类仅仅用来集中实例域。</p><pre><code class="java">public class Point &#123;    public double x;        public double y;&#125;</code></pre><p>由于这种类的数据域是直接可以访问的，这些类没有提供封装 API 的功能，如果不改变 API，就无法改变的它的数据表示法，也无法强加任何约束条件，当域被访问的时候，无法采取任何辅助措施。这种类应该用私有域和公有访问方法来代替，getter 和 setter 方法。</p><h3 id="使可变形最小"><a href="#使可变形最小" class="headerlink" title="使可变形最小"></a>使可变形最小</h3><p>不可变类只是其实例不可被修改的类。每个实例包含的所有信息必须在<strong>创建该实例的时候就提供</strong>，并在对象的整改生命周期内固定不变。Java 平台内的不可变类：String、基本类型的包装类、BigInteger 和 BigDecimal 类。存在许多不可变的类的理由：易于设计、实现和使用，而且更加安全。</p><p>为了使类成为不可变类，需要遵循 5 条规则：</p><ol><li>不要提供任何会修改对象状态的方法；</li><li>保证类不会被扩展（一般使用 final ）；</li><li>所有域都是 final 的；</li><li>所有域都是私有的（防止被引用的可变对象）；</li><li>确保任何可变组件的互斥访问（如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用）。</li></ol><h3 id="复合优于继承"><a href="#复合优于继承" class="headerlink" title="复合优于继承"></a>复合优于继承</h3><p>封装、继承、多态是面向对象的三个基本特征。继承运行在不改变原有类的情况下，对其进行扩展，是实现代码重用的强有力手段。</p><p>在包内使用继承是安全的，因为继承和实现处于同一个程序员的控制之下。但是对于普通类（不是专门为了继承而设计的类）进行进行跨包边界继承则是非常危险的。</p><p><strong>继承打破了封装性</strong>。子类的实现依赖于基类的实现细节，如果基类的实现细节发生变更，则子类可能会完全遭到破坏，即使子类做任何更改。</p><p>一个继承 HashSet 类的例子，添加了一个域 addCount 记录添加元素的个数：</p><pre><code class="java">public class MyHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;    private int addCount;    @Override    public boolean add(E e) &#123;        this.addCount++;        return super.add(e);    &#125;    @Override    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;        this.addCount += c.size();        return super.addAll(c);    &#125;&#125;</code></pre><p>在该类中覆盖了 HashSet 中的 add 和 addAll 方法，看似没有什么问题，但是通过测试发现这个类是有问题的，先执行 add 然后执行 addAll 后返回的 addCount 不正确。</p><p>因为 HashSet 中，addAll 方法是调用 add 方法来执行添加操作的，所以调用 addAll 之后又对每个元素执行 add 操作，因此 addCount 会返回错误的值。</p><p>只要删除 MyHashSet 类中的 addAll 方法就可以修复这个问题，直接调用 HashSet 类的 addAll 方法，但是它的正确性依然依赖于 addAll 是在 add 之上实现这种事实，可能别的平台的实现方式并非如此，可能将来 HashSet 类会修改这个实现方式，这些情况下都会导致该类出错，总之，这个类非常脆弱！</p><p>还有一种方式就是覆盖 addAll 方法，自己实现 addAll 方法，循环 addAll 的参数集合，循环调用 add 方法。这种情况下相当于重新实现了超类的方法，如果有子类无法访问的私有域，有些方法就无法实现。</p><p>导致子类脆弱还有一个原因就是基类可能在后续的版本获得新方法，则可能仅仅由于调用了未被子类覆盖的新方法而导致错误。</p><p>如果在扩展一个类的时候，仅仅是添加新的方法，而不去覆盖原有的方法，可能是比较安全的做法。但是如果后续版本中基类新增了一个和子类同名同参数但是不同返回类型的方法，则会导致子类无法通过编译。</p><p>复合可以很好的解决以上的问题。在新的类中增加一个私有域引用到现有类的实例，新类中的每个实例方法都可以调用现有类的方法并得到其结果，这种类非常稳固，因为其不依赖于现有类的实现细节，即使现有的类增加了新的方法，也不会影响到新的类。</p><pre><code class="java">public class MyHashSet1&lt;E&gt; &#123;    private int addCount;    // 新的类新增私有域引用到现有类的实例    private HashSet&lt;E&gt; hashSet = new HashSet&lt;&gt;();    public boolean add(E e) &#123;        this.addCount++;        return this.hashSet.add(e);    &#125;    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;        this.addCount += c.size();        return this.hashSet.addAll(c);    &#125;&#125;</code></pre><p>只有当子类型真正是超类的子类型时使用继承才是恰当的。即便如此，如果子类和超类处在不同的包中，并且超类并不是为了继承而设计的，那么继承也将导致脆弱性。为了避免这种情况，可以使用复合和转发机制代替继承。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次Spark任务卡住的问题排查</title>
      <link href="/2022/04/01/3762ce77035a/"/>
      <url>/2022/04/01/3762ce77035a/</url>
      
        <content type="html"><![CDATA[<p>上个版本因为一个需求需要在原有任务上加两个字段，很简单的一件事，想都没多想，直接在 select 后面加上了两个字段，类似于：</p><span id="more"></span><pre><code class="sql">insert overwrite table tbl_test partition (undr)select a.*,       b.app,   -- 新增字段       c.date   -- 新增字段from awhere join b on a.id = b.aidleft join c on a.id = c.aidleft join d on a.id = d.aidleft join e on a.id = e.aidleft join f on a.id = f.aid</code></pre><p>加完之后就上到测试环境去跑了，想着先把基表数据跑出来再做后面的需求。这时候问题出现了，原本基本两个小时跑完的任务，这次跑了五六个小时都没跑完，于是开始找问题。</p><p>最初没深究问题，直接 <code>yarn application -kill application...</code> kill 掉了，因为 kill 掉，所以调度平台收到了任务报错的消息，就自动下发了，我没注意到调度平台会自动下发，于是 kill 掉之后立即手动下发。等我回来排查问题的时候，发现下发的任务都在排队，因为有一个任务在跑，把资源都占用完了。</p><p>重复下发了几次，都是超过四五个小时没结束，甚至头一天下班下发的任务，第二天上班还没跑完，感觉不太对劲，开始仔细排查问题。</p><p>查看日志每次都卡在 stage8，看 DAG 图，应该是最后一个 stage 了，流程比较复杂。怀疑是加的两个字段有问题，于是将两个字段写死成 ‘’ ，结果还是跑不出结果。</p><p>因为不是专业搞大数据的，又临近版本日，只好提单向大数据组的同事求助。结果令人失望，一个接单的女同事，都没看我的 SQL 直接发给我几个优化参数，说加上再跑试试。。原本以为他们能具体问题具体分析的。加上了几个常见的优化参数还是不行。</p><p>确实没办法，只能先上到生产环境，生产环境资源多，历史记录显示基本50分钟左右就能跑完。周末发版之后让运营帮忙下发了任务，持续观察，结果过了快一天也没有跑完，资源占满还导致一些重要的任务被卡住了好几个小时，开始报警。无奈只能强行 kill 掉。</p><p>让大数据组的同事拉了集群节点的进程、内存、CPU资源占用情况，发现内存占用很低，CPU 占用几乎达到100%。</p><p>感觉很诡异了，也找不到问题所在，有点束手无策。前两天下班后和组里的一位对大数据比较熟悉的同事讨论，我正打算把这个表新加的字段删除，直接把任务恢复到改动之前去试试的，这才看到 insert 语句后面跟了动态分区！partition(undr)！！我想我知道问题在哪里了，这个语句有动态分区，原本的 SQL 里最后一个字段是年月，做了分区字段，而我加上了这两个字段之后，现在 SQL 在用客户号分区，而这个 SQL 查出来的客户号有上亿的数据，真相就在这里了！于是开始验证我的想法，先查看表机构，确定原本的最后一个字段就是分区字段；dfs -ls 语句查看表里的目录，确实正是用客户号分的区，分区目录不计其数。确定就是分区导致的问题后，将新增加的两个字段调整到分区字段之前，重新部署、下发任务。不出预料，很顺利的 50 分钟就成功结束，困扰两个星期的问题最终还是靠自己解决。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习笔记</title>
      <link href="/2022/03/20/c5e8e7b94e93/"/>
      <url>/2022/03/20/c5e8e7b94e93/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="为什么需要-Hive"><a href="#为什么需要-Hive" class="headerlink" title="为什么需要 Hive"></a>为什么需要 Hive</h3><p>Hadoop 生态系统的出现，为以合理的成本处理大数据集提供了一个解决方案，它基于 HDFS（分布式文件系统）实现了一个 MapReduce 编程模型，将计算任务分散到多个硬件机器上，从而降低成本并提供水平伸缩性。</p><span id="more"></span><p>但是从现有的数据基础架构转移到 Hadoop 以及从 Hadoop 中获取数据是一个比较麻烦的事情（MapReduce Java API），Hive 的出现就是为了解决这个问题，基于 Hive 可以方便的实现结构化数据到 Hadoop 数据仓库的数据转移。</p><p>Hive 将大多数的查询转化成 MR 任务，HiveQL 既降低了使用难度，也提高了 Hadoop 的扩展性。</p><h3 id="Hive-的局限"><a href="#Hive-的局限" class="headerlink" title="Hive 的局限"></a>Hive 的局限</h3><ul><li>Hive 适用于数据不经常变动，而且不需要立即得到查询结果的情况。</li><li>由于 Hadoop 和 HDFS 的设计，Hive 不支持行级别的插入、删除及更新，不支持事务。</li><li>HiveQL 不符合 ANSI SQL 标准，很多 SQL 和 Oracle、MySQL 存在差异。</li></ul><h3 id="Java-和-Hive-：词频统计算法"><a href="#Java-和-Hive-：词频统计算法" class="headerlink" title="Java 和 Hive ：词频统计算法"></a>Java 和 Hive ：词频统计算法</h3><p>这是《Hadoop权威指南》中的第一章的例子程序，使用 Hadoop Java API 实现一个统计文本文件中每个单词出现次数的程序，可以帮助理解 MR 原理以及使用 Hive 的好处。</p><p>关键代码如下：</p><pre><code class="xml">&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;    &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;    &lt;version&gt;3.2.2&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;    &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;    &lt;version&gt;3.2.2&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;    &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt;    &lt;version&gt;3.2.2&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;    &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;    &lt;version&gt;3.2.2&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><pre><code class="java">package im.yuki.wordcount;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import java.io.IOException;/** * @author longkun * @version V1.0 * @date 2022/3/17 11:36 PM * @description hadoop 词频统计 */public class WordCount &#123;    private static final String OUTPUT_PATH = &quot;hdfs://127.0.0.1:9000/hdp/0317/wordcountoutput/&quot;;    public static class Map extends Mapper&lt;LongWritable, Text, Text, LongWritable&gt; &#123;        private static final LongWritable one = new LongWritable(1);        @Override        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;            String[] words = value.toString().split(&quot; &quot;);            Text word;            for (String w : words) &#123;                word = new Text(w);                context.write(word, one);            &#125;        &#125;    &#125;    public static class Reduce extends Reducer&lt;Text, LongWritable, Text, LongWritable&gt; &#123;        @Override        protected void reduce(Text key, Iterable&lt;LongWritable&gt; values, Context context) throws IOException,                InterruptedException &#123;            int count = 0;            for (LongWritable value : values) &#123;                count += value.get();            &#125;            context.write(key, new LongWritable(count));        &#125;    &#125;    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;        // 设置环境变量 HADOOP_USER_NAME        System.setProperty(&quot;HADOOP_USER_NAME&quot;, &quot;longkun&quot;);        // 读取配置文件        Configuration configuration = new Configuration();        configuration.set(&quot;fs.defaultFS&quot;, &quot;hdfs://127.0.0.1:9000&quot;);        configuration.set(&quot;yarn.resourcemanager.hostname&quot;, &quot;hdp01&quot;);        FileSystem fileSystem = FileSystem.get(configuration);        Job job = Job.getInstance(configuration, &quot;WordCount&quot;);        job.setJarByClass(WordCount.class);        job.setMapperClass(Map.class);        job.setCombinerClass(Reduce.class);        job.setReducerClass(Reduce.class);        job.setMapOutputKeyClass(Text.class);        job.setMapOutputValueClass(LongWritable.class);        job.setOutputKeyClass(Text.class);        job.setOutputKeyClass(LongWritable.class);        job.setNumReduceTasks(2);        Path outputPath = new Path(OUTPUT_PATH);        FileInputFormat.setInputPaths(job, new Path(&quot;hdfs://127.0.0.1:9000/hdp/0317/wordcountinput/&quot;));        FileOutputFormat.setOutputPath(job, outputPath);        if (fileSystem.exists(outputPath)) &#123;            fileSystem.delete(outputPath, true);        &#125;        System.exit(job.waitForCompletion(true) ? 0 : 1);    &#125;&#125;</code></pre><p>⚠️ <em>运行时会提示 log4j 的配置有误，运行程序前需要将 $HADOOP_HOME&#x2F;etc&#x2F;hadoop&#x2F;log4j.properties 文件复制到 src&#x2F;main&#x2F;resouces 目录下。</em></p><p>将需要统计的文本文件上传到 hdfs:&#x2F;&#x2F;127.0.0.1:9000&#x2F;hdp&#x2F;0317&#x2F;wordcountinput 目录下。</p><p>在 Hive 中统计词频：</p><p>1、将文本文件上传到 hdfs 中</p><pre><code class="sh">hdfs dfs -put ~/Desktop/wordcount.txt /hdp/0317/wordcountinput</code></pre><p>2、将 hdfs 中的数据插入到 Hive 表中</p><pre><code class="sql">&gt; load data inpath &#39;/hdp/0317/wordcountinput/wordcount.txt&#39; docs</code></pre><p>3、HiveQL 查询结果</p><pre><code class="sql">select tmp.word, count(*) as cntfrom (    select explode(split(line, &#39; &#39;)) as word  from docs) tmpgroup by tmp.wordorder by cnt;</code></pre><h2 id="Hive-命令"><a href="#Hive-命令" class="headerlink" title="Hive 命令"></a>Hive 命令</h2><p>执行 <code>hive --help</code> 查看 Hive 命令列表：</p><table><thead><tr><th>选项</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>cli</td><td>命令行界面</td><td>进入命令行。</td></tr><tr><td>hwi</td><td>Hive Web 界面</td><td>可以执行查询语句和其他命令的简单 Web 界面。</td></tr><tr><td>metastore</td><td></td><td>启动一个扩展的元数据服务，可以供多客户端使用。</td></tr><tr><td>rcfilecat</td><td></td><td>一个可以打印出 RCFile 格式文件内容的工具</td></tr></tbody></table><h3 id="CLI-选项"><a href="#CLI-选项" class="headerlink" title="CLI 选项"></a>CLI 选项</h3><p>使用命令 <code>hive --help --service cli</code> 查看 cli 选项。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-d | –define</td><td>变量替换</td></tr><tr><td>-e</td><td>执行命令行中的 SQL</td></tr><tr><td>-f</td><td>从文件中执行 SQL</td></tr><tr><td>-H</td><td>打印帮助信息</td></tr><tr><td>-h</td><td>连接主机名</td></tr><tr><td>-i</td><td>初始化 SQL 文件</td></tr><tr><td>-p</td><td>连接端口</td></tr><tr><td>-S | -silent</td><td>交互式命令行下安静模式</td></tr><tr><td>-v | –verbose</td><td>输出调试信息</td></tr></tbody></table><h3 id="Hive-的属性命名空间"><a href="#Hive-的属性命名空间" class="headerlink" title="Hive 的属性命名空间"></a>Hive 的属性命名空间</h3><table><thead><tr><th>命名空间</th><th>权限</th><th>描述</th></tr></thead><tbody><tr><td>hivevar</td><td>可读可写</td><td>用户自定义变量</td></tr><tr><td>hiveconf</td><td>可读可写</td><td>Hive 相关的配置</td></tr><tr><td>system</td><td>可读可写</td><td>Java 定义的配置属性</td></tr><tr><td>env</td><td>只可读</td><td>Shell 环境定义的环境变量</td></tr></tbody></table><p>几个例子🌰：</p><pre><code class="shell"># hivevar --define &amp; set$ hive --define foo=bar;&gt; set foo;&gt; foo=bar;&gt; set hivevar:foo=bar2;&gt; create table tbl_0318(int i, $&#123;foo&#125; string);&gt; desc tbl_0318;OKi                   intbar2                string# hiveconf# 显示当前所在库名&gt; set hiveconf hive.cli.print.current.db=true;# system&gt; set system:user.namesystem:user.name=longkun# env&gt; set env:HOMEenv:HOME=/Users/longkun</code></pre><h3 id="Hive-中使用一次命令"><a href="#Hive-中使用一次命令" class="headerlink" title="Hive 中使用一次命令"></a>Hive 中使用一次命令</h3><p>✅ 如果希望一次执行多个查询，查询结束后立即退出 cli，可以使用 -e 选项：</p><pre><code class="shell">$ hive --service cli -e &quot;select * from db_0316.docs where 1 = 1&quot;;</code></pre><p>✅ 还可以将输出重定向到一个文件中：</p><pre><code class="shell">$ hive --service cli -e &quot;select * from db_0316.docs where 1 = 1&quot; &gt; ~/Desktop/hive_tmp_result.txt</code></pre><p>✅ 当记不清楚某个属性名时，可以使用 grep ：</p><pre><code class="shell">$ hive -S -e &quot;set&quot; | grep current.dbhive.cli.print.current.db=false$ hive -S -e &quot;set&quot; | grep warehousehive.metastore.warehouse.dir=/user/hive/warehouse</code></pre><h3 id="从文件中执行查询"><a href="#从文件中执行查询" class="headerlink" title="从文件中执行查询"></a>从文件中执行查询</h3><p>可以使用 -f 选项从文件中执行一个或多个查询语句，文件尽量使用 .q 或者 .hql 后缀。</p><p>新建一个文本文件 query.hql：</p><pre><code>select *from db_0316.docswhere 1 = 1;</code></pre><pre><code class="shell"># 执行查询$ hive -S -f query.hql# 在 cli 中可以使用 source 命令来执行文件中的查询语句&gt; source ~/Documents/Hive/query.hql</code></pre><h3 id="hiverc文件"><a href="#hiverc文件" class="headerlink" title="hiverc文件"></a>hiverc文件</h3><p>-i 选项执行一个文件，每次 CLI 启动时会先执行这个文件。Hive 会在当前目录下寻找 .hiverc 文件并执行。编辑 $HIVE_HOME&#x2F;.hiverc 文件，添加几个比较实用的变量（⚠️ 分号是必须的）：</p><pre><code>set hive.cli.print.current.db=true;set hive.cli.print.header=true;set hive.exec.mode.local.auto=true;</code></pre><p>✅ <em>使用 tab 键可以补全关键字或者函数名。</em></p><h3 id="执行-shell-命令"><a href="#执行-shell-命令" class="headerlink" title="执行 shell 命令"></a>执行 shell 命令</h3><p>无需退出 cli 即可执行简单的 shell 命令，只需要在 shell 命令前加上 ! ，并且以 ; 结尾。</p><pre><code class="shell">hive (default)&gt; !pwd;/Users/longkun</code></pre><h3 id="在-Hive-内使用-dfs-命令"><a href="#在-Hive-内使用-dfs-命令" class="headerlink" title="在 Hive 内使用 dfs 命令"></a>在 Hive 内使用 dfs 命令</h3><p>用户可以在 cli 中执行 Hadoop  的 dfs 命令，只需要将 hdfs 去掉。</p><pre><code class="shell">hive (default)&gt; dfs -ls /;Found 3 itemsdrwxr-xr-x   - longkun supergroup          0 2022-03-17 23:54 /hdpdrwx-wx-wx   - longkun supergroup          0 2022-03-18 00:52 /tmpdrwxr-xr-x   - longkun supergroup          0 2022-03-16 21:50 /user</code></pre><p><em>据说这种方式比在 bash shell 中执行 hdfs dfs … 更高效，因为后者会每次启动一个 JVM 实例，而 Hive 会在同一个进程执行。</em></p><h2 id="数据类型和文件格式"><a href="#数据类型和文件格式" class="headerlink" title="数据类型和文件格式"></a>数据类型和文件格式</h2><h3 id="byte、Byte、bit、字节"><a href="#byte、Byte、bit、字节" class="headerlink" title="byte、Byte、bit、字节"></a>byte、Byte、bit、字节</h3><ul><li><p>bit</p><pre><code>bit 即是位，表示一个二进制位，0 或 1。</code></pre></li><li><p>byte</p><pre><code>Java 的基本数据类型之一，存储整形，Byte 是其包装类。</code></pre></li><li><p>Byte</p><pre><code>Byte 表示字节，1 Byte = 8 bit</code></pre><p>Hive 中的数据类型都来源于 Java 中的数据类型。</p></li></ul><h3 id="Hive-中的数据类型"><a href="#Hive-中的数据类型" class="headerlink" title="Hive 中的数据类型"></a>Hive 中的数据类型</h3><table><thead><tr><th>数据类型</th><th>长度</th><th>例子🌰</th></tr></thead><tbody><tr><td>TINYINT</td><td>1byte 有符号整数</td><td>20</td></tr><tr><td>SMALLINT</td><td>2byte 有符号整数</td><td>20</td></tr><tr><td>INT</td><td>4byte 有符号整数</td><td>20</td></tr><tr><td>BIGINT</td><td>8byte 有符号整数</td><td>20</td></tr><tr><td>BOOLEAN</td><td>bool类型，true 或者 false</td><td>TRUE</td></tr><tr><td>FLOAT</td><td>单精度浮点型</td><td>3.1315</td></tr><tr><td>DOUBLE</td><td>双精度浮点型</td><td>3.1415</td></tr><tr><td>STRING</td><td>字符序列，可以使用单引号或者双引号</td><td>‘zhang san’  “wang er”</td></tr><tr><td>TIMESTAMP</td><td>整数、浮点或者字符串</td><td>Unix新纪元秒，Unix新纪元秒及纳秒，JDBC时间格式</td></tr><tr><td>BINARY</td><td>字节数组</td><td>和关系型数据库中 VARNIBARY类似？没看懂</td></tr></tbody></table><p><em>单精度和双精度是什么意思？单和双是什么意思？</em></p><p>单精度：1位符号，8位指数，23位小数。</p><p><img src="https://pic1.zhimg.com/80/v2-749cc641eb4d5dafd085e8c23f8826aa_1440w.jpg?source=1940ef5c" alt="单精度表示"></p><p>双精度：1位符号，11位指数，52位小数。</p><p><img src="https://pic2.zhimg.com/80/v2-48240f0e1e0dd33ec89100cbe2d30707_1440w.jpg?source=1940ef5c" alt="双精度表示"></p><p>还是没解释 单 和 双 的意思。。</p><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><blockquote><p>Hive 中支持 struct、map 和 array 集合数据类型。</p></blockquote><table><thead><tr><th>数据类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>STRUCT</td><td>与对象类似，可以通过 . 访问元素内容</td><td>struct{first string, last string}</td></tr><tr><td>MAP</td><td>键值对</td><td>map(‘first’, ‘john’, ‘last’, ‘doe’)</td></tr><tr><td>ARRAY</td><td>具有相同类型的变量集合</td><td>array(‘first’, ‘last’)</td></tr></tbody></table><p>建表语句：</p><pre><code class="sql">drop table if exists db_0320.tbl_person;drop table if exists db_0320.person;create table db_0320.tbl_person (    name string comment &#39;name&#39;,    age float comment &#39;age&#39;,    location string comment &#39;location&#39;,    friends array&lt;string&gt; comment &#39;friends&#39;,    score map&lt;string, double&gt; comment &#39;score&#39;,    address struct&lt;number: tinyint, street: string, city: string&gt;)row format delimitedfields terminated by &#39;\001&#39;collection terminated by &#39;\002&#39;map keys terminated by &#39;\003&#39;lines terminated by &#39;\n&#39;stored as textfile;</code></pre><h2 id="HiveQL-数据定义"><a href="#HiveQL-数据定义" class="headerlink" title="HiveQL 数据定义"></a>HiveQL 数据定义</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li>HiveQL 和 MySQL 比较接近，但也有较大差异</li><li>Hive 不支持行级插入、更新及删除操作</li><li>Hive 不支持事务</li><li>大多数情况下 HiveQL 和其他 SQL 很像</li><li>查询、分组、过滤及连接</li></ul><h3 id="常见查询"><a href="#常见查询" class="headerlink" title="常见查询"></a>常见查询</h3><pre><code class="sql">-- 新建数据库&gt; create database db_test;&gt; create database if not exists db_test;-- 查看所有的库&gt; show databases;-- 使用正则表达式-- 查询以 db_ 开头 的所有数据库&gt; show databases like &#39;db_*&#39;-- 查看库里的表&gt; show tables from db_test;-- 删库（删库之前必须先删除库中的表，或者使用关键字 CASCADE）&gt; drop database if exists db_test cascade;-- 查看表属性&gt; desc formatted tbl_test;-- 如果只想查看某一列的信息，只需在表名后增加这一列的名称即可（亲测报错：missing EOF at &#39;.&#39; near &#39;tbl_person&#39;）&gt; describe db_0320.tbl_person.score;-- 拷贝一张已存在的表&gt; create table if not exists tbl_test1 like tbl_test;</code></pre><h3 id="内部表与外部表（MANAGED-TABLE-EXTERNAL-TABLE）"><a href="#内部表与外部表（MANAGED-TABLE-EXTERNAL-TABLE）" class="headerlink" title="内部表与外部表（MANAGED_TABLE &amp; EXTERNAL_TABLE）"></a>内部表与外部表（MANAGED_TABLE &amp; EXTERNAL_TABLE）</h3><p>使用 EXTERNAL 创建的表是外部表，否则就是内部表。内部表默认存储在 user&#x2F;hive&#x2F;warehouse&#x2F;下， 当删除一个表时，Hive 会删除该目录下存储的数据；而删除外部表时，只会删除表的元数据，不会删除表数据。严格说，Hive 管理着这么目录和文件，但是不对其拥有完全控制权。</p><p>外部表示例：</p><p>1、先建立一个目录，存放外部表要操作的数据</p><pre><code class="shell">&gt; dfs -mkdir /hdp/0322</code></pre><p>2、建表并指向外部表空间</p><pre><code class="shell">drop table if exists db_0320.ex_tbl_student;create external table if not exists db_0320.ex_tbl_student (    name string comment &#39;name&#39;,    age float comment &#39;age&#39;,    class string comment &#39;class&#39;)row formatdelimited fields terminated by &#39;,&#39;location &#39;/hdp/0322/&#39;;</code></pre><p>3、准备数据并上传至 HDFS</p><pre><code class="shell">&gt; dfs -put ~/Documents/ex_tbl_student.txt /hdp/0323/</code></pre><p>文件内容：</p><pre><code>zhangsan,12,一班lisi,14,二班wangwu,16,三班</code></pre><p>4、将数据导入外部表中</p><pre><code class="shell">&gt; load data inpath &#39;/hdp/0323/ex_tbl_student.txt&#39; overwrite into table db_0320.ex_tbl_student;</code></pre><p>5、确认数据及操作</p><h2 id="分区表和管理表"><a href="#分区表和管理表" class="headerlink" title="分区表和管理表"></a>分区表和管理表</h2><p>分区将数据分散在多个目录下，可以提高查询性能。</p><p>如果表中数据或者分区中的数据量巨大，执行一个包含所有分区的查询会出发巨大的 MR 任务，可以将 <code>hive.mapred.mode=strict</code> 设置成严格模式禁止提交任务。</p><p>创建分区表：</p><pre><code class="sql">drop table if exists db_0322.tbl_student;create table if not exists db_0322.tbl_student (    name string comment &#39;name&#39;,    age float comment &#39;age&#39;,    class string comment &#39;class&#39;)partitioned by (grade string comment &#39;grade&#39;);</code></pre><p>查看分区：</p><pre><code class="shell">&gt; desc partitions db_0322.tbl_student;</code></pre><p>导入数据至分区表：</p><pre><code class="sh">&gt; load data inpath &#39;tbl_student.txt&#39; overwrite into table tbl_student partition (grade=&#39;grade2&#39;);</code></pre><p>为外部分区表增加一个分区：</p><pre><code class="sql">&gt; alter table log add partition(year=2012, month=1, day=1);</code></pre><h2 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h2><p>删除表：</p><pre><code class="sql">&gt; drop table if exists db_0323.tbl_test;</code></pre><p><em>可以了解下 Hive 的回收站功能。</em></p><p>修改表：可以使用 alter table 语句修改表，这种方式会<strong>修改表的元数据，不会修改数据本身。</strong></p><pre><code class="sql">-- 重命名表&gt; alter table tbl_test rename to tbl_test1;-- 增加分区，给没有分区的表添加分区会报错&gt; alter table tbl_test add if not exists partition (city=&#39;Beijing&#39;);-- 删除分区&gt; alter table tbl_test2 drop if exists partition (city = &#39;Beijing&#39;);-- 修改字段&gt; alter table tbl_test2 change column name username string comment &#39;username&#39; after column1;-- 新增一个字段&gt; alter table tbl_test1 add columns (age float comment &#39;age&#39;);-- 修改表属性&gt; alter table tbl_test1 set tblproperties (&#39;note&#39;=&#39;test note....&#39;)-- 执行钩子，当往表中写入数据时触发执行&gt; alter table tbl_test touch partition(year=2021, month=12, day=1);-- 将分区内的文件打包成 Hadoop 压缩包（HAR），使用 unarchive 反向操作&gt; alter table ... archive partition (year, month, day);-- 防止分区被修改或删除（报错）&gt; alter table tbl_test partition (year=2021, month=10, day=1) enable no_drop;</code></pre><h2 id="HiveQL-数据操作"><a href="#HiveQL-数据操作" class="headerlink" title="HiveQL 数据操作"></a>HiveQL 数据操作</h2><p>Hive 不支持行级数据插入、更新及删除，只能通过大批量的方式将数据导入表中。</p><pre><code class="sql">&gt; load data local inpath &#39;$&#123;env:HOME&#125;/data&#39; overwrite into table tbl_test partition (year = 2022, month = 3, day = 22);</code></pre><p><em>local 表示本地目录，如果不加 local 则表示 hdfs 上的文件。</em></p><p>Hive 不会校验导入的数据和表的模式是否匹配，但是会校验文件格式是否和表的定义一致。</p><p>通过查询向表中导入数据：</p><pre><code class="sql">use db_0323;from tbl_test3_tmp tmpinsert overwrite table tbl_test3    partition (city = &#39;Beijing&#39;)    select name where tmp.city = &#39;Beijing&#39;insert overwrite table tbl_test3    partition (city = &#39;Tianjin&#39;)    select name where tmp.city = &#39;Tianjin&#39;insert overwrite table tbl_test3    partition (city = &#39;Tianjing&#39;)    select name where tmp.city = &#39;Tianjing&#39;;</code></pre><p>如果一个分区一个分区的查出来再导入的话，会非常繁琐，可以使用动态分区插入来避免这个问题。</p><pre><code class="sql">use db_0323;insert overwrite table tbl_test3select name, cityfrom tbl_test3_tmp;</code></pre><p><em>最后的几列顺序要和分区字段一致，Hive 根据列位置来确定分区字段，而不是名称。并且静态分区字段必须位于动态分区字段之前。</em></p><p><code>dfs -ls /user/hive/warehouse/db_0323.db/tbl_test3</code> 查看分区：</p><pre><code>Found 3 itemsdrwxr-xr-x   - longkun supergroup          0 2022-03-24 23:56 /user/hive/warehouse/db_0323.db/tbl_test3/city=Beijingdrwxr-xr-x   - longkun supergroup          0 2022-03-24 23:56 /user/hive/warehouse/db_0323.db/tbl_test3/city=Tianjindrwxr-xr-x   - longkun supergroup          0 2022-03-24 23:56 /user/hive/warehouse/db_0323.db/tbl_test3/city=Tianjing</code></pre><p>动态分区功能默认是关闭的。开启后，默认以“严格”模式执行，这种模式下，要求至少有一列字段是静态分区，有助于防止因设计错误导致产生大量的分区。</p><p>动态分区相关属性：</p><table><thead><tr><th>属性名称</th><th>缺省值</th><th>描述</th></tr></thead><tbody><tr><td>hive.exec.dynamic.partition</td><td>false</td><td>设置成 true，开启动态分区功能</td></tr><tr><td>hive.exec.dynamic.partition.mode</td><td>strict</td><td>设置成 no strict，允许所有列都是动态分区</td></tr><tr><td>hive.exec.max.dynamic.partitions.pernode</td><td>100</td><td>每个 mapper 和 reducer 可以创建的最大分数，超过会报错</td></tr><tr><td>hive.exec.max.dynamic.partitions</td><td>1000</td><td>一个动态分区语句可以创建的最大动态分区个数，超过会报错</td></tr><tr><td>hive.exec.max.created.files</td><td>100000</td><td>全局可以创建的最大文件个数，超过会报错</td></tr></tbody></table><p>单个查询语句创建表并加载数据：</p><pre><code class="sql">create table tbl_test4 asselect namefrom tbl_test3where city = &#39;Beijing&#39;;</code></pre><p>导出数据 <code>insert directory</code>：</p><pre><code class="sql">use db_0323;-- 第一种方式insert overwrite local directory &#39;$&#123;env:HOME&#125;/Documents/Hive/export&#39;select name, cityfrom tbl_test3where city = &#39;Beijing&#39;;-- 第二种方式from tbl_test3 tmpinsert overwrite local directory &#39;$&#123;env:HOME&#125;/Documents/Hive/export-beijing&#39;    select name where tmp.city = &#39;Beijing&#39;insert overwrite local directory &#39;$&#123;env:HOME&#125;/Documents/Hive/export-tianjin&#39;    select name where tmp.city = &#39;Tianjin&#39;insert overwrite local directory &#39;$&#123;env:HOME&#125;/Documents/Hive/export-tianjing&#39;    select name where tmp.city = &#39;Tianjing&#39;;</code></pre><p><em>Hive 中没有临时表的概念。</em></p><h2 id="HiveQL-查询"><a href="#HiveQL-查询" class="headerlink" title="HiveQL 查询"></a>HiveQL 查询</h2><h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><table><thead><tr><th>返回值类型</th><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>BIGINT</td><td>round(double d)</td><td>取近似值</td></tr><tr><td>DOUBLE</td><td>round(double d, int n)</td><td>取近似值，保留 n 位小数</td></tr><tr><td>BIGINT</td><td>floot(double d)</td><td>向下取整</td></tr><tr><td>BIGINT</td><td>ceil(double d)</td><td>向上取整</td></tr><tr><td>DOUBLE</td><td>rand()</td><td>生成一个 DOUBLE 类型的随机数</td></tr><tr><td>STRING</td><td>concat_ws(string separator, string s1, string s2…)</td><td>使用指定的分隔符连接字符串</td></tr><tr><td>STRING</td><td>substr(string s, int start, int length)</td><td>截取子字符串</td></tr><tr><td>STRING</td><td>to_date(string date)</td><td>‘2022-01-01 10:20:12’ -&gt; ‘2022-01-01’</td></tr><tr><td>INT</td><td>year(string date)</td><td>返回年</td></tr><tr><td>INT</td><td>month</td><td>获取月份</td></tr><tr><td>INT</td><td>date_diff(string date1, string date2)</td><td>获取两个日期相差天数</td></tr><tr><td>INT</td><td>date_add(string date, int days)</td><td>日期相加</td></tr><tr><td>INT</td><td>date_sub(string date, int days)</td><td>日期相减</td></tr></tbody></table><h3 id="嵌套-SELECT"><a href="#嵌套-SELECT" class="headerlink" title="嵌套 SELECT"></a>嵌套 SELECT</h3><pre><code class="sql">from (    select name, age  from tbl_test3  where age &gt; 10) tmpselect tmp.*where tmp.name like &#39;zhang%&#39;;</code></pre><h3 id="CASE-WHEN"><a href="#CASE-WHEN" class="headerlink" title="CASE WHEN"></a>CASE WHEN</h3><pre><code class="sql">select name,       case         when age &lt; 18 then &#39;未成年&#39;         when age &gt;= 18 and age &lt; 60 then &#39;成年&#39;         else &#39;老年&#39;       end as age,       sex from tbl_test;</code></pre><h3 id="避免进行-MapReduce"><a href="#避免进行-MapReduce" class="headerlink" title="避免进行 MapReduce"></a>避免进行 MapReduce</h3><ul><li>where 条件中过滤字段是分区字段</li><li>没有 where 条件的 select 语句</li><li>hive.exec.mode.local.auto&#x3D;true 会尝试本地模式执行其他 SQL</li></ul><h3 id="类型转换-cast"><a href="#类型转换-cast" class="headerlink" title="类型转换 cast"></a>类型转换 cast</h3><p><em>最好使用 ceil &#x2F; floor &#x2F; round 等函数来将字符串转为整数。</em></p><h3 id="抽样查询"><a href="#抽样查询" class="headerlink" title="抽样查询"></a>抽样查询</h3><p>按照（基于行数的）百分比进行抽样。</p><pre><code class="sql">select * from tbl_student_info_tmp tablesample(50 percent);</code></pre><h3 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h3><p>将多个子表进行合并，这几个子表的列及顺序及类型必须完全一致，理论上可以改为多个 where 语句。</p><h2 id="HiveQL-视图"><a href="#HiveQL-视图" class="headerlink" title="HiveQL 视图"></a>HiveQL 视图</h2><p>可以使用视图简化查询：</p><pre><code class="sql">-- 所有来自北京的学生create view view_student_beijing asselect uid, name, age, grade, classfrom tbl_student_infowhere home_address.province = &#39;北京&#39;;-- 来自北京年龄小于 20 的学生select *from view_student_beijingwhere ceil(age) &lt;= 20;</code></pre><p>删除视图：</p><pre><code class="sql">drop view if exists view_student_beijing;</code></pre><p><em>视图不能做为 load 和 insert 的目标表。视图是只读的，只允许改变与数据信息 tblpropreties。</em></p><pre><code class="sql">alter view set tblproperties(&#39;created_by&#39;=&#39;system&#39;);</code></pre><h2 id="HiveQL-索引"><a href="#HiveQL-索引" class="headerlink" title="HiveQL 索引"></a>HiveQL 索引</h2><h2 id="模式设计"><a href="#模式设计" class="headerlink" title="模式设计"></a>模式设计</h2><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>随着系统运行时间的增加，表数据量会越来越大，Hive 查询通常是全表扫描，性能会越来越低。可以使用分区表提高性能。</p><pre><code class="sql">create table tbl_test(name string)partitioned by (kind string);</code></pre><p>分区列只是一个目录名称，实际不存储这一列数据。</p><p>应该选择合适的分区字段，如果分区数太大，会创建大量的 Hadoop 文件及文件夹，反而会降低查询效率。</p><p>可以选择多个分区字段来进行分区。</p><pre><code class="sql">create table student (    name string,  sex string) partitioned by (grade string, class string);</code></pre><p>查看分区：</p><pre><code class="sql">show partitions table_name;</code></pre><h3 id="唯一键和标准化"><a href="#唯一键和标准化" class="headerlink" title="唯一键和标准化"></a>唯一键和标准化</h3><p>Hive 没有关系型数据库中的唯一键和序列自增，应避免对非标准化（？）数据进行 JOIN 操作，复杂的数据类型，可以通过 Array、Map、STRUCT 实现。</p><h3 id="同一份数据处理多次"><a href="#同一份数据处理多次" class="headerlink" title="同一份数据处理多次"></a>同一份数据处理多次</h3><p>Hive 可以从一个数据源产生多个数据聚合，而无需每次聚合都重新扫描一次，可以节省很多时间。</p><pre><code class="sql">from tbl_student_info_tmpinsert overwrite tbl_student_info1 where age &gt; 10;insert overwrite tbl_student_info2 where age &gt; 20;</code></pre><h3 id="对于每个表的分区"><a href="#对于每个表的分区" class="headerlink" title="对于每个表的分区"></a>对于每个表的分区</h3><p>对于一些中间数据可以使用分区，可以保证任务重跑的时候不会覆盖所有的数据，只对目标数据进行处理。</p><p>这几个月负责公司一些数据的处理，基本都是按月拉结果，使用月末的时间做为分区，这样每一个月的数据都可以留存下来成为历史数据，不受下个月数据的影响。</p><h3 id="分桶-🪣"><a href="#分桶-🪣" class="headerlink" title="分桶 🪣"></a>分桶 🪣</h3><p>Hive表分区的实质是分目录（将超大表的数据按指定标准细分到指定目录），且分区的字段不属于Hive表中存在的字段；分桶的实质是分文件（将超大文件的数据按指定标准细分到分桶文件），且分桶的字段必须在Hive表中存在。</p><p>分桶的好处在于表中的数据已经按条件分到了多个文件中，join 或者其他计算时只需取符合条件的数据进行处理，从而提高性能。</p><pre><code class="sql">-- 创建分桶表use db_0327;drop table if exists bucket_tbl_student_info;create table if not exists bucket_tbl_student_info (  uid string comment &#39;uid&#39;,  name string comment &#39;name&#39;,  age int comment &#39;age&#39;) clustered by (age) into 2 bucketsrow format delimitedfields terminated by &#39;,&#39;lines terminated by &#39;\n&#39;;-- 将数据写入分桶表set hiveconf:hive.enforce.bucketing=true;use db_0327;from tbl_student_info_tmpinsert overwrite table bucket_tbl_student_infoselect uid, name, floor(age) as age where 1 = 1;-- 如果不设置  hiveconf:mapred.reduce.tasks，则需要手动设置与分桶个数相等的 reducer 数set hiveconf:mapred.reduce.tasks=2;use db_0327;from tbl_student_info_tmpinsert into table bucket_tbl_student_infoselect uid, name, floor(age)where 1 = 1cluster by age;-- 从分桶表中获取抽样数据select uid, name, age from bucket_tbl_student_info tablesample(bucket 1 out of 2 on age);</code></pre><p><em>将 hive.enforce.bucketing 设置成 true 之后，Hive 会在目标表初始化过程中设置一个正确的 reducer 数。</em></p><h3 id="为表新增列"><a href="#为表新增列" class="headerlink" title="为表新增列"></a>为表新增列</h3><blockquote><p>Hive 表对数据格式的要求比较宽松，列的信息在元数据中，新增列或者删除列只是改变元数据。如果列的个数比实际数据的列要多，则多余的列会被省略，相反，则会以 NULL 填充。</p></blockquote><p>Hive 表新增列：</p><pre><code class="sql">alter table tbl_access_log add columns (rank1 int, rank2 int);</code></pre><p>在新增列之前入库的数据，查询的时候新加的字段会用 NULL 填充。</p><h3 id="使用列存储表-📦"><a href="#使用列存储表-📦" class="headerlink" title="使用列存储表 📦"></a>使用列存储表 📦</h3><p>Hive 默认使用行式存储。假设有足够多的列，列中有很多的重复数据，这种类型的数据使用列式存储性能会更好，查询的时候不要加载所有列的数据。</p><p><em>参见 15.3.2 RCfile 使用这种格式？</em></p><h3 id="使用压缩-🗜️"><a href="#使用压缩-🗜️" class="headerlink" title="使用压缩 🗜️"></a>使用压缩 🗜️</h3><p>几乎所有的情况下，使用压缩都能降低磁盘占用量，降低 I&#x2F;O 以提高查询速度。</p><p>使用外部数据或者非压缩格式时无法使用压缩。</p><p>压缩和解压缩都会消耗 CPU 资源，但是大多数 MR 任务都是 I&#x2F;O 密集型任务，所以 CPU 开销通常不是问题。</p><h2 id="Hive-常见问题及解决方案记录-📝"><a href="#Hive-常见问题及解决方案记录-📝" class="headerlink" title="Hive 常见问题及解决方案记录 📝"></a>Hive 常见问题及解决方案记录 📝</h2><p>1、启动 Hive 报错：Cannot create directory &#x2F;tmp&#x2F;hive&#x2F;longkun&#x2F;50be98c2-62e0-4b37-9002-c2270fed6a20. Name node is in safe mode.</p><blockquote><p>控制台日志提示无法创建临时目录，Hive 处于安全模式中。</p><p>安全模式主要是 HDFS 系统的时候检查 DataNode 上数据块的有效性，同时根据策略复制和删除部分数据块，运行的时候也可以通过命令进入安全模式。安全模式中不允许修改和删除数据。</p><p>可以通过命令来离开安全🔐模式：<code>hadoop dfsadmin -safemode leave</code> </p><p>离开安全模式之后，Hive 正常启动。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS下Hadoop和Hive安装配置问题记录</title>
      <link href="/2022/03/19/8017d84950b3/"/>
      <url>/2022/03/19/8017d84950b3/</url>
      
        <content type="html"><![CDATA[<p>MacOS 下 Hadoop 和 Hive 安装配置问题记录</p><span id="more"></span><p>MacOS catalina 由于系统版本较低已经无法编辑共享的 Numbers 表格，但是重装系统所有的开发环境又要重新弄一遍，一天时间都不一定搞得完。纠结了好几个月，前两天还是决定把系统升级到最新的 Monterey 了。</p><p>之前的 Hadoop 和 Hive 环境是在 Ubuntu 虚拟机中配置的，这次想着虚拟机也要吃配置，索性直接安装在本机了，途中遇到一些问题，卡了几个小时，记录一下。</p><!-- readmore --><p>问题一：hdfs 启动报错：Cannot set priority for process ….</p><pre><code>在配置的日志目录下可以查看启动错误日志，我的日志目录为 $HADOOP_HOME/logs每次启动报错会生成一个 .log 文件，输出错误日志后看到：cannot change file mode on .../datanode, operation not permitted可以看到是文件权限的错误，之前配置都是新建一个 Hadoop 用户去配置，这次直接是用 root ，安装路径也是 root 目录下。将 $HADOOP_HOME/data 目录的属主改成当前用户就好了，虽然还是不太愿意这样做。。$ sudo chown -R user:staff $HADOOP/data</code></pre><p>问题二：Hive 启动报错：system:java.io.tmpdir</p><pre><code>在 $HIVE_HOME 下新建 tmp 目录，然后编辑 $HIVE_HOME/conf/hive-site.xml 文件，添加以下配置：  &lt;property&gt;    &lt;name&gt;system:java.io.tmpdir&lt;/name&gt;    &lt;value&gt;/opt/hive/hive-3.1.2/tmp&lt;/value&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;syetem:user.name&lt;/name&gt;    &lt;value&gt;root&lt;/value&gt;  &lt;/property&gt;  </code></pre><p>问题三：Hive 启动报错：java.net.URISyntaxException: Relative path in absolute URI: ${system:user.name%7D</p><pre><code>在该路径下使用了绝对URI，因为上面配置了 user.name，编辑 $HIVE_HOME/conf/hive-site.xml搜索用到 system:user.name 的地方，删掉system，改成 user.name即：  &lt;property&gt;    &lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt;    &lt;value&gt;$&#123;system:java.io.tmpdir&#125;/$&#123;user.name&#125;&lt;/value&gt;    &lt;description&gt;Local scratch space for Hive jobs&lt;/description&gt;  &lt;/property&gt;</code></pre><p>参考：</p><ul><li><a href="https://blog.csdn.net/baidu_34122324/article/details/84942965">https://blog.csdn.net/baidu_34122324/article/details/84942965</a></li><li><a href="https://blog.csdn.net/weixin_45082972/article/details/116056745">https://blog.csdn.net/weixin_45082972/article/details/116056745</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机-2-Java内存区域及异常</title>
      <link href="/2022/01/22/f86c2029e70e/"/>
      <url>/2022/01/22/f86c2029e70e/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java 与 C++ 之间有一堵由内存动态分配和垃圾回收技术所围成的高墙，墙外的人想进去，墙里的人想出来。</p></blockquote><p>从大二开始学习 Java ，到现在工作的第四个年头，早已经习惯了 Java 的开发模式——想要对象就 new 一个，内存的分配和溢出从来没放在心上。前两天在 ESP8266 上写代码，开发板的 flash 只有 4M 内存，每行代码都要思前想后，申请释放内存的工作让人精疲力竭。C 语言考验技术， Java 用起来省心。</p><span id="more"></span><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><ul><li>方法区（Method Area）-线程共享</li><li>堆（Heap）                   -线程共享</li><li>虚拟机栈（VM Stack）</li><li>本地方法栈（Native Method Stack）</li><li>程序计数器（Program Counter Register）</li></ul><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>一块较小的内存空间，当前线程执行字节码指令的行号指示器，字节码指示器通过改变计数器的值获得下一条将要执行的指令，实现分支、循环、异常处理等功能。</p><p>Java虚拟机的多线程是通过<strong>线程轮换、分配处理器执行时间</strong>来实现的，同一时刻只有一个线程运行，为了使线程处理器执行时间结束后能回到正确的位置，每个线程都需要一个独立的计数器（<strong>线程私有</strong>）。类似于体能测试跑800米1000米一样，不跑的几个人分别盯着跑的那几个人，每个旁边的人记着自己的盯的人是第几个到终点，最后再和老师的计时器对比得到完成时间。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈也是线程私有，每个方法执行的时候，虚拟机都会创建一个栈，用来存放这个方法相关的临时变量，操作数等。在 IDEA IDE 中，调试模式下，控制台左侧会有一个 Frame 的区域，展示流程中的方法栈。</p><p>栈主要用来存放基本数据类型及对象引用（地址）。</p><ol><li>boolean</li><li>byte</li><li>char</li><li>short</li><li>int</li><li>float</li><li>double</li><li>long</li></ol><p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stack）与虚拟机栈类似，不过本地方法栈是为本地方法（Native Method）服务的，虚拟机栈是执行字节码服务的。</p><h3 id="编译期与运行期"><a href="#编译期与运行期" class="headerlink" title="编译期与运行期"></a>编译期与运行期</h3><p>编译期：</p><blockquote><p>指把源码交给编译器生成计算机可执行文件的过程。在 Java 中即把 .java 文件编译成 .class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。</p></blockquote><p>运行期：</p><blockquote><p>是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来，在Java中把磁盘中的代码放到内存中就是类加载过程，类加载是运行期的开始部分。</p></blockquote><p>编译期分配内存并不是说在编译期就把程序所需要的空间在内存中分配好，而是说在编译期生成的代码中产生一些指令，在运行代码时通过这些指令把程序所需的内存分配好。只不过在编译期的时候就知道<em>分配的大小</em>，并且知道这些<em>内存的位置</em>。</p><p>而运行期分配内存是指只有在运行期才确定内存的大小、存放的位置。</p><p>参考：<a href="https://www.cnblogs.com/myitnews/p/11457649.html">编译期与运行期 </a></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆由所有线程共享，几乎所有的 Java 对象和数组都在这里分配内存，所以该区域也是垃圾回收的主要区域。</p><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区，以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变 Java 堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p><p>Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p><p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的(通过参数 <strong>-Xmx</strong> 和 <strong>-Xms</strong> 设定)。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出 OutOfMemoryError 异常。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区和堆一样，是各个线程共享的内存区域，用于存储被虚拟机加载的类型信息、常量、静态变量等数据。</p><p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的 确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p>深入理解 intern() 方法：<a href="https://www.runoob.com/java/java-string-intern.html">Java intern() 方法</a></p><h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>当虚拟机遇到一条 new 指令时，先检查这个指令能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被<em>加载</em>、<em>解析</em>、<em>初始化</em>过，如果有，则分配内存，否则会先加载这个类。</p><p>为对象分配内存时，如果堆中的内存是规整的（使用过的与未使用的内存区域是分开的），则在未使用的区域中划分一块确定大小的内存区域（指针移动所需分配内存大小的距离）；如果内存区域使用过的和空闲的未分开，则需要维护一个列表来管理未划分和已划分的内存。</p><p>Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理(Comp act)的能力决定。</p><p>分配内存时，还需要考虑并发的问题，可能会出现分配内存的过程中又将此内存区域分配给了另一个对象的问题。一种解决办法是对分配内存的操作进行<strong>同步处理</strong>，另一种方法是<strong>为每个线程在堆中预先分配一块内存，即本地线程分配缓冲（TLAB）</strong>。虚拟机是否使用 TLAB ，可以通过参数：**-XX:+&#x2F;-UseTLAB** 设置。</p><p>内存分配完成之后需要对对象进行初始化，将分配到的除对象头信息外的内存空间初始化为零值。</p><p>还需要对对象进行必要的设置（元数据信息、对象哈希码、所属类等）。</p><p>✅ 内存分配已经全部完成，在内存中已经产生一个新对象了，后面还需要根据构造函数来对这个对象进行初始化，执行完构造函数之后，这个对象就完整了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ESP8266和心知天气的小电视</title>
      <link href="/2022/01/22/f591413767a4/"/>
      <url>/2022/01/22/f591413767a4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上周末无意中在某个短视频中看到一个基于 ESP8266 开发的小电视，萌萌的外观，勾起了我的兴趣。大概半年多以前我也买了一个esp芯片，还有一块 0.96 寸 oled 屏，也有同样的想法要做一个，忘了什么原因一直闲置在一边。想着资源利用，又把这个事情提了上来。坑比想象中要多，从周六早上搞到现在，每天晚上弄到一点钟，终于弄完了，动手能力太差了。把过程记录一下，供以后参考。</p></blockquote><span id="more"></span><h2 id="VSCODE-ESP8266-开发环境搭建"><a href="#VSCODE-ESP8266-开发环境搭建" class="headerlink" title="VSCODE ESP8266 开发环境搭建"></a>VSCODE ESP8266 开发环境搭建</h2><p>网上有很多资料，给 VSCODE 安装一些插件、添加相关配置即可。</p><h2 id="WiFi连接"><a href="#WiFi连接" class="headerlink" title="WiFi连接"></a>WiFi连接</h2><p>在代码里写死 SSID 和 密码的话，WiFi 连接比较简单，没几行代码。在 <a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-tips/wifimanager/">ESP8266自动配网 – WiFiManager库使用说明</a> 中看到可以利用 WiFiManager 来进行配置，但是不知道是不是我安装的库不对，按照教程写完代码编译会报错，没有继续尝试。</p><pre><code class="c">#include &lt;ESP8266WiFi.h&gt;// WiFi设置const char *ssid = &quot;My-WiFi-Name&quot;;const char *password = &quot;password&quot;;void setup()&#123;    Serial.begin(9600);    connectWifi();    delay(2000);&#125;void loop() &#123;&#125;void connectWifi()&#123;    // WiFiManager wifiManager;    // wifiManager.autoConnect(&quot;AutoConnectAP&quot;, &quot;12345678&quot;);    WiFi.begin(ssid, password);    while (WiFi.status() != WL_CONNECTED)    &#123;        delay(500);        Serial.print(&quot;.&quot;);    &#125;    Serial.print(&quot;IP address:    &quot;);    Serial.println(WiFi.localIP());&#125;</code></pre><h2 id="oled-屏幕连接"><a href="#oled-屏幕连接" class="headerlink" title="oled 屏幕连接"></a>oled 屏幕连接</h2><p>这里选择了 SSD1306 这个库，所有的输出要在屏幕初始化完成之后进行。前两天优化代码的时候，把顺序弄反了，结果屏幕就是通电的时候亮一下然后黑屏，还以为屏幕不小心烧坏了。</p><p>库的例子程序里 SCREEN_ADDRESS 这个值默认为 0x3D，如果例子程序都跑不起来的，可以改成 0x3C 试一下。还有检测这个地址值的程序，参考 <a href="https://www.cnblogs.com/cuianbing/p/14376811.html">ESP8266驱动I2C-初始化oled显示屏</a></p><pre><code class="c">#include &lt;Wire.h&gt;#include &lt;Adafruit_GFX.h&gt;#include &lt;Adafruit_SSD1306.h&gt;#define SCREEN_WIDTH 128#define SCREEN_HEIGHT 64#define OLED_RESET -1       // Reset pin # (or -1 if sharing Arduino reset pin)#define SCREEN_ADDRESS 0x3C ///&lt; See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);void setup()&#123;    Serial.begin(9600);    // 显示器连接    if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))    &#123;        Serial.println(F(&quot;SSD1306 allocation failed&quot;));        for (;;)            ;    &#125;    delay(2000);    printMessage(&quot;Display initialed!&quot;);    delay(2000);&#125;</code></pre><h2 id="在屏幕上输出"><a href="#在屏幕上输出" class="headerlink" title="在屏幕上输出"></a>在屏幕上输出</h2><p>SSD1306 库的使用方法可以参考 <a href="https://www.cnblogs.com/cuianbing/p/14376811.html">ESP8266驱动I2C OLED显示屏</a> 这篇博客的内容，写得非常详细且实用。常用的输出文字、描点、画线以及各种图形的函数都有例子。</p><p>一个输出初始化信息的例子：</p><pre><code class="c">void printMessage(char *message)&#123;    display.clearDisplay();    display.setTextSize(1);    display.setTextColor(WHITE);    display.setCursor(0, 25);    display.println(message);    display.display();    delay(2000);&#125;</code></pre><h2 id="字体及文字大小的控制"><a href="#字体及文字大小的控制" class="headerlink" title="字体及文字大小的控制"></a>字体及文字大小的控制</h2><p>用了好久才发现原来 SSD1306 库不支持中文输出，要输出中文必须用 drawBitmap(x, y, bitmap, size, size, color) 这个函数，考虑到取字模的话会非常费时费力，于是又尝试使用 U8g2 库，U8g2 支持常见的一小部分中文，遗憾的是，不支持调整字体大小，没办法最后只能继续使用 SSD1306，然后取字模。</p><p>字体颜色必须要设置，精简代码的时候以为默认字体颜色就是白色，于是将设置颜色的代码去掉，结果背景色也是黑色，字体也是黑色，导致屏幕上看不到任何显示。</p><p>生成字模有很多软件可以使用，但是都需要下载安装，比较麻烦。花了一些时间找到一个不错的字母网站：<a href="https://www.zhetao.com/fontarray.html">单片机-LCD-LED-OLED中文点阵生成软件</a> ，可以在线生成，复制 C 代码，不需要下载安装，免费使用，使用起来比较方便。</p><p>⚠ 如果输出字体比较小，比如 16x16 的话，最好不要选择“黑体”这类线条较粗的字体，不然会糊。</p><h2 id="关于天气-API-的选择"><a href="#关于天气-API-的选择" class="headerlink" title="关于天气 API 的选择"></a>关于天气 API 的选择</h2><p>天气 API 的选择也是一个大坑。</p><h3 id="心知天气"><a href="#心知天气" class="headerlink" title="心知天气"></a>心知天气</h3><blockquote><p>因为在“太极创客”的文章例子看到使用的是心知天气，本着代码复用的原则，也选择了心知天气。调用之后发现返回字段和例子里有差异，免费版只返回了“温度”之类的3个字段，太少不够用。有收费版可以试用15天，对于我的需求，每天调用48次就足够了，不太值得付费太多。</p></blockquote><h3 id="和风天气"><a href="#和风天气" class="headerlink" title="和风天气"></a>和风天气</h3><blockquote><p>和风天气免费版返回的字段和心知天气的收费版一样，调用频率虽然有限制但也是1分钟几十次，足有用了。但是有一个问题，就是在浏览器里 API 可以正常调用，但是在 ESP8266 里一直显示连接失败，在这个问题上卡了好久，最后选择放弃。</p></blockquote><h2 id="API-接口的端口以及-SSL"><a href="#API-接口的端口以及-SSL" class="headerlink" title="API 接口的端口以及 SSL"></a>API 接口的端口以及 SSL</h2><h3 id="80-端口和-443-端口"><a href="#80-端口和-443-端口" class="headerlink" title="80 端口和 443 端口"></a>80 端口和 443 端口</h3><p>在调用和风天气的接口的时候，发现一只连接失败。卡了好长时间才去对比浏览器请求和代码请求的区别，发现浏览器请求的端口是443，而我一直在 ESP8266 中请求连接 80 端口，所以一直连接失败。用 Telnet 连接 443 端口之后，发现可以正常连接上。</p><h3 id="和风天气-API-域名的问题"><a href="#和风天气-API-域名的问题" class="headerlink" title="和风天气 API 域名的问题"></a>和风天气 API 域名的问题</h3><p>在浏览器请求中发现两边不仅除了端口不一样，连域名也不一样，和风天气 API 文档中给的域名是 devapi.qweather.com ，而我在浏览器调试窗口中看到的是 devapi.hweather.net ，而且这两个域名在 telnet 中都能连上、在浏览器中都能正常返回，就很谜。。</p><h3 id="接口加密问题"><a href="#接口加密问题" class="headerlink" title="接口加密问题"></a>接口加密问题</h3><p>改了域名以及端口换成 443 之后，HTTP 还是显示连接失败。ESP8266 调用和风天气相关的资料不太多，在这个问题上卡了好久。</p><p>去查了 443 端口相关的资料，意识到 HTTPS SSL请求的问题，最后在和风天气的官网上看到一篇公告：<a href="https://www.qweather.com/blog/no-more-http">和风天气官方动态-不再支持非SSL接口连接</a> </p><p>尝试使用 WiFiClientSecure 去调用，也没成功。</p><p>最后放弃使用和风天气。</p><h2 id="ArduinoJson的使用"><a href="#ArduinoJson的使用" class="headerlink" title="ArduinoJson的使用"></a>ArduinoJson的使用</h2><p>调用了心知天气API后返回的数据和浏览器请求相比少了几个字段，以为是接口返回少了，所以感到很迷惑。将接口返回信息完整的打印出来发现，接口返回的数据没少。</p><pre><code class="c">void requestWeather()&#123;    WiFiClientclient;    StringreqRes = &quot;/v3/weather/now.json?key=&quot; + reqUserKey +                 +&quot;&amp;location=&quot; + reqLocation +                 &quot;&amp;language=en&amp;unit=&quot; + reqUnit;    /* 建立http请求信息 */    String httpRequest = String( &quot;GET &quot; ) + reqRes + &quot; HTTP/1.1\r\n&quot; +                 &quot;Host: &quot; + host + &quot;\r\n&quot; +                 &quot;Connection: close\r\n\r\n&quot;;    Serial.println( &quot;&quot; );    Serial.print( &quot;Connecting to &quot; ); Serial.print( host );    /* 尝试连接服务器 */    if ( client.connect( host, 80 ) )    &#123;        Serial.println( &quot; Success!&quot; );        /* 向服务器发送http请求信息 */        client.print( httpRequest );        Serial.println( &quot;Sending request: &quot; );        Serial.println( httpRequest );        /* 获取并显示服务器响应状态行 */        String status_response = client.readStringUntil( &#39;\n&#39; );        Serial.print( &quot;status_response: &quot; );        Serial.println( status_response );        /* 打印出完整的接口返回信息 */        String responsePayload = wifiClient.readString();        Serial.println( &quot;Server Response Payload: &quot; );        Serial.println( responsePayload );        /* 使用find跳过HTTP响应头 */        if ( client.find( &quot;\r\n\r\n&quot; ) )        &#123;            Serial.println( &quot;Found Header End. Start Parsing.&quot; );        &#125;        /* 利用ArduinoJson库解析心知天气响应信息 */        parseInfo( client );    &#125; else &#123;        Serial.println( &quot; connection failed!&quot; );    &#125;    /* 断开客户端与服务器连接工作 */    client.stop();&#125;</code></pre><p>就是下面这几行：</p><pre><code class="c">/* 打印出完整的接口返回信息 */String responsePayload = wifiClient.readString();Serial.println( &quot;Server Response Payload: &quot; );Serial.println( responsePayload );</code></pre><p>尝试将 ArduinoJson 的空间调大之后，解析出了全部字段：</p><pre><code class="c">const size_t capacity = JSON_ARRAY_SIZE(1) + JSON_OBJECT_SIZE(1) + 2*JSON_OBJECT_SIZE(3) + JSON_OBJECT_SIZE(6) + 230;/* 将 capacity 改为 1024 */DynamicJsonDocument doc(capacity);deserializeJson(doc, client);</code></pre><h3 id="ArduinoJson-Assistant"><a href="#ArduinoJson-Assistant" class="headerlink" title="ArduinoJson Assistant"></a>ArduinoJson Assistant</h3><p>今天晚上回来的打算好好了解一下 ArduinoJson，看到 太极创客 有专门提到这个库，Arduino 官网竟然还有一个专门根据 JSON 数据反向生成解析代码的页面：<a href="https://arduinojson.org/v6/assistant/">ArduinoJson Assistant</a>，变量自动命名，很好用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码地址：<a href="git@github.com:intfunc/weather-clock.git">weather-clock</a></p><p>花了一星期的时间，完成了本该半年之前就要完成的事情，途中遇到了许多想象不到的问题，每天晚上八九点回来一直弄到一两点，有点睡眠不足，终于明天是周末，可以多睡一会儿。</p><p>夜深人静，头脑更加清醒；</p><p>指尖跳动，键盘清脆作响；</p><p>用代码谱写最华美的乐章！</p>]]></content>
      
      
      <categories>
          
          <category> 玩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> ESP8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java本地方法</title>
      <link href="/2022/01/15/4ac95d243d69/"/>
      <url>/2022/01/15/4ac95d243d69/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在看 JDK 源码的时候，不停往方法调用链下走，会发现到了很多标注了 native 的方法的地方就停止了。</p><p>native 标注的方法是 Java 本地方法，这些方法可以由 C、C++实现。当程序无法完全用 Java 实现的时候，本地方法可以处理这种情况。</p></blockquote><span id="more"></span><p>一个简单的例子，在 java 中调 C++ 程序实现两个整数的求和。简单起见，在 Linux 平台实现。</p><h2 id="创建一个-Java-程序"><a href="#创建一个-Java-程序" class="headerlink" title="创建一个 Java 程序"></a>创建一个 Java 程序</h2><pre><code class="java">public class CalSum &#123;    static &#123;        // 这里写绝对路径，相对路径报错，未解决        System.load(&quot;/home/user/documents/java/sum/libcalsum_c.so&quot;);    &#125;        // 声明 native 方法    public native static int calSum(int a, int b);        public static void main(String[] args) &#123;        int a = 10;        int b = 20;                // 调用 C++ 实现的 native 方法求和        int sum = calSum(a, b);                System.out.println(a + &quot; + &quot; + b + &quot; = &quot; + sum);    &#125;&#125;</code></pre><h2 id="编译-CalSum-java-并生成-CalSum-h-头文件"><a href="#编译-CalSum-java-并生成-CalSum-h-头文件" class="headerlink" title="编译 CalSum.java 并生成 CalSum.h 头文件"></a>编译 CalSum.java 并生成 CalSum.h 头文件</h2><pre><code class="sh">javac CalSum.javajavah CalSum</code></pre><p>执行完 javah 命令后，会在当前目录下生成一个 CalSum.h 头文件，文件内容如下：</p><pre><code class="c++">/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class CalSum */#ifndef _Included_CalSum#define _Included_CalSum#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* * Class:     CalSum * Method:    calSum * Signature: (II)I */JNIEXPORT jint JNICALL Java_CalSum_calSum  (JNIEnv *, jclass, jint, jint);#ifdef __cplusplus&#125;#endif#endif</code></pre><h2 id="在当前目录下创建-CalSum-c-文件并用-C-实现求和功能"><a href="#在当前目录下创建-CalSum-c-文件并用-C-实现求和功能" class="headerlink" title="在当前目录下创建 CalSum.c 文件并用 C++ 实现求和功能"></a>在当前目录下创建 CalSum.c 文件并用 C++ 实现求和功能</h2><pre><code class="c++">#include&lt;jni.h&gt;#include &quot;CalSum.h&quot;JNIEXPORT jint JNICALL Java_CalSum_calSum(JNIEnv *env, jclass object, jint a, jint b) &#123;    jint sum = a + b;    return sum;&#125;</code></pre><h2 id="生成-libcalsum-c-so"><a href="#生成-libcalsum-c-so" class="headerlink" title="生成 libcalsum_c.so"></a>生成 libcalsum_c.so</h2><p><code>gcc CalSum.c CalSum.h -I /opt/openjdk-8u262/include -I /opt/openjdk-8u262/include/linux -fPIC -shared -o libcalsum_c.so</code></p><p>:warning: 这里主要是注意需要在 jdk 安装路径下找到 <strong>jni.h</strong> 和 <strong>jni_md.h</strong> 两个头文件的路径，然后添加编译命令中。</p><h2 id="运行-CalSum-程序得到-C-程序返回的结果"><a href="#运行-CalSum-程序得到-C-程序返回的结果" class="headerlink" title="运行 CalSum 程序得到 C++ 程序返回的结果"></a>运行 CalSum 程序得到 C++ 程序返回的结果</h2><p><code>java CalSum</code></p><p>输出：</p><pre><code class="bash">❯ java CalSum10 + 20 = 30</code></pre><h2 id="所有流程总结"><a href="#所有流程总结" class="headerlink" title="所有流程总结"></a>所有流程总结</h2><ol><li>创建带有 native 标识的方法，并从 Java 中调用它</li><li>Java 编译器生成 .class 字节码文件</li><li>C&#x2F;C++ 生成链接库</li><li>运行程序，执行字节码</li><li>执行到loadLibary或load调用的时候，添加一个 .so文件到这个进程中</li><li>执行到native方法的时候，通过方法签名，在已打开的.so文件中进行搜索</li><li>如果链接库内有对应方法，就会被执行，否则程序崩溃</li></ol><p>参考：</p><p><a href="https://www.cnblogs.com/longfurcat/p/9830129.html">详解 JNI（Java Native Interface）（一）</a></p><p><a href="https://www.cnblogs.com/longfurcat/p/9856595.html">详解 JNI（Java Native Interface）（二）</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 本地方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Hexo博客部署到服务器</title>
      <link href="/2022/01/14/6a21d3472901/"/>
      <url>/2022/01/14/6a21d3472901/</url>
      
        <content type="html"><![CDATA[<blockquote><p>去年看到 racknerd 做活动，1vCore 512M 15G SSD年费才8美元，于是就买了一个，性能太低没派上什么用场。GitHub 访问速度有点慢，于是就想着把博客部署到这个机器上去，记录一下操作流程。</p></blockquote><h2 id="1⃣️-静态文件上传"><a href="#1⃣️-静态文件上传" class="headerlink" title="1⃣️ 静态文件上传"></a>1⃣️ 静态文件上传</h2><p>✅ 将 blog&#x2F;public目录压缩 public.zip</p><p>✅ scp public.zip user@remote_vps:~&#x2F;document</p><p>✅ 解压 public.zip</p><h2 id="2⃣️-Nginx-的安装和配置"><a href="#2⃣️-Nginx-的安装和配置" class="headerlink" title="2⃣️ Nginx 的安装和配置"></a>2⃣️ Nginx 的安装和配置</h2><p>✅ <code>sudo apt update&amp;&amp;sudo apt install nginx</code> 安装 Nginx</p><p>✅ <code>sudo service nginx stop</code></p><p>✅ <code>sudo vim /etc/nginx/nginx.conf</code></p><p>✅ 配置好 用户名，root，service_name，index，error_page，其中 root 只想静态文件目录</p><p>✅ <code>service nginx restart</code></p><p>✅ done, enjoy it !</p>]]></content>
      
      
      <categories>
          
          <category> 博客维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机(1)-编译openjdk</title>
      <link href="/2022/01/12/97295980f61b/"/>
      <url>/2022/01/12/97295980f61b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>想要窥探虚拟机内部的实现原理，最直接的一条路径就是编译一套自己的 jdk，通过阅读和调试 jdk 源码来了解 java 技术体系的运作，虽然这样门槛会高一点，但是肯定会比阅读各种文章、书籍来得更加贴近本质。此外，java 中许多方法都是 Native 的，在了解这些方法运作的过程都需要调试虚拟机代码的能力。</p></blockquote><span id="more"></span><h2 id="版本控制工具-Mecurial-常见命令"><a href="#版本控制工具-Mecurial-常见命令" class="headerlink" title="版本控制工具 Mecurial 常见命令"></a>版本控制工具 Mecurial 常见命令</h2><pre><code class="bash"># 设置用户名和邮箱hg config --edit# 初始化仓库hg init# 查看项目状态hg st# 将文件添加到版本控制hg add file_name# 提交修改hg ci -m &quot;commit comment&quot;# 初次提交hg push --new-branch# 正常提交hg push -b branch_name# 新建分支hg branch branch_name# 查看当前分支hg branch# 查看所有分支hg branches# 切换分支hg update new_branch# 合并分支hg merge branch# 更新hg pull# 回退文件hg revert file_name# 全部回退hg revert -a</code></pre><h2 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h2><p>1、浏览器打开 <a href="http://hg.openjdk.java.net/jdk8/jdk8">OpenJDK &#x2F; jdk8 &#x2F; jdk8</a> ，因为种种原因，可能会比较慢；</p><p>2、点击页面左侧的 browse ，页面会列出 openjdk 的目录结构；</p><p>3、点击页面左边菜单栏 zip 👈 ，就能下载到源码的压缩包；</p><p>4、将源码压缩包解压缩到 jdk8-source 目录下。</p><h2 id="配置本地-JDK"><a href="#配置本地-JDK" class="headerlink" title="配置本地 JDK"></a>配置本地 JDK</h2><p>要拥有梯子，你必须要先有个梯子；要编译 JDK ，必须要有一个启动 JDK（Boot JDK）。本地 JDK 版本的与要编译的 JDK 版本有关系，略过了。</p><h2 id="编译前准备"><a href="#编译前准备" class="headerlink" title="编译前准备"></a>编译前准备</h2><p>1、添加源码目录中的 .configure 执行权限；</p><p>2、执行 .&#x2F;configure ，不出意外的话会报错，只能一个一个消灭这些错误，不过百度一下应该都能找到答案，要有耐心。</p><p>3、成功：</p><pre><code>configure: creating /Users/chenxii/Documents/Java/compile-openjdk/jdk8-source/build/macosx-x86_64-normal-server-release/config.statusconfig.status: creating /Users/chenxii/Documents/Java/compile-openjdk/jdk8-source/build/macosx-x86_64-normal-server-release/spec.gmkconfig.status: creating /Users/chenxii/Documents/Java/compile-openjdk/jdk8-source/build/macosx-x86_64-normal-server-release/hotspot-spec.gmkconfig.status: creating /Users/chenxii/Documents/Java/compile-openjdk/jdk8-source/build/macosx-x86_64-normal-server-release/bootcycle-spec.gmkconfig.status: creating /Users/chenxii/Documents/Java/compile-openjdk/jdk8-source/build/macosx-x86_64-normal-server-release/compare.shconfig.status: creating /Users/chenxii/Documents/Java/compile-openjdk/jdk8-source/build/macosx-x86_64-normal-server-release/spec.shconfig.status: creating /Users/chenxii/Documents/Java/compile-openjdk/jdk8-source/build/macosx-x86_64-normal-server-release/Makefileconfig.status: creating /Users/chenxii/Documents/Java/compile-openjdk/jdk8-source/build/macosx-x86_64-normal-server-release/config.h====================================================      * JVM variants:   server* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64Tools summary:* Boot JDK:       openjdk version &quot;1.8.0_292&quot; OpenJDK Runtime Environment (Zulu 8.54.0.21-CA-macosx) (build 1.8.0_292-b10) OpenJDK 64-Bit Server VM (Zulu 8.54.0.21-CA-macosx) (build 25.292-b10, mixed mode)  (at /opt/java/zulu8.54.0.21-ca-jdk8.0.292-macosx_x64)* C Compiler:      version  (at /usr/bin/gcc)* C++ Compiler:    version  (at /usr/bin/g++)Build performance summary:* Cores to use:   4* Memory limit:   16384 MB* ccache status:  installed, but disabled (version older than 3.1.4)Build performance tip: ccache gives a tremendous speedup for C++ recompilations.Build performance summary:* Cores to use:   4* Memory limit:   16384 MB* ccache status:  installed, but disabled (version older than 3.1.4)Build performance tip: ccache gives a tremendous speedup for C++ recompilations.You have ccache installed, but it is a version prior to 3.1.4. Try upgrading.</code></pre><h3 id="常见错误汇总"><a href="#常见错误汇总" class="headerlink" title="常见错误汇总"></a>常见错误汇总</h3><p>1、configure: error: GCC compiler is required. Try setting –with-tools-dir.</p><blockquote><p>注释掉 jdk8-source&#x2F;common&#x2F;autoconf&#x2F;generated-configure.sh 中相关的地方，直接搜  GCC compiler is required ，然后将出现的行都用 # 注释掉。</p></blockquote><p>2、error: could not found freetype</p><blockquote><p>1、安装 freetype</p><p>2、.&#x2F;configure -with-freetype-include&#x3D;&#x2F;usr&#x2F;local&#x2F;include&#x2F;freetype2 —with-freetype-lib&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;</p></blockquote><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>1、执行 <code>chmod a+x get_source.sh</code></p><p>2、执行 <code>./get_source.sh</code></p><p>2、执行 <code>make all</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jdk </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机-走进Java</title>
      <link href="/2022/01/11/8964752fc0df/"/>
      <url>/2022/01/11/8964752fc0df/</url>
      
        <content type="html"><![CDATA[<blockquote><p>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</p></blockquote><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java不仅是一门编程语言，它还是一个由一系列计算机软件和规范组成的技术体系，这个体系提供了完整的用于开发和跨平台部署的支持环境，广泛应用于嵌入式体系、移动终端、企业服务器和大型机等场合。</p><p>Java的优点：</p><ul><li>面向对象</li><li>跨平台</li><li>安全的内存管理和访问机制</li><li>完善的程序接口</li></ul><h3 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h3><p>JDK：</p><ul><li>Java语言</li><li>Java虚拟机</li><li>Java类库</li></ul><p>JRE：</p><ul><li>Java类库</li><li>Java虚拟机</li></ul><h3 id="Java的历史"><a href="#Java的历史" class="headerlink" title="Java的历史"></a>Java的历史</h3><p>以 Oracle 收购 Sun 为分界点，分为两个时期。前期在 Sun 公司掌舵之下，Java取得巨大成功，但是语言演进缓慢；Oracle 主导 Java 之后，Java 发展速度加快。</p><h3 id="Java的虚拟机家族"><a href="#Java的虚拟机家族" class="headerlink" title="Java的虚拟机家族"></a>Java的虚拟机家族</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客备份</title>
      <link href="/2022/01/09/efcc41a82c3b/"/>
      <url>/2022/01/09/efcc41a82c3b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前的博客都是在笔记本上，考虑到大多数时间在用台式机，所以研究了一下同时在笔记本上和台式机上都可以更新博客的方法，中途遇到一些小问题，特此记录一下。</p></blockquote><span id="more"></span><h2 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h2><ol><li><p>在 GitHub 的博客仓库下新建 backup 分支</p><p><code>git checkout -b backup</code></p></li><li><p>删除 themes&#x2F;Butterfly 下的 .git 文件夹，如果还有其他主题的话，同样删除 .git 文件夹</p></li><li><p>在博客根目录下初始化 git 仓库</p></li><li><p>关联到 backup 分支</p><pre><code class="bash">git remote add origin https://xxx/xxx.github.io.gitgit fetchgit checkout -n backup</code></pre></li><li><p>新建 .gitignore 文件，忽略掉 public db.json mode_modules</p><pre><code class="log">.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre></li><li><p>从博客根目录推送到 GitHub backup 分支</p><pre><code class="bash">git add .git commit -m &quot;first backup&quot;git push origin backup</code></pre></li></ol><p>到这里，就备份完成了。</p><h2 id="另一台机器上初始化"><a href="#另一台机器上初始化" class="headerlink" title="另一台机器上初始化"></a>另一台机器上初始化</h2><p>在另一台机器上安装好 node.js 和 hexo后：</p><ol><li><p>关联到 backup 分支</p><pre><code class="bash">cd bloggit initgit remote add origin https://xxx/xxx.github.io.gitgit fetchgit checkout backup</code></pre></li><li><p>初始化博客</p><pre><code class="bash">npm install</code></pre></li><li><p>安装完成后就可以正常使用了</p><pre><code class="bash">hexo cleanhexo g&amp;&amp;hexo d</code></pre></li></ol><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="git提示输入密码"><a href="#git提示输入密码" class="headerlink" title="git提示输入密码"></a>git提示输入密码</h3><p>提示输入密码，但是现在GitHub已经不支持密码验证了，所以只能重新生成一个 ssh-key，放到GitHub的ssh key里面，将https协议使用 git协议再重新推送。</p><h3 id="Win10-cmd输入中文无法显示"><a href="#Win10-cmd输入中文无法显示" class="headerlink" title="Win10 cmd输入中文无法显示"></a>Win10 cmd输入中文无法显示</h3><p>新建文章的时候，发现 cmd 输入中文会变成一个问号，无法正常显示。看了一些网上执行 <code>chcp 65001</code> ，或者是修改注册表的方式，都没有解决，暂时没有解决方案。</p><h3 id="Typora开始收费！！"><a href="#Typora开始收费！！" class="headerlink" title="Typora开始收费！！"></a>Typora开始收费！！</h3><p>新建了一篇测试文章后，本能的打开 Typora ，但是提示该 beta 版本已过期，请安装使用更新版本。还觉得奇怪，为啥不直接让我升级，还要重新安装一个。打开官网下载页面发现有一个金额，还以为是捐赠，可是有一个大大的 purchase 字样，才知道原来已经开始收费了。用了三四年了，目前用过的最好的 markdown 编辑器。</p><p>目前安装这个版本可以试用 15 天，本来想着入正，可以还不明确是续费制，还是买断制，先观望着吧，同时也找找其他替代品。</p>]]></content>
      
      
      <categories>
          
          <category> 博客维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo大小写问题导致分类和标签访问404</title>
      <link href="/2022/01/08/069379041ce6/"/>
      <url>/2022/01/08/069379041ce6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在配置 Hexo Butterlfy 主题的时候，无意间发现通过文章分类或者标签点进具体文章时会不确定性的404，本地正常，但是在 GitHub 上就不找不到页面，研究了好久才解决这个问题。</p></blockquote><span id="more"></span><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>这两天一直在弄 Hexo 博客，研究怎么把分类作为博客的菜单，研究了好几天晚上，终于弄好了。把本地修改传到 GitHub 之后，发现通过博客分类也就是菜单点进文章会404，但是本地又是没有问题的。想找一下网上有没有人有类似的经历，但是没发现什么解决办法。第二天晚上才找到一篇文章，提到了相同的问题。</p><p><a href="https://www.yikakia.com/hexo-%E6%9B%B4%E6%96%B0tag%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99%E5%90%8E%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF/">hexo- 更新 tag 的大小写后标签页出现错误</a> </p><p>原来是因为最开始的时候，我建立标签页面的时候用的命令是 <code>hexo new page &quot;Tags&quot;</code>，大写的 Tags，传到了 GitHub 之后，远程仓库里的文件夹名称就是 Tags，当我本地删了这个 Tags 文件夹再重新生成标签页面的时候用的命令时： <code>hexo new page &quot;tags&quot;</code>，于是本地 public 下的标签文件夹名称是 tags，再  hexo d 发布的时候，git 还是认为 Tags 文件夹和 tags 文件夹是同一个，所以远程仓库里的文件夹名称依然是 Tags，依然只能通过 <a href="https://xxx/Tags/xx">https://xxx/Tags/xx</a> 访问，如果换成 <a href="https://xxx/tags/xx">https://xxx/tags/xx</a> 就会出现404的现象。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最终按照文章里的方法：</p><ol><li>进入到 blog&#x2F;.deploy 目录下</li><li>编辑 config 文件，设置 ignorecase &#x3D; false 后保存退出</li><li>清空 .deploy_git 目录</li><li>重新 hexo g&amp;&amp;hexo d 发布，等1分钟刷新页面即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客维护 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell学习笔记</title>
      <link href="/2021/09/23/953b0bfeaae6/"/>
      <url>/2021/09/23/953b0bfeaae6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这段时间工作中需要写些Spark大数据脚本，用到了Shell脚本，基本都是靠抄前人的代码，就是替换一下SQL，写完了有时候也有点懵🤔️。好久之前就想好好学一下sh脚本，一直没有时间💦，这次要认真学完💪</p></blockquote><span id="more"></span><h2 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h2><pre><code class="bash">#!/bin/bash:&lt;&lt; EOF注释1注释2EOFecho &quot;Hello world!&quot;</code></pre><p>添加执行权限：<code>chmod +x start.sh</code> 后执行脚本：<code>./start.sh</code></p><h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><h3 id="变量定义和操作"><a href="#变量定义和操作" class="headerlink" title="变量定义和操作"></a>变量定义和操作</h3><ul><li>字母A-Z ➕ 数字🔢 ➕ 下划线_</li><li>不能以数字开头、不能包含bash关键字⚠️</li></ul><pre><code class="bash">username=&quot;Bob&quot;echo &quot;username is \&quot;$&#123;username&#125;\&quot;&quot;</code></pre><ul><li>变量赋值等号两边不能有空格</li></ul><p><em>单引号字符串会原样输出，双引号可以转义字符、读取变量</em></p><ul><li><p>使用readonly指定只读变量，只读变量不能被修改</p></li><li><p>使用unset删除变量</p></li></ul><pre><code class="bash">#!/bin/bashreadonly TEN=10username=&quot;Bob&quot;echo &quot;username的值为：\&quot;$&#123;username&#125;\&quot;&quot;echo &quot;TEN is $&#123;TEN&#125;&quot;</code></pre><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><ul><li>字符串长度</li></ul><pre><code class="bash">username=&quot;John&quot;echo &quot;length is $</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT使用入门</title>
      <link href="/2021/08/26/68ca4f1d95cd/"/>
      <url>/2021/08/26/68ca4f1d95cd/</url>
      
        <content type="html"><![CDATA[<p>无意间了解到ESP32和树莓派之类的电子产品还可以使用消息队列MQTT来接入网络中，感觉很新奇，于是尝试着学习了一下MQTT的使用。记录一下MQTT服务器的搭建过程备忘📝</p><p>参考文章: <a href="https://blog.csdn.net/ssj925319/article/details/112059117">详介 MQTT 服务器的搭建与客户端连接</a></p><span id="more"></span><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p><a href="https://www.emqx.com/zh/downloads?product=broker">EMQ X 开源版 Docker</a></p><p>1、获取Docker镜像🌊🐳🌊</p><pre><code class="shell">docker pull emqx/emqx:4.3.7</code></pre><p>2、启动Docker🐳容器📦</p><pre><code class="shell">docker run -d --name emqx -p 1883:1883 -p 8081:8081 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx:4.3.7</code></pre><p>3、登陆Dashboard🪂</p><p><a href="http://localhost:18083/">登陆到MQ后台</a></p><p>初始账号: admin   初始密码: public</p><p>后台页面📃: </p><p><img src="https://images2.imgbox.com/8d/9a/jVms2Jxx_o.png" alt="EMQX后台页面"></p><p>1、在【设置⚙️】页面可以设置语言为中文</p><p>2、在【插件🔌】模块开启全部插件</p><p>3、在【主题🎨】页面可以新建需要监控的Topic</p><p><img src="https://images2.imgbox.com/35/46/pqk5cfs0_o.png" alt="主题页面可以新建需要监控的Topic"></p><p>4、在【客户端】-【订阅列表】可以新订阅主题，这个藏得比较深，找了好久没有找到💦</p><h2 id="客户端测试"><a href="#客户端测试" class="headerlink" title="客户端测试"></a>客户端测试</h2><p>1、<a href="http://www.jensd.de/apps/mqttfx/1.7.1/">客户端MQTT.fx下载</a> ，支持Linux、MacOS和Windows💻</p><p>2、下载后直接安装。</p><p>3、安装后打开软件，点击齿轮⚙️，设置Broker Address，这里是本机💻 127.0.0.1，端口为 1883，ClientID点击生成直接随机生成一个，可以配置一下User Credential里的用户名，点击Connect直接连接。</p><p>4、在Public页面可以新建主题和在选定的主题下发送消息，在Subscribe页面可以订阅主题，接受选定主题的消息👀</p><p><img src="https://images2.imgbox.com/d5/9e/8QAc95IS_o.png" alt="创建主题及发送消息"></p><p><img src="https://images2.imgbox.com/29/71/714RSq4U_o.png" alt="订阅主题"></p><p>在后台可以看到相关记录📝</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQTT </tag>
            
            <tag> IoT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop入门-找最高气温</title>
      <link href="/2021/08/22/161238b85a63/"/>
      <url>/2021/08/22/161238b85a63/</url>
      
        <content type="html"><![CDATA[<p>上个月参加了一个Spark的培训📒，由于没有大数据基础，基本什么也没听懂。前两周买了《Hadoop权威指南》、《Hive编程指南》📚想认真学一下大数据相关的知识。结果第一个气象数据🌡的例子就卡了好久，今天研究了一下，记录📝一下。</p><span id="more"></span><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>由于美国🇺🇸气象中心的数据下载比较慢，下载下来之后还要预处理，比较麻烦。索性自己写✍🏻一个脚本生成一个有格式的最终想要的文件📃，Python脚本如下：</p><pre><code class="python">#!/usr/bin/env python3# _*_coding=utf8_*_import randomimport datetime# 开始年份start = 1900# 结束年份end = 1950# 生成文件路径file_path = &quot;/Users/chenxii/Documents/BigData/climate-data/&quot;# 生成随机温度，-50摄氏度到50摄氏度，保留一位小数def generate_temperature():    temp = (random.random() - 0.5) * 100    temp = int(temp * 10) / 10    if temp &gt; 0:        return &quot;+&quot; + str(temp)    else:        return temp# 生成温度文件，所有年份的温度放在一个文件中def generate_file1(start_year, end_year, save_path):    file_name = &#39;temp.txt&#39;    file = open(save_path + file_name, &#39;w&#39;)    for year in range(start_year, end_year):        date = datetime.date(int(year), 1, 1)        end_date = datetime.date(int(year), 12, 31)        while date &lt;= end_date:            temp = generate_temperature()            file.write(str(date) + &quot; &quot; + str(temp) + &#39;\n&#39;)            date += datetime.timedelta(days=1)    file.flush()    file.close()if __name__ == &#39;__main__&#39;:    # generate_file(start, end, file_path)    generate_file1(start, end, file_path)    </code></pre><p>保证路径存在，直接用 python 命令运行脚本即可，生成的数据格式为：</p><pre><code>1900-01-20 +11.8</code></pre><p>每天一条数据，第0-4位是年份，第11位为零上或零下的标识，第12位到结尾为气温值。0的时候没有 ‘+’ 或 ‘-‘ 标识。</p><p>用 <code>hdfs dfs -put temp.txt /user/hadoop/climate/temp.txt</code> 将文件上传到 hdfs 中。</p><h2 id="Java程序编写"><a href="#Java程序编写" class="headerlink" title="Java程序编写"></a>Java程序编写</h2><p>需要新建一个Maven项目，然后打成jar包上传到虚拟机上，代码如下：</p><pre><code class="java">package finqo.hadoop;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Mapper;import java.io.IOException;/** * @author zhulongkun20@163.com * @since 2021/8/22 12:41 PM */public class MaxTemperatureMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123;    @Override    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;        String line = value.toString();        String year = line.substring(0, 4);        int temperature = 0;        if (&#39;+&#39; == line.charAt(11) || &#39;-&#39; == line.charAt(11)) &#123;            double tmp = Double.parseDouble(line.substring(12)) * 10;            temperature = (int) tmp;        &#125;        context.write(new Text(year), new IntWritable(temperature));    &#125;&#125;</code></pre><pre><code class="java">package finqo.hadoop;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Reducer;import java.io.IOException;/** * @author zhulongkun20@163.com * @since 2021/8/22 1:09 PM */public class MaxTemperatureReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123;    @Override    protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context)            throws IOException, InterruptedException &#123;        int maxValue = Integer.MIN_VALUE;        for (IntWritable value : values) &#123;            maxValue = Math.max(maxValue, value.get());        &#125;        context.write(key, new IntWritable(maxValue));    &#125;&#125;</code></pre><pre><code class="java">package finqo.hadoop;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.conf.Configured;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.util.Tool;import java.io.IOException;/** * @author zhulongkun20@163.com * @since 2021/8/22 1:15 PM */public class MaxTemperature extends Configured implements Tool &#123;    public int run(String[] strings) throws Exception &#123;        return 0;    &#125;    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;        if (args.length != 2) &#123;            System.err.println(&quot;Usage: MaxTemperature &lt;input path&gt; &lt;output path&gt;&quot;);            System.exit(-1);        &#125;        Configuration conf = new Configuration();        conf.set(&quot;mapred.jar&quot;, &quot;flinqo-hadoop-1.0.jar&quot;);        Job job = Job.getInstance(conf);        job.setJarByClass(MaxTemperature.class);        job.setJobName(&quot;Max temperature&quot;);        FileInputFormat.addInputPath(job, new Path(args[0]));        FileOutputFormat.setOutputPath(job, new Path(args[1]));        job.setMapperClass(MaxTemperatureMapper.class);        job.setReducerClass(MaxTemperatureReducer.class);        job.setOutputKeyClass(Text.class);        job.setOutputValueClass(IntWritable.class);        System.exit(job.waitForCompletion(true) ? 0 : 1);    &#125;&#125;</code></pre><p><code>mvn package</code>打成jar包后上传，pom文件需要添加：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;flinqo.hadoop&lt;/groupId&gt;    &lt;artifactId&gt;flinqo-hadoop&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;            &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;            &lt;version&gt;3.2.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;            &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;            &lt;version&gt;3.2.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;            &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;            &lt;version&gt;3.2.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.4.4&lt;/version&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;goals&gt;                            &lt;goal&gt;repackage&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>不添加的话，jar运行的时候或报错，找不到主类。</p><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>运行命令：</p><pre><code class="sh">hadoop jar flinqo-hadoop-1.0.jar /user/hadoop/climate/temp.txt /user/hadoop/result</code></pre><p>运行结束后查看结果：</p><pre><code class="sh">hdfs dfs -cat /user/hadoop/result</code></pre><p>结果：</p><pre><code>19004991901495190249919034981904493190549919064981907494190849919094971910499191149719124991913493191449819154971916497191749919184931919498192049919214991922499192349719244991925498192649919274991928499192949819304981931499193249719334951934499193549819364981937498193849619394971940495194149919424971943499194449919454991946499194749919484991949497</code></pre><p>因为放大了10倍，所以数值比较大。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记Vue-proxyTable跨域代理配置失效问题</title>
      <link href="/2021/06/22/b1fbbadd9381/"/>
      <url>/2021/06/22/b1fbbadd9381/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上周周四和周五开发中遇到一个文件批量上传的需求，单纯的将文件上传到服务器、然后加上查询和删除功能。之前做过类似功能，但是没回去看代码，结果卡了一天。Element一次选择多个文件上传只会调用一次且是第一个文件上传后调用一次 on-success 函数，踩了坑耽误了开发进度。计划周末去加班的，但是因为这几天疫情严重，没有48h核酸检测不让进楼，没办法只能在家里新建一个demo研究一下，结果一开始就卡在了代理配置上。</p></blockquote><span id="more"></span><h2 id="代理的配置"><a href="#代理的配置" class="headerlink" title="代理的配置"></a>代理的配置</h2><p>我用的是vue-cli + webpack + Element 的方式，配置在 <code>config/index.js</code>,代理配置如下：</p><pre><code class="json">proxyTable: &#123;    proxy: &#123;        &#39;/&#39;: &#123;            target: &#39;http://localhost:8081/&#39;,            changeOrigin: true,            pathRewrite: &#123;                &#39;^/&#39;: &#39;&#39;            &#125;        &#125;    &#125;&#125;</code></pre><p>后台地址是：localhost:8081，浏览器直接访问后台地址能正常返回数据。但是通过axios访问却一直报404错误。</p><pre><code class="javascript">sendAction() &#123;    this.$axios.get(&#39;/name&#39;).then((res) =&gt; &#123;        console.log(&#39;res: &#39;, res)    &#125;)&#125;</code></pre><br><h2 id="各种尝试"><a href="#各种尝试" class="headerlink" title="各种尝试"></a>各种尝试</h2><p>周天花了一天研究这个问题，没找到解决方案，记得上次一个项目里也是遇到同样的问题，花了好几个晚上的时间都没解决，噩梦又来了，内心有点退缩了。</p><p>看了上次的项目配置，再加上百度、Bing、谷歌搜了个遍，找到几种最常见的解决方案：</p><ul><li>浏览器直接访问后端接口，看能否正常返回；</li><li>配置完跨域代理之后，一定要重启项目，<code>npm run ddev</code> ;</li><li>确保配置没问题，并且请求中的URL在被代理正则替换之后是浏览器能正常访问返回数据的正确地址；</li><li>代理插件可能有缓存，删除 node_modules 之后，重新 <code>npm install</code> ， <code>npm run dev</code> ；</li><li>更换前端项目端口然后重启；</li><li>检查是否搭了梯子，代理可能会受到影响；</li><li>为 axios 配置 baseUrl …</li></ul><p>大致找到以上常见的解决方案，除了配置 baseUrl，其他的我都尝试了，并且100%保证配置没问题，可是就是请求不过去。甚至想查一下怎么看代理以后的地址长什么样，可是没找到相关的方法。</p><br><h2 id="最终原因"><a href="#最终原因" class="headerlink" title="最终原因"></a>最终原因</h2><p>今天晚上回来从10：50开始研究，去GitHub比对了和上次的配置差在哪里，一行一行比对，结果发现配置里的 json 多了一层 proxy！这个配置是我从网上博客里复制过来的，害死人了。</p><p>当前配置：</p><pre><code class="json">proxyTable: &#123;    proxy: &#123;        &#39;/&#39;: &#123;            target: &#39;http://localhost:9002/&#39;,            changeOrigin: true,            pathRewrite: &#123;                &#39;^/&#39;: &#39;&#39;            &#125;        &#125;    &#125;&#125;</code></pre><p>正确配置：</p><pre><code class="json">proxyTable: &#123;    &#39;/&#39;: &#123;        target: &#39;http://localhost:9002/&#39;,        changeOrigin: true,        pathRewrite: &#123;            &#39;^/&#39;: &#39;&#39;        &#125;    &#125;&#125;</code></pre><p>去掉proxy一层，重启前端项目，然后清除缓存，刷新页面，访问，成功返回数据。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitlab+Jenkins+Docker自动部署SpringBoot微服务</title>
      <link href="/2021/06/13/4c933e644385/"/>
      <url>/2021/06/13/4c933e644385/</url>
      
        <content type="html"><![CDATA[<p>在公司用了半年的 SpringCloud + Docker + Jenkins 的技术框架，现在流行持续集成，还没有抽点时间自己实际走一下全流程开发环境的搭建，正好赶上端午节，可以宅在出租屋里好好研究一下，特此记录一下实践过程中遇到的问题及解决方案。</p><span id="more"></span><h2 id="搭建测试项目"><a href="#搭建测试项目" class="headerlink" title="搭建测试项目"></a>搭建测试项目</h2><h3 id="请求接口"><a href="#请求接口" class="headerlink" title="请求接口"></a>请求接口</h3><ul><li><p>搭建一个简单的SpringBoot项目，创建一个接口用来测试。</p><p>  <a href="https://github.com/chenxii81">chenxii81</a>&#x2F;<strong><a href="https://github.com/chenxii81/springboot-demo">springboot-demo</a></strong></p></li></ul><p>接口地址：&#x2F;api&#x2F;user-management&#x2F;users</p><pre><code class="java">@GetMapping(&quot;/users&quot;)public Response&lt;List&lt;UserPo&gt;&gt; listUsers(@RequestParam int count) &#123;    Response&lt;List&lt;UserPo&gt;&gt; response = new Response&lt;&gt;();    response.setCode(0);    response.setMessage(&quot;请求成功&quot;);    response.setData(userService.listUsers(count));    return response;&#125;</code></pre><p>返回数据格式：</p><pre><code class="json">&#123;  &quot;code&quot;: 0,  &quot;message&quot;: &quot;请求成功&quot;,  &quot;data&quot;: [    &#123;      &quot;no&quot;: &quot;U00-0&quot;,      &quot;name&quot;: &quot;U-name0&quot;,      &quot;level&quot;: &quot;高级用户&quot;,      &quot;point&quot;: 245    &#125;,    &#123;      &quot;no&quot;: &quot;U00-1&quot;,      &quot;name&quot;: &quot;U-name1&quot;,      &quot;level&quot;: &quot;初级用户&quot;,      &quot;point&quot;: 238    &#125;,    &#123;      &quot;no&quot;: &quot;U00-2&quot;,      &quot;name&quot;: &quot;U-name2&quot;,      &quot;level&quot;: &quot;初级用户&quot;,      &quot;point&quot;: 240    &#125;  ]&#125;</code></pre><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><pre><code>FROM openjdk:8-jdk-alpineVOLUME /tmpCOPY springboot-demo.jar app.jarENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]EXPOSE 8080</code></pre><h3 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h3><pre><code>pipeline &#123;    agent any    stages &#123;        stage(&#39;Build&#39;) &#123;            steps &#123;                echo &#39;Building..&#39;                sh &#39;mvn clean &amp;&amp; mvn package&#39;                sh &#39;cp target/springboot-demo.jar src/main/docker/springboot-demo.jar&#39;                echo &#39;Build completed.&#39;            &#125;        &#125;        stage(&quot;Image&quot;) &#123;            steps &#123;                echo &#39;Imaging..&#39;                sh &#39;cd src/main/docker &amp;&amp; docker build --rm -t springboot-demo:v1 .&#39;                echo &#39;Image completed.&#39;            &#125;        &#125;        stage(&#39;Deploy&#39;) &#123;            steps &#123;                echo &#39;Deploying....&#39;                sh &#39;docker run -d -p 8082:8001 --name springboot-demo springboot-demo:v1&#39;                echo &#39;Deploy completed.&#39;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="Docker安装以及Dockerhub账户注册"><a href="#Docker安装以及Dockerhub账户注册" class="headerlink" title="Docker安装以及Dockerhub账户注册"></a>Docker安装以及Dockerhub账户注册</h2><p>注册Dockerhub账号，然后安装docker。</p><pre><code class="shell"># 安装dockercurl -sSL https://get.daocloud.io/docker | sh# 将用户加入docker组中sudo gpasswd -a chenxii docker# 更新docker组sudo grpnew docker# 登录docker，用docker id登录而不是邮箱# 不要直接 -p 登录，不安全cat passwd.txt | docker login -u chenxii81 --password-stdin</code></pre><h2 id="Gitlab安装"><a href="#Gitlab安装" class="headerlink" title="Gitlab安装"></a>Gitlab安装</h2><p>本来想用VPS的，但是从docker启动gitlab之后总是几分钟就会Exit，应该是配置太低了，才512M内存，1核处理器。只能放到虚拟机弄了。</p><p>为了配置方便，用 Docker 安装 Gitlab：</p><pre><code class="shell">docker pull gitlab/gitlab-ce:latestdocker run -d  -p 443:443 -p 80:80 -p 222:22 --name gitlab gitlab/gitlab-ce:latest# e176b0d7d3d8775a293701d85029421eebf0ae6d013e79edb791c47df0e8c857docker ps -a# 状态为 healthy之后就可以用宿主机ip进行访问了，Up 3 minutes (healthy)# 修改gitlab地址# 打开文件 /etc/gitlab/gitlab.rb 文件并找到 # external_url &#39;GENERATED_EXTERNAL_URL&#39; 这行，去掉注释，并按照下面的格式修改。# 使用hosts里配置的域名，git提交会被redirect，最好用ipexternal_url &#39;http://gitlab.chenxii.com&#39; 或者 external_url &#39;http://192.168.8.188&#39;# 然后执行下面的命令使配置生效sudo docker exec gitlab gitlab-ctl reconfigure# 修改完之后仓库的地址：git@gitlab.chenxii.com:gitlab-instance-8190bce8/Monitoring.githttp://gitlab.chenxii.com/gitlab-instance-8190bce8/Monitoring.git# 将代码传到gitlabgit remote add origin http://192.168.8.188/root/springboot-demo.gitgit add .git commit -m &quot;init repo&quot;git push -u origin --allgit push -u origin --tags</code></pre><p>初次登录需要重设密码，之后可以用root + 新密码登录。</p><p><img src="https://images.happy365.day/24/04/17231138.png" alt="截图"></p><h2 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h2><p>使用Docker配置Jenkins</p><pre><code class="shell">docker pull jenkins/jenkins:lts# Jenkins Docker镜像中没有Maven，所以将宿主机的Maven挂载到Docker容器docker run -d -p 8081:8080 --name jenkins \-v /opt/jdk/jdk1.8.0_181:/usr/lib/jvm/java-1.8-openjdk \-v /opt/maven/maven-3.5.4:/usr/local/maven3 jenkins/jenkins:lts# 使用docker logs查看Jenkins初始化密码docker logs container_id</code></pre><p>安装推荐插件之后，创建用户进入Jenkins</p><p><img src="https://images.happy365.day/24/04/17231212.png" alt="截图"></p><h2 id="安装Jenkins插件"><a href="#安装Jenkins插件" class="headerlink" title="安装Jenkins插件"></a>安装Jenkins插件</h2><h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.8.1/binaries/apache-maven-3.8.1-bin.tar.gz"> apache-maven-3.8.1-bin.tar.gz</a></p><p>配置：</p><pre><code class="shell"># 因为maven-3.8.1报错，换成了3.5.4版本sudo mv ~/Downloads/apache-maven-3.5.4-bin.tar.gz /opt/maven  sudo tar -zxvf apache-maven-3.5.4-bin.tar.gzcd apache-maven-3.5.4sudo mv apache-maven-3.5.4/opt /maven-3.5.4vim ~/.bashrcexport MAVEN_HOME=/opt/maven/maven-3.5.4export PATH=$PATH:$MAVEN_HOME/bin</code></pre><h2 id="配置Gitlab-Key"><a href="#配置Gitlab-Key" class="headerlink" title="配置Gitlab Key"></a>配置Gitlab Key</h2><h3 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h3><p>在 Gitlab 中 SSH Key 页面（<a href="http://192.168.8.188/-/profile/keys%EF%BC%89%EF%BC%8C%E5%B0%86%E8%87%AA%E5%B7%B1%E6%9C%AC%E5%9C%B0">http://192.168.8.188/-/profile/keys），将自己本地</a> ~&#x2F;.ssh&#x2F;id_rsa.pub 内容存进去，这样传代码不需要每次都输入密码。</p><h3 id="Access-Tokens"><a href="#Access-Tokens" class="headerlink" title="Access Tokens"></a>Access Tokens</h3><p>1、给Jenkins安装Publish Over SSH插件</p><p>2、Jenkins需要从Gitlab拉取代码，所以需要为Jenkins配置一个Access Tokens，类似：5nU3oGSxyZXsxHyuwekH，生成之后将其配置到 <strong>系统配置</strong> &gt; <strong>Publish over SSH</strong> &gt; <strong>Key</strong> 保存。</p><h2 id="Jenkins报错"><a href="#Jenkins报错" class="headerlink" title="Jenkins报错"></a>Jenkins报错</h2><h3 id="mvn命令找不到"><a href="#mvn命令找不到" class="headerlink" title="mvn命令找不到"></a>mvn命令找不到</h3><p>Jenkins报错 mvn 命令找不到，因为 Docker Jenkins里没有Maven。</p><pre><code>+ mvn clean/var/jenkins_home/workspace/springboot-demo_master@tmp/durable-c0a723ef/script.sh: 1: /var/jenkins_home/workspace/springboot-demo_master@tmp/durable-c0a723ef/script.sh: mvn: not foundscript returned exit code 127</code></pre><p>配置如下：</p><p>在这里卡了很长时间，最后找到一个解决方案：<a href="https://blog.csdn.net/qq_43437874/article/details/107087363">Jenkins打包Maven项目找不到mvn解决办法script.sh: line 1: mvn: not found</a></p><p>启动命令中将宿主机上的maven路径挂在到Docker容器的 &#x2F;usr&#x2F;local&#x2F;maven3目录下，然后在 <strong>系统配置</strong> &gt; <strong>全局属性</strong> 下，将MAVEN_HOME追加到环境变量中，然后扫描流水线就可以下载依赖了。</p><pre><code># docker run中挂载宿主机maven到docker容器中-v /opt/maven/maven-3.5.4:/usr/local/maven3 jenkins/jenkins:lts</code></pre><blockquote><p>还有一种挂载方式不需要重新运行镜像，直接给容器挂载新的目录：</p><p>修改 &#x2F;var&#x2F;run&#x2F;docker&#x2F;containerid&#x2F;容器id&#x2F;hostconfig.json 和 &#x2F;var&#x2F;run&#x2F;docker&#x2F;containerid&#x2F;容器id&#x2F;config.v2.json</p><p>参见：<a href="https://blog.51cto.com/hjun169/2440799"><strong>docker给已经启动容器添加挂载目录</strong></a></p></blockquote><table><thead><tr><th>键</th><th>值</th></tr></thead><tbody><tr><td>MAVEN_HOME</td><td>&#x2F;usr&#x2F;local&#x2F;maven3</td></tr><tr><td>PATH+EXTRA</td><td>$MAVEN_HOME&#x2F;bin</td></tr></tbody></table><p><img src="https://images.happy365.day/24/04/17231249.png"></p><p><img src="https://images.happy365.day/24/04/17231337.png"></p><h3 id="docker命令找不到"><a href="#docker命令找不到" class="headerlink" title="docker命令找不到"></a>docker命令找不到</h3><p>解决方案：</p><blockquote><p>给启动的Docker容器挂载宿主机的 docker 环境</p><p>参见：<a href="https://blog.51cto.com/hjun169/2440799">docker给已经启动容器添加挂载目录</a></p></blockquote><h3 id="var-run-docker-sock-connect-permission-denied"><a href="#var-run-docker-sock-connect-permission-denied" class="headerlink" title="&#x2F;var&#x2F;run&#x2F;docker.sock: connect: permission denied"></a>&#x2F;var&#x2F;run&#x2F;docker.sock: connect: permission denied</h3><p>运行到 docker 构建镜像的时候提示权限不足，&#x2F;var&#x2F;run&#x2F;docker.sock 只有 root 权限才能调用，可以将 jenkins 用户加到 docker 组下：</p><pre><code class="shell">sudo gpasswd -a jenkins dockernewgrp docker</code></pre><p>但是这里docker是挂载了宿主机的docker目录，所以不存在docker组，直接将 &#x2F;var&#x2F;run&#x2F;docker.sock 改成 777 权限：</p><pre><code class="shell">docker exec -u 0 -it 容器id /bin/bashchmod -R 777 /var/run/docker.sockexit</code></pre><p>再次构建：</p><p><img src="https://images.happy365.day/24/04/17231419.png" alt="截图"></p><p><img src="https://images.happy365.day/24/04/17231501.png" alt="截图"></p><p><img src="https://images.happy365.day/24/04/17231547.png" alt="截图"></p><p><img src="https://images.happy365.day/24/04/17231621.png" alt="截图"></p><p>20次的流水线扫描，上百次 Bing 搜索，终于成功看到了赏心悦目的绿色和接口返回值 🎉</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实上个月已经做个一个 Jenkins Pipeline 的实践项目，但是上次 Jenkins 和 Gitlab 都是虚拟机安装，没有使用 Docker，所以这次两天的实践基本上是填 Docker 中遇到的坑，端午节假期今天结束了，很庆幸虽然这两天断断续续但还是赶在最后的时间点部署成功了。对 Docker 、 Jenkins 和 Gitlab 这一套技术有了更深的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI </tag>
            
            <tag> 持续集成 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkinsfile cd命令不生效的问题</title>
      <link href="/2021/06/05/68c5ea459181/"/>
      <url>/2021/06/05/68c5ea459181/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天晚上给前端项目配置Jenkins流水线的时候遇到一个问题：cd 命令不生效，<code>sh 'cd ask_front'</code> 这个语句执行前后 <code>pwd</code> 的输出是一样的。</p><pre><code>+ pwd/home/jingh527/.jenkins/workspace/try-ask_master</code></pre><p>去Jenkins机器上看了上面这个目录结构：</p><pre><code>try-ask_master-- ask-- ask_front</code></pre><span id="more"></span><p>Jenkinsfile的定义：</p><pre><code class="groovy">pipeline &#123;    agent &#123;        docker &#123;            image &#39;node:10&#39;            args &#39;-itd -p 9001:8080&#39;        &#125;    &#125;    stages &#123;        stage (&quot;编译&quot;) &#123;            steps &#123;                echo &quot;======== 开始编译项目 ========&quot;                sh &quot;pwd&quot;                sh &quot;cd ask_front&quot;                sh &quot;npm uninstall *&quot;                sh &quot;rm -rf node_modules&quot;                sh &quot;rm -rf package-lock.json&quot;                sh &quot;npm cache clean --force&quot;                sh &quot;npm install&quot;                echo &quot;======== 项目编译结束 ========&quot;            &#125;        &#125;        stage (&quot;部署&quot;) &#123;            steps &#123;                echo &quot;======== 开始部署项目 ========&quot;                sh &quot;pwd&quot;                sh &quot;npm run dev&quot;                echo &quot;======== 项目成功部署 ========&quot;            &#125;        &#125;    &#125;&#125;</code></pre><p>在执行到 npm 命令相关的地方就开始报错：</p><pre><code>+ npm run devnpm ERR! code ENOENTnpm ERR! syscall opennpm ERR! path /home/jingh527/.jenkins/workspace/try-ask_master/package.jsonnpm ERR! errno -2npm ERR! enoent ENOENT: no such file or directory, open &#39;/home/jingh527/.jenkins/workspace/try-ask_master/package.json&#39;npm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoent npm ERR! A complete log of this run can be found in:npm ERR!     /home/node/.npm/_logs/2021-06-04T17_20_39_229Z-debug.logscript returned exit code 254</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在网上找了一会儿资料，看到一个帖子：<a href="https://blog.csdn.net/liumiaocn/article/details/102632742">Jenkins基础：Jenkinsfile注意事项：条件跳转与当前路径</a></p><blockquote><p>cd demo、npm install、npm run build这本是三条命令，强硬地使用&amp;&amp;写在了一起，为什么不能分开使用三个sh ‘’的原因是因为，在具体的实现的时候，显然执行完返回当前目录会恢复为原始状态。这是一个非常容易被忘记的问题。</p></blockquote><pre><code>stage(&#39;Build Angular Project&#39;) &#123; // build angular demo app    sh &#39;cd demo &amp;&amp; npm install &amp;&amp; npm run build&#39;&#125;</code></pre><p>才反应过来脚本写得有问题，于是改了一下，将多个操作用 &amp;&amp; 连接起来，就部署成功了。</p><pre><code class="groovy">pipeline &#123;    agent &#123;        docker &#123;            image &#39;node:10&#39;            args &#39;-itd -p 9001:8080&#39;        &#125;    &#125;    stages &#123;        stage (&quot;编译&quot;) &#123;            steps &#123;                echo &quot;======== 开始编译项目 ========&quot;                sh &quot;pwd&quot;                sh &quot;cd ask_front &amp;&amp; npm uninstall * &amp;&amp; rm -rf node_modules &amp;&amp; rm -rf package-lock.json &amp;&amp; npm cache clean --force &amp;&amp; npm install&quot;                echo &quot;======== 项目编译结束 ========&quot;            &#125;        &#125;        stage (&quot;部署&quot;) &#123;            steps &#123;                echo &quot;======== 开始部署项目 ========&quot;                sh &quot;cd ask_front &amp;&amp; npm run dev&quot;                echo &quot;======== 项目成功部署 ========&quot;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据入门</title>
      <link href="/2021/05/30/79b633b27ff1/"/>
      <url>/2021/05/30/79b633b27ff1/</url>
      
        <content type="html"><![CDATA[<h2 id="Hadoop的安装和配置"><a href="#Hadoop的安装和配置" class="headerlink" title="Hadoop的安装和配置"></a>Hadoop的安装和配置</h2><h3 id="Hadoop下载"><a href="#Hadoop下载" class="headerlink" title="Hadoop下载"></a>Hadoop下载</h3><h3 id="Hadoop环境变量"><a href="#Hadoop环境变量" class="headerlink" title="Hadoop环境变量"></a>Hadoop环境变量</h3><h3 id="Hadoop启动和停止"><a href="#Hadoop启动和停止" class="headerlink" title="Hadoop启动和停止"></a>Hadoop启动和停止</h3><span id="more"></span><h2 id="Hive的安装和配置"><a href="#Hive的安装和配置" class="headerlink" title="Hive的安装和配置"></a>Hive的安装和配置</h2><p>Hive-3.1.2版本下载地址：<a href="https://mirrors.bfsu.edu.cn/apache/hive/hive-3.1.2/apache-hive-3.1.2-bin.tar.gz">apache-hive-3.1.2-bin.tar.gz</a></p><p>下载之后解压并复制到 &#x2F;opt 目录下</p><pre><code class="bash">tar -zxvf apache-hive-3.1.2-bin.tar.gzcp -r apache-hive-3.1.2-bin /opt/hive-3.1.2sudo chown -R currUser:currUserGroup hive3.1.2</code></pre><p>配置hive路径：</p><pre><code class="bash">export HIVE_HOME=/opt/hive-3.1.2export PATH=$PATH:$HIVE_HOME/binsource ~/.bashrc</code></pre><p>启动Hive时先启动Hadoop：</p><pre><code class="bash">cd $HADOOP_HOME/binstart-all.shhive</code></pre><p>遇到的问题：</p><blockquote><p>Hive启动报错：java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument</p></blockquote><p>因为 HIVE_HOME&#x2F;lib下的 guava jar 包的版本个HADOOP_HOME&#x2F;share&#x2F;hadoop&#x2F;common&#x2F;lib下的 guava 包版本不一致导致的，先删除其中一个版本比较低的，然后将另一个目录下的 guava 包复制过去就可以了。</p><blockquote><p>Hive启动报错： Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient异常</p></blockquote><p>在 HIVE_HOME&#x2F;conf 目录下配置 hive-site.xml 文件，去 hive-site.xml 设置Derby数据库的位置：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;                &lt;value&gt;/opt/hive-3.1.2/data&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.metastore.local&lt;/name&gt;                &lt;value&gt;true&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;                &lt;value&gt;jdbc:derby:/opt/hive-3.1.2/metastore_db;databaseName=metastore_db;create=true&lt;/value&gt;        &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>&#x2F;data 是自己建立的数据仓库目录。</p><p>然后删除原来的metadb schema，再重新初始化：</p><pre><code class="bash">rm -rf $HIVE_HOME/metastore_dbcd $HIVE_HOMEschematool -initSchema -dbType derby...Initialization script completedschemaTool completed</code></pre><p>然后再进入hive，执行show databases; 已经可以正常工作了。</p><pre><code class="sql">select * from employee where name = &#39;name1&#39; and id = 1;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Element的Nav导航高亮</title>
      <link href="/2021/05/13/2c8a67e01784/"/>
      <url>/2021/05/13/2c8a67e01784/</url>
      
        <content type="html"><![CDATA[<p>这两天遇到一个问题：element的Nav菜单点击之后，跳转到相应页面，然后点击之后的菜单要高亮显示。菜单写成了组件。</p><p>研究了好长时间没解决，今天晚上找到一个解决方案，完美的解决了问题！记录一下。</p><p>链接🔗：<a href="https://www.cnblogs.com/liuqin-always/p/11603708.html">vue 中使用element-ui的menu选中项高亮的问题</a></p><span id="more"></span><p>nav组件：</p><pre><code class="html">&lt;template&gt;    &lt;div style=&quot;padding-left: 15px&quot;&gt;        &lt;el-menu :default-active=&#39;$route.name&#39; class=&quot;el-menu-vertical-demo&quot;                active-text-color=&quot;#409EFF&quot; router                @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot;&gt;            &lt;el-menu-item index=&quot;/&quot;&gt;                &lt;span&gt;Home&lt;/span&gt;            &lt;/el-menu-item&gt;            &lt;el-menu-item index=&quot;allQuestions&quot;&gt;                &lt;span&gt;Questions&lt;/span&gt;            &lt;/el-menu-item&gt;            &lt;el-menu-item index=&quot;tags&quot;&gt;                &lt;span&gt;Tags&lt;/span&gt;            &lt;/el-menu-item&gt;            &lt;el-menu-item index=&quot;users&quot;&gt;                &lt;span&gt;Users&lt;/span&gt;            &lt;/el-menu-item&gt;        &lt;/el-menu&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><p>使用:route.name和router，在点击菜单后跳转到相应的页面，其中一个页面：</p><pre><code class="html">&lt;template&gt;    &lt;div class=&quot;pane&quot;&gt;        &lt;router-view&gt;&lt;/router-view&gt;        &lt;el-row&gt;            &lt;header1&gt;&lt;/header1&gt;            &lt;el-col :span=&quot;4&quot;&gt;                &lt;side-bar style=&quot;margin-top: 15px&quot;&gt;&lt;/side-bar&gt;            &lt;/el-col&gt;        &lt;/el-row&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import SideBar from &#39;../components/SideBar.vue&#39;import Header from &#39;../components/Header.vue&#39;    components: &#123;        &#39;side-bar&#39;: SideBar,        &#39;header1&#39;: Header,    &#125;&lt;/script&gt;</code></pre><p>路由的配置：</p><pre><code class="json">export default new Router(&#123;    routes: [&#123;            path: &#39;/users&#39;,            name: &#39;users&#39;,            component: User        &#125;    ]&#125;)</code></pre><p>发现这样配置之后会将 index添加到path中，菜单也能高亮显示。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-cli项目配置代理不生效</title>
      <link href="/2021/05/09/cb163c8f928d/"/>
      <url>/2021/05/09/cb163c8f928d/</url>
      
        <content type="html"><![CDATA[<p>详解webpack的proxyTable无效的解决方案</p><span id="more"></span><h2 id="webpack下配置proxyTable的问题"><a href="#webpack下配置proxyTable的问题" class="headerlink" title="webpack下配置proxyTable的问题"></a>webpack下配置proxyTable的问题</h2><p>Vue-cli@2创建的项目，用的webpack，配置了 config&#x2F;index.js ：</p><pre><code class="json">module.exports = &#123;  dev: &#123;    // Paths    assetsSubDirectory: &#39;static&#39;,    assetsPublicPath: &#39;/&#39;,    proxyTable: &#123;      &#39;/api&#39;: &#123;        target: &#39;http://localhost:9003/&#39;,        ws: true,        changOrigin: true,        pathRewrite: &#123;          &#39;^/api&#39;: &#39;&#39;        &#125;      &#125;    &#125;, ...  &#125; &#125;</code></pre><p>导入了axios：</p><pre><code class="javascript">import axios from &#39;axios&#39;Vue.prototype.axios = axios</code></pre><p>请求的代码：</p><pre><code class="javascript">login() &#123;    if (this.form.userId === &#39;&#39; || this.form.password === &#39;&#39;) &#123;        this.openMessageWarning(&#39;用户名和密码不能为空&#39;)        return    &#125;    this.axios.post(&#39;/test/param1&#39;).then((res) =&gt; &#123;        console.log(&quot;res: &quot;, res)    &#125;)&#125;</code></pre><p>改完之后重启了项目，但是控制台显示请求的ip还是本地：</p><pre><code>POST http://localhost:8080/test/param1 404 (Not Found)</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>查了一下午的资料，基本上都差不多：</p><ul><li>检查proxyTable中配置的域名</li><li>配置 webpack.baseUrl</li><li>配置完要重启应用才能生效</li><li>删掉node_modules重建项目</li></ul><p>前几个方法都试了，没什么效果。甚至和以前的项目对比了，都没找到什么不同的地方。</p><h2 id="最终解决（理解错误）"><a href="#最终解决（理解错误）" class="headerlink" title="最终解决（理解错误）"></a>最终解决（理解错误）</h2><p>看了 <a href="https://www.jb51.net/article/142086.htm">详解webpack的proxyTable无效的解决方案</a> ，说可能是缓存的问题，我每次都有清理浏览器的缓存，不知道webpack还有缓存的，然后我尝试着将proxyTable中的端口换了一下，结果…就请求成功了！</p><pre><code>POST http://localhost:9004/test/param1 404 (Not Found)</code></pre><p>没想到这层原因，在这个问题上卡了一下午，心态崩溃。</p><h2 id="正确的解决方案"><a href="#正确的解决方案" class="headerlink" title="正确的解决方案"></a>正确的解决方案</h2><p>其实是配置中target配置有问题：</p><p>例如后台地址：<a href="http://baidu.com/api/user/%7BuserId%7D">http://baidu.com/api/user/{userId}</a></p><p>本地项目地址为：<a href="http://localhost:8080/">http://localhost:8080</a></p><pre><code>//方式一，留空，不写&#39;/^api&#39;: &#39;&#39;, //代表你在axios里的请求&#39;/api/info&#39; = http://localhost:54321/info//方式二，重写&#39;/^api&#39;: &#39;api/&#39;, //代表你在axios里的请求&#39;/api/info&#39; = http://localhost:54321/api/info</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacBook Pro 2020指纹无反应</title>
      <link href="/2021/05/09/7c7b271bb846/"/>
      <url>/2021/05/09/7c7b271bb846/</url>
      
        <content type="html"><![CDATA[<p>记得上个月重装了一次系统，然后指纹都被清掉了，重装完系统之后发现无法录入指纹，按压指纹没有反应。</p><span id="more"></span><p>昨天晚上发版，有一个配置没有提交，导致今天早上☀️生产部署失败⚠️了，七点不到⏰就去公司🏙处理。想趁着今天刚好周末有时间，去售后看看。可是售后人🚶太多了，笔记本💻的号都排完了，只能预约下周六。</p><p>回来之后无意之间搜了一下这个问题，其实之前就有搜过很多帖子，但是没找到有用的信息。第一个搜索结果很熟悉：<a href="https://discussionschinese.apple.com/thread/251698511">Macbook Pro 2020 指纹识别失灵 无法使用</a> ，因为以前就看过，不抱希望的点进去看了一下，结果发现之前没仔细看描述：<strong>插上电源 大部分时候就是不灵敏 开屏解锁，填充密码等都是，不插电源正常。</strong> 回想了一下，好像我确实一直插着电在用，我把电源拔掉一试，竟然可以正常使用。</p><p>但是每次用指纹都要拔掉电源很麻烦，往下看到一个有用答案⭐️：</p><blockquote><p>我也有同样的问题 研究了半天 感觉是电源没有接地的原因 我在楼上插着充电器就不能用指纹 楼下就能 好无语😓 然后我偶然间发现插着电源用指纹的时候手掌手臂尽量接触电脑的金属表面 指纹也能重新识别😂</p></blockquote><p><strong>只要用指纹的时候手掌接触机身就可以正常识别。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacBook Pro </tag>
            
            <tag> 指纹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reset Your IDE Eval Information</title>
      <link href="/2021/05/01/6b91ab7e5440/"/>
      <url>/2021/05/01/6b91ab7e5440/</url>
      
        <content type="html"><![CDATA[<p>IDEA无限试用：</p><span id="more"></span><blockquote><h2 id="Reset-Your-IDE-Eval-Information"><a href="#Reset-Your-IDE-Eval-Information" class="headerlink" title="Reset Your IDE Eval Information"></a>Reset Your IDE Eval Information</h2><ol><li><p>Download and install plugin from</p><p> Download Link: <a href="https://plugins.zhile.io/files/ide-eval-resetter-2.1.14-d2fedb86.zip">Download Link</a></p><ul><li>Alternative installation method:<ul><li>Add “Custom Plugin Repository”: <code>https://plugins.zhile.io</code> manually (<code>Settings/Preferences</code> -&gt; <code>Plugins</code>)</li><li>Search and install plugin: <code>IDE Eval Reset</code></li></ul></li></ul></li><li><p>Click <code>Help</code> or <code>Get Help</code> -&gt; <code>Eval Reset</code> menu.</p></li><li><p>Click <code>Reset</code> -&gt; <code>Yes</code> button.</p></li><li><p>Restart your IDE.</p></li><li><p>Now you have another 30 days eval time :)</p></li><li><p>For more information, visit <a href="https://zhile.io/2020/11/18/jetbrains-eval-reset-da33a93d.html">here</a>.</p></li></ol></blockquote><p>IDEA版本： 2020.3</p><p>项目地址： <a href="https://gitee.com/pengzhile/ide-eval-resetter">Reset Your IDE Eval Information</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 无限试用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-generator的使用</title>
      <link href="/2021/04/27/e82d77936c3a/"/>
      <url>/2021/04/27/e82d77936c3a/</url>
      
        <content type="html"><![CDATA[<p>MyBatisGenerator的配置和使用</p><span id="more"></span><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;!-- mybatis-generator自动生成代码插件 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.5&lt;/version&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>更新pom文件导入依赖后在idea侧边栏能看到mybatisGenerator插件。</p><p><img src="https://images2.imgbox.com/ee/a0/h1JH6RCQ_o.png" alt="image-20210427004620531"></p><p>配置完成后可以直接双击运行。</p><h2 id="配置generatorConfig-xml"><a href="#配置generatorConfig-xml" class="headerlink" title="配置generatorConfig.xml"></a>配置generatorConfig.xml</h2><p>在项目resources目录下新建generatorConfig.xml文件，文件内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--mysql 连接数据库jar 这里选择自己本地位置--&gt;    &lt;classPathEntry            location=&quot;/Users/jingh527/.m2/try-ask-repo/mysql/mysql-connector-java/8.0.22/mysql-connector-java-8.0.22.jar&quot;/&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&quot;                        userId=&quot;admin&quot;                        password=&quot;admin&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和           NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.xxx.yyy.po&quot;                            targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;false&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置           如果maven工程只是单独的一个工程，targetProject=&quot;src/main/java&quot;           若果maven工程是分模块的工程，targetProject=&quot;所属模块的名称&quot;，例如：           targetProject=&quot;ecps-manager-mapper&quot;，下同--&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.xxx.yyy.dao&quot;                         targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;                             targetPackage=&quot;com.xxx.yyy.dao&quot;                             targetProject=&quot;src/main/java&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table schema=&quot;&quot; tableName=&quot;table1&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;table2&quot;&gt;&lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>需要注意数据连接信息，以及驱动jar包，可以复制maven本地仓库里的jar包地址。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>双击图一中的mybatis-generator:generate，自动下载完插件依赖后，代码就生成完了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB入门</title>
      <link href="/2021/03/16/2e423b4a46ff/"/>
      <url>/2021/03/16/2e423b4a46ff/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB的安装"><a href="#MongoDB的安装" class="headerlink" title="MongoDB的安装"></a>MongoDB的安装</h2><ul><li><p><a href="https://www.mongodb.com/try/download/community">MongoDB官网下载地址</a> 下载安装包并解压到mongo&#x2F;</p></li><li><p>创建mongo&#x2F;db目录和&#x2F;mongo&#x2F;log&#x2F;mongodb.log文件</p></li><li><p>创建配置文件mongo&#x2F;mongodb.conf</p><span id="more"></span><pre><code># 数据文件存放目录dbpath=/Users/youyou-2608/Downloads/mongodb/db# 日志文件存放目录logpath=/Users/youyou-2608/Downloads/mongodb/log/mongodb.log# 以追加的方式记录日志logappend=true# 默认端口27017port=27017# 对访问ip地址不做限制，默认为本地地址bind_ip=0.0.0.0# 以守护进程的方式启用，即在后台运行fork=true# 默认开启身份认证auth=true</code></pre></li></ul><h2 id="配置环境变量及服务的启动和停止"><a href="#配置环境变量及服务的启动和停止" class="headerlink" title="配置环境变量及服务的启动和停止"></a>配置环境变量及服务的启动和停止</h2><p>~&#x2F;.bash_profile文件中：</p><pre><code class="bash">export PATH = mongo/bin:$PATH</code></pre><p>执行 sourcce ~&#x2F;.bash_profile</p><p>启动及停止：</p><pre><code># 启动mongod -f mongo/mongodb.conf# 停止kill 9 -piduse amdin;db.shutdownServer();</code></pre><p>关闭MongoDB报错：</p><blockquote><p>Error: shutdownServer failed: {</p><p>​“ok” : 0,</p><p>​“errmsg” : “not authorized on admin to execute command { shutdown: 1.0, lsid: { id: UUID(&quot;4d11f7c3-3b79-458d-b857-2aac4816cd17&quot;) }, $db: &quot;admin&quot; }”,</p><p>​“code” : 13,</p><p>​“codeName” : “Unauthorized”</p><p>}</p></blockquote><p>因为没有 hostManager 权限所以报错：</p><pre><code>use admin;db.grantRolesToUser(&quot;uadd&quot;, [&#123;role: &quot;hostManager&quot;, db: &quot;admin&quot;&#125;]);# 授权后再执行db.shutdownServer()</code></pre><h2 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h2><p>登录及创建用户：</p><pre><code>&gt; use admin;&gt; db.auth(&quot;uadd&quot;, &quot;uadd&quot;)use admin;# 创建管理员用户db.createUser(    &#123;        &quot;user&quot;: &quot;testuser&quot;,        &quot;pwd&quot;: &quot;123456&quot;,        &quot;roles&quot;: [            &#123;                &quot;role&quot;: &quot;userAdminAnyDatabase&quot;,                &quot;db&quot;: &quot;admin&quot;            &#125;        ]    &#125;)# 创建普通用户use test;db.createUser(    &#123;        &quot;user&quot;: &quot;testuser&quot;,        &quot;pwd&quot;: &quot;123456&quot;,        &quot;roles&quot;: [            &#123;                &quot;role&quot;: &quot;readWrite&quot;,                &quot;db&quot;: &quot;test&quot;            &#125;        ]    &#125;)</code></pre><h2 id="增删改查及常用命令"><a href="#增删改查及常用命令" class="headerlink" title="增删改查及常用命令"></a>增删改查及常用命令</h2><pre><code>use database;show dbs;show users;db.user.insert(&#123;&quot;name&quot;: &quot;zhangsan&quot;&#125;);db.user.insertMany([]);db.user.deleteOne(&#123;&quot;name&quot;: &quot;zhangsan&quot;&#125;)db.user.deleteMany(&quot;_id&quot;: &#123;&quot;$gte&quot;: 3&#125;)db.user.find(&quot;age&quot;: &#123;&quot;$gte&quot;: 3, &quot;$lte&quot;: 20&#125;)db.user.drop();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合redis报错</title>
      <link href="/2021/03/07/c3c39e4a1fb6/"/>
      <url>/2021/03/07/c3c39e4a1fb6/</url>
      
        <content type="html"><![CDATA[<p>在SpringBoot中整合Redis进行Token登录，测试方法中一直报错：</p><span id="more"></span><pre><code>java.lang.IllegalStateException: Failed to load ApplicationContextCaused by: org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named &#39;redisTemplate&#39; is expected to be of type &#39;org.springframework.data.redis.core.StringRedisTemplate&#39; but was actually of type &#39;org.springframework.data.redis.core.RedisTemplate&#39;</code></pre><p>代码：</p><pre><code class="java">public boolean set(String key, String value) &#123;    boolean result = false;    try &#123;        redisTemplate.opsForValue().set(key, value);        result = true;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    return result;&#125;// 测试方法@Testpublic void setTest() &#123;    redisClient.set(&quot;key1&quot;, &quot;value1&quot;);    String value = redisClient.get(&quot;key1&quot;);    assertNotNull(value);    log.info(&quot;value: &#123;&#125;&quot;, value);&#125;</code></pre><p>原来是注入的时候变量名有问题：</p><pre><code class="java">@Resourceprivate StringRedisTemplate redisTemplate;</code></pre><p>不是 redisTemplate ，而是 stringRedisTemplate。</p><p><strong>@Resource和@Autowired的区别。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近学到的IDEA使用技巧</title>
      <link href="/2021/02/05/92092d3c7660/"/>
      <url>/2021/02/05/92092d3c7660/</url>
      
        <content type="html"><![CDATA[<p>昨天晚上加班到凌晨3点，和前辈一起改一段代码，代码提交完，在等测试的时候，和前辈交流了一下IDEA的使用技巧，学到了很多东西。上次有这种感觉还是实习的时候，那时候学会了很多Sublime的小技巧。</p><ul><li>MyBatisX插件，直接查看MyBatis对应的SQL，自带MapperGenerator插件</li><li>Ctrl+Shift+F 查找所有</li><li>Ctrl+Shfit+R 替换所有</li><li>RestfulTool插件直接向接口发送请求。</li><li>Ctrl+Q查看Java文档注释，查看表信息并查看前十条数据</li><li>Ctrl+Shfit+上&#x2F;下：上下移动一行代码</li><li>多使用IDEA自带的Database插件，可以多个SQL脚本一键执行，SQL字段提示。</li><li>多使用IDEA集成的git和SVN插件，方便查看代码变更。</li></ul><p>才一个不到10万人使用的系统，就出现了很多性能问题，第一次在工作中接触到性能问题。每个SQL，每个循环，每个文件导入导出，一不小心就会超时出现数据提交失败的情况。大量优化代码逻辑，优化SQL执行效率，同步改异步，多线程，前端尽可能少提交数据，一晚上忙得晕头转向。虽然这两个星期每天晚上搞到很晚，身心疲惫，但是还是有所收获，真切的体会到了写高质量代码的必要性。</p><p>昨天上午因为一条SQL里加了递归，大量数据导致查询效率低下，流量高峰的时候系统直接挂了，然后又发紧急版本修复。之前从未使用过Oracle数据库，很多语法不懂，借此机会，正好可以学习一下Oracle。</p>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 使用技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue前后端分离项目中的跨域问题</title>
      <link href="/2020/12/20/974cffafa414/"/>
      <url>/2020/12/20/974cffafa414/</url>
      
        <content type="html"><![CDATA[<p>前后端分离项目的跨域问题</p><span id="more"></span><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>请求跨域报错：</p><p>Blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested……</p><h2 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h2><p>在Vue项目根目录下新建 <code>vue.config.js</code>文件，文件内容：</p><pre><code class="javascript">module.exports = &#123;    devServer: &#123;        open: true,        host: &#39;localhost&#39;,        port: 8091,        https: false,        //以上的ip和端口是我们本机的;下面为需要跨域的        proxy: &#123; //配置跨域            &#39;/api&#39;: &#123;                target: &#39;http://localhost:8092/&#39;, //这里后台的地址模拟的;应该填写你们真实的后台接口                ws: true,                changOrigin: true, //允许跨域                pathRewrite: &#123;                    &#39;^/api&#39;: &#39;&#39; //请求的时候使用这个api就可以                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>试了这种方式，但是在调试信息中看到输出的实际请求地址是<code>http://localhost:8091/api/</code>，返回404错误，不知道是不是哪里配置得不对。</p><h2 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h2><p>在项目 config&#x2F;index.js文件中的proxyTable中添加下面的内容，然后请求时的url拼接为：&#x2F;api&#x2F;xxx，这种方式能成功请求到后台。</p><p>不要配置<code>axios.defaults.baseURL</code>。</p><pre><code class="javascript">&#39;/api&#39;: &#123;    target: &#39;http://localhost:8092/&#39;, //这里后台的地址模拟的;应该填写你们真实的后台接口    ws: true,    changOrigin: true, //允许跨域    pathRewrite: &#123;        &#39;^/api&#39;: &#39;&#39; //请求的时候使用这个api就可以    &#125;&#125;</code></pre><p>改完配置之后记得重启项目！！</p><h2 id="解决方案3"><a href="#解决方案3" class="headerlink" title="解决方案3"></a>解决方案3</h2><p>可以使用Nginx代理实现跨域，照着网上的资料配置了server的listen项和proxy项，但是没有配置成功，有时间再试试。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Echarts自定义tooltip之后图例丢失问题</title>
      <link href="/2020/12/12/076e2156e425/"/>
      <url>/2020/12/12/076e2156e425/</url>
      
        <content type="html"><![CDATA[<p>解决自定义 echarts 的 tooltip 之后 tooltip 中图例丢失问题。</p><span id="more"></span><p>Echarts默认的tooltip中是带有图例的，默认的代码：</p><pre><code class="javascripte">tooltip: &#123;    trigger: &#39;axis&#39;&#125;</code></pre><p><img src="https://images.happy365.day/24/04/17220406.png" alt="问题"></p><br><p>但是自定义tooltip的显示之后图例丢失，官方的文档里没有在自定义中保留图例相关的配置。</p><pre><code class="javascript">tooltip: &#123;    trigger: &#39;axis&#39;,    formatter: &#39;&#123;b0&#125;&lt;br /&gt;&#123;a0&#125;: &#123;c0&#125;&lt;br /&gt;&#123;a1&#125;: &#123;c1&#125;&#39;&#125;</code></pre><p><img src="https://images.happy365.day/24/04/17220648.png" alt="问题"></p><br><p>找到一个解决方案：<a href="https://blog.csdn.net/qq_36051044/article/details/110237830">Echarts自定义tooltip提示框及图例</a> </p><pre><code class="javascript">tooltip: &#123;    trigger: &#39;axis&#39;,    // formatter: &#39;&#123;b0&#125;&lt;br /&gt;&#123;a0&#125;: &#123;c0&#125;&lt;br /&gt;&#123;a1&#125;: &#123;c1&#125;&#39;    formatter: function(params) &#123;        let val = &#39;&#39;;        for (let i = 0; i &lt; params.length; i++) &#123;            const param = params[i];            if (i === 0) &#123;            val = `              &lt;div style=&quot;padding:5px 3px&quot;&gt;                $&#123;param.name&#125;&lt;br/&gt;                &lt;div style=&quot;display:flex&quot;&gt;                  &lt;div style=&quot;width:10px;height:10px;border-radius: 50%;margin:6px 4px 0 0;background:                  $&#123;typeof param.color === &#39;string&#39; ? param.color : param.color.colorStops[0].color&#125;&quot;&gt;&lt;/div&gt;                  &lt;div&gt;$&#123;param.seriesName&#125;：$&#123;param.value&#125;&lt;/div&gt;                &lt;/div&gt;`;            &#125; else &#123;                val += `                &lt;div style=&quot;display:flex&quot;&gt;                    &lt;div style=&quot;width:10px;height:10px;border-radius: 50%;margin:6px 4px 0 0;background:                    $&#123;typeof param.color === &#39;string&#39; ? param.color : param.color.colorStops[0].color&#125;&quot;&gt;&lt;/div&gt;                 &lt;div&gt;$&#123;param.seriesName&#125;：$&#123;param.value&#125;&lt;/div&gt;              &lt;/div&gt;`;          &#125;      &#125;      val += `&lt;/div&gt;`;      return val;    &#125;&#125;,</code></pre><br><p>显示效果：</p><p><img src="https://images.happy365.day/24/04/17220728.png" alt="效果"></p><br><p>显示效果没什么问题，但是数据集多了能感觉到弹窗跟随鼠标时有明显的卡顿。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务无法注册到Eureka注册中心</title>
      <link href="/2020/11/22/e4b8cde283a0/"/>
      <url>/2020/11/22/e4b8cde283a0/</url>
      
        <content type="html"><![CDATA[<p>今天遇到一个问题：eureka客户端和服务端都正常启动，控制台也没有任何错误，并且客户端都可以正常访问，没有什么报错信息，但是无法注册到注册中心，再三检查也没发现配置有什么问题。</p><span id="more"></span><br><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code class="yaml"># eureka server的配置server:  port: 8000eureka:  instance:    hostname: localhost  client:    fetchRegistry: false    registerWithEureka: false    serviceUrl:      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/spring:  application:    name: eureka-service</code></pre><br><pre><code class="yaml"># 客户端的配置server:  port: 8001spring:  application:    name: cloud-payment-serviceeureka:  client:    registerWithEureka: true    fetchRegistry: true    serviceUrl:      defaultZone: http://localhost:8000/eureka</code></pre><br><p>注册中心显示：No instances available。</p><p><img src="https://images.happy365.day/24/04/17222344.png" alt="报错"></p><p>仔细看启动日志，服务端有注册日志，但是客户端启动日志没有。</p><p><img src="https://images.happy365.day/24/04/17222434.png" alt="日志"></p><h2 id="错误的Maven依赖"><a href="#错误的Maven依赖" class="headerlink" title="错误的Maven依赖"></a>错误的Maven依赖</h2><p>查了一些资料，发现一般都是启动阶段直接报错的，可以根据报错信息排查。</p><p>看到一篇文章：<a href="https://ask.csdn.net/questions/752782">spring-cloud，eureka客户端注册没有任何响应</a> ，点进去瞄一眼，在结尾看到描述跟我的问题一样：<em>我的提供者无法完成注册，日志没有任何注册相关的消息，也没有任何异常打印。</em>  </p><p><img src="https://images.happy365.day/24/04/17222607.png" alt="信息"></p><p>第一时间查看Maven依赖，发现问题所在。</p><p>正确的依赖是：<code>spring-cloud-starter-netflix-eureka-client</code> ，而不是 <code>spring-cloud-netflix-eureka-client</code> 。</p><h2 id="正确启动"><a href="#正确启动" class="headerlink" title="正确启动"></a>正确启动</h2><p>改完pom文件，reimport相关依赖，重新启动客户端，一切正常了。</p><p><img src="https://images.happy365.day/24/04/17222838.png" alt="启动日志"></p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务注册 </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Required request body is missing</title>
      <link href="/2020/11/21/42a8931b9523/"/>
      <url>/2020/11/21/42a8931b9523/</url>
      
        <content type="html"><![CDATA[<p>用postman测试接口一直报错，提示：Required request body is missing。</p><p>用浏览器请求和用postman post + param方式请求都说body missing，后台接口加了@RequestBody注解。</p><p>网上查了一会儿资料才发现原来是请求方式不对，参数应该放在body中并且以json方式传递。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java字节码解析</title>
      <link href="/2020/11/18/8fc8358110c9/"/>
      <url>/2020/11/18/8fc8358110c9/</url>
      
        <content type="html"><![CDATA[<p>最近在学Jvm相关的知识，看完视频，找了点字节码的资料看，理解字节码的含义。推荐 <a href="https://www.jianshu.com/p/252f381a6bc4">一文让你明白Java字节码</a></p><span id="more"></span><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>从一个简单类 Math.java 开始：</p><pre><code class="java">public class Math &#123;    private int m;    public int inc() &#123;        return m + 1;    &#125;&#125;</code></pre><p>用 <code>javac Math.java</code> 得到字节码文件 Math.class，文件内容：</p><pre><code>cafe babe 0000 0034 0013 0a00 0400 0f090003 0010 0700 1107 0012 0100 016d 01000149 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 0369 6e630100 0328 2949 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 7468 2e6a 6176 610c0007 0008 0c00 0500 0601 0004 4d61 74680100 106a 6176 612f 6c61 6e67 2f4f 626a6563 7400 2100 0300 0400 0000 0100 02000500 0600 0000 0200 0100 0700 0800 01000900 0000 1d00 0100 0100 0000 052a b70001b1 0000 0001 000a 0000 0006 0001 00000001 0001 000b 000c 0001 0009 0000 001f0002 0001 0000 0007 2ab4 0002 0460 ac000000 0100 0a00 0000 0600 0100 0000 06000100 0d00 0000 0200 0e</code></pre><h2 id="内容解读"><a href="#内容解读" class="headerlink" title="内容解读"></a>内容解读</h2><p>参照图例：</p><p><img src="https://images2.imgbox.com/08/79/8kGgoJqq_o.jpeg"></p><p><img src="https://images2.imgbox.com/61/17/vm6prCvK_o.png"></p><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>cafe babe：魔数，文件后缀标识，被java虚拟机接受。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>0000：次版本号</p><p>0034：主版本号&#x3D;52，java 1.8</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>0013：常量池入口，2+n，十进制&#x3D;19，表明有18个常量，从1开始</p><p>0a：十进制&#x3D;10，对应CONSTANT_Methodref_info，指向声明方法</p><p>0004：常量索引#4</p><p>000f：常量索引#15</p><p>09：十进制&#x3D;9，对应CONSTANT_Fieldref_info，指向字段的类或接口描述</p><p>0003：常量索引#3</p><p>0010：常量索引#16</p><p>07：十进制&#x3D;7，对应CONSTANT_Class_info，指向全限定名常量项的索引</p><p>0011：常量索引#17</p><p>07：同上</p><p>0012：常量索引#18</p><p>01：十进制&#x3D;1，对应表中的CONSTANT_Utf8_info，utf8编码的字符串长度</p><p>0001：字符串长度为1</p><p>6d：109&#x3D;”m”</p><p>01：同上</p><p>0001：同上</p><p>49：49&#x3D;”1”</p><p>01：同上</p><p>0006：同上</p><p>3c 696e 6974 3e：字符串&#x3D;<init></p><p>01：同上</p><p>0003：同上</p><p>2829 56：()V</p><p>01：同上</p><p>0004：同上</p><p>436f 6465：C_de</p><p>01：同上</p><p>000f：同上</p><p>4c 696e 654e 756d 6265 7254 6162 6c65：LineNumberTable</p><p>01：同上</p><p>0003：同上</p><p>69 6e63：inc</p><p>01：同上</p><p>0003：同上</p><p>28 2949：()I</p><p>01：同上</p><p>000a：长度为10的字符串</p><p>53 6f75 7263 6546 696c 65：SourceFile</p><p>01：同上</p><p>0009：同上</p><p>4d61 7468 2e6a 6176 61：Math.java</p><p>0c：十进制&#x3D;12，CONSTANT_NameAndType_info，指向该字段或方法名称常量项的索引</p><p>0007：字段或者名字名称常量项索引#7</p><p>0008：字段或者名字名称常量项索引#8</p><p>0c：同上</p><p>0005：字段或者名字名称常量项索引#5</p><p>0006：字段或者名字名称常量项索引#6</p><p>01：同上</p><p>0004：同上</p><p>4d61 7468：Math</p><p>01：同上</p><p>0010：同上</p><p>6a 6176 612f 6c61 6e67 2f4f 626a 6563 74：java&#x2F;lang&#x2F;Object</p><p>&#x3D;&#x3D;&#x3D;&#x3D; 常量解析完毕，共18个常量</p><h2 id="Access-Flag-访问标志部分"><a href="#Access-Flag-访问标志部分" class="headerlink" title="Access_Flag 访问标志部分"></a>Access_Flag 访问标志部分</h2><blockquote><p>0x0021：是 0x0020 和 0x0001 的并集。</p></blockquote><p>0021：ACC_PUBLIC，访问修饰符为Public。</p><h2 id="类索引"><a href="#类索引" class="headerlink" title="类索引"></a>类索引</h2><p>类索引用于确定类的全限定名。</p><p>0003：引用第3个常量，第3个常量引用第17个常量，为 Math。</p><h2 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h2><p>0004：引用第18个常量，为 java&#x2F;lang&#x2F;Object。</p><h2 id="接口索引"><a href="#接口索引" class="headerlink" title="接口索引"></a>接口索引</h2><p>0000：没有接口。</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。</p><p><img src="https://images2.imgbox.com/46/18/b007hXKr_o.png"></p><p>0001：字段属性。</p><p>0002：Private访问。</p><p>0005：常量索引#5，为”m”。</p><p>0006：常量索引#6，为”1”。</p><p>0000：属性表数量为0。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="https://images2.imgbox.com/b5/62/ZKPXcYOv_o.png"></p><p>to be continued…</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 字节码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Let’s Encrypt给网站加密</title>
      <link href="/2020/11/07/abed4ee56096/"/>
      <url>/2020/11/07/abed4ee56096/</url>
      
        <content type="html"><![CDATA[<p>使用 <strong>Let’s Encrypt</strong> 给网站加密</p><p>还没给你的网站加上Https？快用 <strong>Let’s Encrypt</strong>  给你的网站加个小锁吧！</p><span id="more"></span><h2 id="证书申请"><a href="#证书申请" class="headerlink" title="证书申请"></a>证书申请</h2><p>到 <a href="https://letsencrypt.osfipin.com/">来此加密</a> 按照步骤给域名申请证书，需要用邮箱注册账号。</p><p>验证的话，直接在域名解析里加个 TXT 类型的 DNS 解析，等 3 分钟就可以验证了。添加完了可以用 nslookup -q&#x3D;txt _acme-challenge.xxx.com 验证是否添加成功。</p><p>本来之前我用 FreeSSL 的，还有个客户端 KeyManager，阿里云可以一键申请证书和一键部署非常方便，但是我在用一键部署的时候一直卡住，试了几次没成功就放弃了。换了 Let’s Encrypt。</p><h2 id="上传证书"><a href="#上传证书" class="headerlink" title="上传证书"></a>上传证书</h2><p>证书申请成功后，下载下来是一个压缩包，解压缩后里面有几个文件，用 scp 命令或者 ftp 工具将文件夹上传到服务器上。</p><pre><code>scp -r local_path remote_path user@ip:remote_path </code></pre><h2 id="更改-Nginx配置文件"><a href="#更改-Nginx配置文件" class="headerlink" title="更改 Nginx配置文件"></a>更改 Nginx配置文件</h2><p>打开 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default 文件，添加配置：</p><pre><code>server&#123;    listen 80;    listen 443 ssl http2;        # SSL配置    ssl_certificate path/fullchain.crt;    ssl_certificate_key path/private.pem;    ssl_protocols TLSv1.1 TLSv1.2;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    ssl_session_cache shared:SSL:10m;    ssl_session_timeout 10m;&#125;</code></pre><p>path 是证书的目录。</p><p><strong>一定要注意每一行后面有分号</strong>，我就是没注意这个分号，导致重启 nginx 的时候一直报错，说 ssl_certificate 是未定义变量。主要是 <a href="https://letsencrypt.osfipin.com/">https://letsencrypt.osfipin.com</a> 这个网站官方配置说明里就没有分号。</p><p>443 端口一定要放开。</p><pre><code>sudo service nginx restart</code></pre><p>重启 nginx 就可以用 https 访问了！</p>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Let&#39;s Encrypt </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题</title>
      <link href="/2020/10/29/1d14bf52aca3/"/>
      <url>/2020/10/29/1d14bf52aca3/</url>
      
        <content type="html"><![CDATA[<p>最近在面试中遇到的一些问题，虽然很多都是最最基础的问题，但是很多问题要么是没回答出来要么是说的丢三落四。作为工作两年的我来说，感觉很丢人啊。顺便记下来，给后来人做个参考，最近自己也多花点时间打打基础。题目顺序不分类型和先后。</p><span id="more"></span><ol><li>byte,char,short,int各占几个字节？</li><li>char能存下一个汉字吗？</li><li>数据库常加哪些索引？不常用哪些索引？</li><li>SpringBoot启动类注解都有哪些？</li><li>SpringBoot怎么加载配置文件？</li><li>实现多线程的方式？</li><li>start() 方法和run() 的方法的区别？</li><li>jdk有几种线程池？newSingleThreadPool有什么作用？</li><li>ThreadPoolExecuror类的几个构造参数及其含义？拒绝策略有哪些？</li><li>String，StringBuffer，StringBuilder的异同？</li><li>String类为什么要设计成不可变的？</li><li>MySQL有哪些类型的索引？</li><li>大概说一下你对SpringMVC的理解？</li></ol><hr><p>1.<br>Integer a &#x3D; 123;<br>Integer b &#x3D; Integer.valueOf(123);</p><p>Integer a &#x3D; 300;<br>Integer b &#x3D; Integer.valueOf(300);<br>（-128到127 IntegerCache）</p><p>说一说以上代码执行的细节？说说拆装箱的细节？</p><ol start="2"><li><p>什么时候需要重写hashCode()方法和equals()方法？两个对象相等hashcode一定相等吗？</p></li><li><p>说一说HashMap的实现原理？当我put一个已经存在的键值对时怎么更新值的？</p></li><li><p>Spring中@Autowired和@Resource的区别？</p></li><li><p>ThreadPoolExecuror类的几个构造参数及其含义？</p></li><li><p>MySQL分页最后的页特别慢，说一说优化策略？</p></li><li><p>Java中的锁有了解吗？synchronized和Lock的区别？说一说synchronized的实现？</p></li></ol><hr><ol><li>String类是可变的吗？底层数据结构是什么？为什么要设计成不可变的？</li><li>ArrayList和LinkedList的区别？</li><li>HashMap的实现原理？构造方法及参数的含义？初始容量是多大？扩容策略？</li><li>有了解过B+树吗？</li><li>说一说你对IOC和AOP的理解？</li><li>说一说你对反射以及动态代理的理解？</li><li>如何实现进程间通信？</li><li>线程的生命周期？</li><li>一次Http请求的过程（osi七层模型以及三次握手）？两台主机断开连接的过程？</li><li>MySQL有哪些存储引擎，都在什么场景使用？</li></ol><hr><ol><li>有用过dubbo、RabbitMQ之类的中间件吗？</li><li>Java中的锁有了解过吗？</li><li>HashSet如何保证数据不重复？</li><li>说一说你对ConcurrentHashMap的理解？</li><li>concurrent包下面有哪些常用的类？</li><li>什么叫值传递？什么叫引用传递？Java属于哪种？为什么？</li><li>SpringCloud微服务有了解吗？</li><li>有做过Linux服务器上的应用部署吗？</li><li>Apache poi如何读取百万规模的数据？</li><li>你觉得Java和其他语言最显著的特征是什么？</li><li>在你的项目经历中有没有印象特别深刻的经历、有没有让你觉得成长很迅速的经历、有没有让你感觉很有成就感的经历、有没有曾经为项目突破瓶颈的经历？</li><li>有用过redis缓存吗？</li></ol><hr><ol><li>你有比较长远的职业生涯规划吗？</li><li>如果工作需要学习比如小程序开发之类的，你的态度是什么样？</li><li>你对待的加班的态度是什么样的？</li></ol><hr><p>暂时就能想起这么多了…</p>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象排序并去重——一道笔试题</title>
      <link href="/2020/10/27/64af4c9bdaa0/"/>
      <url>/2020/10/27/64af4c9bdaa0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>输入一行数据，格式如下：</p><pre><code> (abc,1),(123,2),(ddd,1),(abc,1)</code></pre><p>每一组数据(String, int)形式，左边为字符串，右边为优先级，将这一行数据按优先级从大到小排列，并且过滤掉字符串与优先级相同的数据， 相同优先级、字符串不同的按先后顺序显示，排列后结果如下：</p><pre><code>(123,2),(abc,1),(ddd,1)</code></pre><span id="more"></span><h2 id="分析题意"><a href="#分析题意" class="headerlink" title="分析题意"></a>分析题意</h2><p>我最开始的想法是：</p><ol><li>用正则表达式将字符串中的键值对提取出来；</li><li>将提取出来的键值对放到List&lt;Map&gt;中；</li><li>遍历List进行排序；</li></ol><p>但是真正开始写的时候第一步就卡住了，写出来的正则表达式只能提取最左边左括号到最右边右括号的内容，就是一整个字符串全给提取出来了，卡了半小时没办法，放弃了正则表达式的做法，改成了遍历 + split() 的方法。</p><p>拆分之后仔细想想，建一个实体类并且实现Comparable接口好像更简便一些，同时重写 hashCode() 方法和 equals() 方法再利用 Set 还能达到去重的效果，可以满足题目的要求。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>感觉代码有点又臭又长，明天再看下网上有没有这个题目，看看更标准的答案。</p><pre><code class="java">package com.test;import java.util.*;/** * @author :  zhulongkun20@gmail.com * @create :  10-27-2020 21:15:13 * @description :  按优先级排序并去重 * @since :  v1.0 */public class MediumMain &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        while (scanner.hasNext()) &#123;            String line = scanner.nextLine();            List&lt;Entity&gt; list = sort(line);            System.out.println(list);        &#125;    &#125;    private static List&lt;Entity&gt; sort(String inputLine) &#123;        String[] split1 = inputLine.split(&quot;\\),\\(&quot;);        Set&lt;Entity&gt; set = new HashSet&lt;&gt;();        for (int i = 0; i &lt; split1.length; i++) &#123;            String[] split2 = split1[i].split(&quot;,&quot;);            String str;            int priority;            if (i == 0) &#123;                str = split2[0].substring(1);            &#125; else &#123;                str = split2[0];            &#125;            if (i == split1.length - 1) &#123;                priority = Integer.parseInt(split2[1].split(&quot;\\)&quot;)[0]);            &#125; else &#123;                priority = Integer.parseInt(split2[1]);            &#125;            Entity entity = new Entity(str, priority);            set.add(entity);        &#125;        List&lt;Entity&gt; list = new ArrayList&lt;&gt;(set);        list.sort(Comparator.naturalOrder());        return list;    &#125;&#125;class Entity implements Comparable&lt;Entity&gt; &#123;    private String str;    private Integer priority;    public Entity(String str, Integer priority) &#123;        this.str = str;        this.priority = priority;    &#125;    // getter and setter        @Override    public int hashCode() &#123;        return str.hashCode() * priority.hashCode();    &#125;    @Override    public boolean equals(Object obj) &#123;        if (obj == null) &#123;            return false;        &#125; else if (this == obj) &#123;            return true;        &#125; else if (obj instanceof Entity) &#123;            Entity entity = (Entity) obj;            return entity.getPriority() == this.getPriority() &amp;&amp; entity.getStr().equals(this.getStr());        &#125;        return false;    &#125;    @Override    public int compareTo(Entity entity) &#123;        if (this.getPriority() &gt; entity.getPriority()) &#123;            return 1;        &#125; else if (this.getPriority() &lt; entity.getPriority()) &#123;            return -1;        &#125; else &#123;            return this.getStr().compareTo(entity.getStr());        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 去重 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《宇宙よりも遠い場所》台词-第四话</title>
      <link href="/2020/10/24/b0a0053eef11/"/>
      <url>/2020/10/24/b0a0053eef11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>无论何时，我们的第一步总是从好奇心开始。 不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。 为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅途。 在到达终点的时候，我们会想些什么呢？ 40度的咆哮，50度的疯狂，60度的呐喊，跨越荒芜的海源到达原生地域。 在地球的天边，远离文明的南方尽头。 这是向南极（比宇宙更远的地方）进发的四位女孩子的旅行物语。我们通过她们回想起生于明日的光辉！</p></blockquote><p>決まり：夢じゃない、嘘じゃない、間違えでもない！毎日確認してはは思う、学校で、家で、バイト先で、何度も何度も口にする、南極にいくんだ！</p><span id="more"></span><p>白瀬：ん。</p><p>A：本当に南極って言った。</p><p>決まり：いいの？</p><p>白瀬：いい、どうせ行くまでなに言っても信じてないから、本当に着いたら言うの。ザマアミロザマアミロザマアミロって。</p><p>決まり：へへ、性格悪いね。</p><p>白瀬：悪いよ、悪い？</p><p>決まり：いい！はは、、</p><br><p>先生：本当なんですね。この夏季訓練とか言うのが二日、その後、十二月から休むってことですか？</p><p>白瀬：はい。</p><p>先生：親御さんはなんって？</p><p>白瀬：許可は取ってあります。</p><p>先生：ん、玉木さんは？</p><p>決まり：ええと。</p><br><p>決まり：どう思う、リン？</p><p>リン：普通かな、冷蔵庫閉める音も普通だし、包丁のリズムもいつもと変わらないし。</p><p>決まり：よし！</p><p>リン：待って！なんか怪しい、普通すぎる、こっちに気づかれないように演技している的な、、</p><p>ママ：マリちゃん。</p><p>決まり：な、なに？</p><p>ママ：入浴剤買って来たから、お風呂場に置いてくれる？</p><p>決まり：うん。</p><p>ママ：そんなの剤あるだね。</p><p>決まり：こいつ、既に知ってる。や、かなる偶然ということもある、ヒットに動いても墓穴を掘ったら、しかし、気付いてたら、たとしたら、これ以上隠しておくのは状況を不利にするだけ、むしろ正極的に動いて、、</p><p>ママ：マリちゃん、どうかしたの？それとも、なにかあるの？南極に。</p><p>決まり：あ、あのね、お母さん、実は冬に旅行に行くことになりまして。</p><p>ママ：もう決定事項なんだ、お母さんなにも聞いてなかったな。今日近所の人に言われるまで、恥かいちゃった。</p><p>決まり：いえ、言うつもりだったんだよ、ただタイミングの問題というか、ハッキリしてからと言うか。</p><p>ママ：誰が書いたの？印鑑をしたのは？</p><p>決まり：待って待って、とりあえず、包丁をおこう、武器は。</p><p>ママ：武器じゃなくて、これは料理道具でしょ。もっとも、バカの娘を調理するにも使えそうだけどね。</p><p>決まり：なにその鬼っぽい台詞。</p><p>ババ：だたい、、</p><p>決まり：お父さん、お父さん、、</p><p>ババ：すまん、娘よ。</p><br><p>恵：全面的に決まりの責任だな。</p><p>決まり：一言でも終わらせないでよ、一個でも赤点取ったら行けないんだよ、そうじゃなくても、外集で勉強時間ないのに。</p><p>恵：じゃ、来週本気で休むのか？</p><p>決まり：土日入れて四日間だから、火曜までだけど。</p><p>恵：ほんとに大丈夫なのか？船が出るかまだ怪しいって書いてあったぞ。</p><p>決まり：まあ、それが今考えてもしょうがないし、う、バイト行きなきゃ。</p><p>恵：大変だな。</p><p>決まり：じゃ。</p><p>恵：無理にしすぎないようにな。</p><p>決まり：うん？</p><p>恵：それ以上頑張ってダメだったら、すごい後悔するだろうから。</p><p>決まり：うん、行って来ます！</p><br><p>決まり：よろしくお願いします！</p><p>日向：嫌だ。</p><p>決まり：なんで？</p><p>日向：あのな、高校へ行ってるってことは授業を受てるってことだろう、一日の中でそれだけ勉強に集中する時間を与えられてと言うことだ。それでできないっては本人の努力の問題じゃん。大体勉強なんて、本当と違ってやれば矢田だけできるんようになるんだよ。</p><p>白瀬：正論ね。</p><p>決まり：敵？</p><p>白瀬：敵もなにもない、ただ日向言ってることは正しい。</p><p>決まり：いいもん、結月ちゃんに頼むも。</p><p>日向：後輩だぞ。</p><p>決まり：着いたってよ。</p><p>結月：おはようございます。</p><p>決まり：なんか雰囲気違う。</p><p>結月：この前は仕事だたので仕方なく。</p><p>決まり：仕方なく？</p><p>結月：ああ言う可愛い系に似合わないじゃなですか？性格的に違うっていかか。</p><p>白瀬：そう？</p><p>日向：可愛いと思うけどな。</p><p>結月：嫌いなんですよ、ああ言う女子ですみたいなの。</p><p>決まり：なんで不機嫌なの？</p><p>日向：まあ、あの仕事はあの仕事でいろいろ複雑なんだろう。</p><p>決まり：ここ？</p><p>日向：間違いない。</p><p>B：お待たせー、分かりにくくてごめんね、でさ、乗って。お、今片付けるね、ごめんごめん。</p><p>結月：なんか、ちょっとイメージが違いません。</p><p>決まり：ん。</p><p>B：イメージと違った？まあ、そうよね、南極観測隊って言ったら、大プロジェクトだものね、一車民間とはいえ、こんあボロチンボックスだね。</p><p>決まり：なんで答えればいいの？</p><p>日向：静か！</p><p>B：しかし、まさかあなたが同行者になってここまで来るってはね。百万円をどうしたの？</p><p>白瀬：まだあります。</p><p>決まり：もしかして、必要ですか？</p><p>B：報道の通りお金がないけど、それは南極二行くための費用多く撮っているから、その分、削れるところは決定的に削ってるだけよ、中止になることは絶対にないから安心して。あなたたちは知らないだろうけど、このプロジェクトが立ち上げてからずっと言われて続けるの、お金が足りない、危険じゃなのか？もう慣れこう。</p><p>結月：そうなんですね。</p><p>B：そんな報道あるたびに、メンバーといつも事務所で行ってるは、うるせい、バーカ！ってね。</p><p>決まり：一緒ですね！</p><p>B：そうなの？</p><p>決まり：はい！</p><p>結月：山、ですね。</p><p>決まり：気持ちいい。</p><p>B：とはいえ、外に出るのは明後日から、今日と明日はミッチリ講義よ、おい、ヘイトヘイト。</p><p>B：資料を確認してね。</p><p>決まり：お、すごい、基地要覧だって。</p><p>結月：内部資料、取扱留意。</p><p>日向：お、雪上車、なんかあがるまん。</p><p>B：その資料をもとに、これからあなたたち四人には他の隊員が冬と夏に受ける訓練と同等のものを凝縮化して受けてます、南極は定住して人間がいない世界で唯一の大陸よ。そこには日本とは違い、いろんな決め事やルールがある、それをここできちんと覚えていてね。</p><p>決まり：はい！</p><p>白瀬：学校とは大違いね。</p><p>決まり：クラス違うでしょう。</p><p>B：だは、早速、隊長挨拶から。</p><p>隊長：南極観測隊隊長、藤堂吟です。</p><p>決まり：隊長。</p><p>結月：女性なんですか？</p><p>隊長：最初に言っておきますが、私は隊員は同行者であろうが研究者であろうが等しく同等だと思ってます。やることは山ほどある、高校生であろうと必要であれば、掃除洗濯から力仕事までどんどんやてもらえます、そのつもりでいってください。</p><p>〜：はい！</p><p>隊長：南極観測隊員のABCというのがあります、A：当たり前のこと、B：ボッケとしないで、ちゃんとやれ。常に、その意識を持ってほしい。</p><br><p>決まり：なんか「隊長」ってな感じな人だね。</p><p>結月：居眠りしてたら、直トン的そうな。</p><p>決まり：テストとかあったら、超難しい問題作りそうだよね。</p><p>日向：それより、明日はルート考査だろう。</p><p>決まり：うん、外出るんでしょう、山来たんだもん、ジャタくらい出ないとね。</p><p>日向：とはいえ、結構大変だぞ、これ。</p><p>B：どうだった？</p><p>隊長：なにが？</p><p>B：久々の再会は。</p><p>隊長：言ったでしょう？私は隊員は同等に扱う。</p><p>B：はいはい。</p><p>隊長：まさとこうしたの？</p><p>B：うん、私はなにもしてない、本当にあの子頑張ってここまでに来たの、でも、正直おか〜たかな、初めてあの子は一緒に行きたい言って時から、貴子の娘だも。</p><br><p>決まり：これは？</p><p>結月：トランシーバーだと思います、これがコンパスと言う、こっちがGPS測る機械で。</p><p>決まり：と旗、日向ちゃん分かった？</p><p>日向：昨日大体を総たしな。</p><p>決まり：でも、なんでこんなことするの？南極って真っ平なんでしょう、道蘭作らなくてもいけるんじゃないの？</p><p>白瀬：逆、真っ平の真っ白だから、吹雪にると方向はわからなくなる、だからルートを作って、そこを通ようにするわけ。</p><p>決まり：お、それで目印にこの旗に立てるわけだ、でもどこに？</p><p>日向：それを自分でやるのがこの訓練だろう。こっちが今私たちいる所だ、そしてここにあるのが目的地。</p><p>決まり：そこに行けばいいの？</p><p>日向：ただ行くんじゃなく、途中にあるこことこことここ、こう言うポイントに旗を立ってて行く。</p><p>結月：なるほどですね。</p><p>決まり：よし、やろ！あっちの方だよね。</p><p>日向：待って待って、そんなに雑乳に動き出してどうする？ポイントがどこにあるのがわかるのか？</p><p>決まり：え、あそこ、らへん？</p><p>日向：らへんじゃないだろう。</p><p>白瀬：それで正確な位置を測って進むの。</p><p>決まり：お、なんか、むずしかそうな予感。</p><p>決まり：４８、４９、５０、ここだよ。</p><p>日向：角度見て。</p><p>白瀬：これ、右目、左目？どっちで見るの？</p><p>日向：きけ目じゃないのか？</p><p>白瀬：きけ目で？</p><p>結月：確かこうやて。</p><p>決まり：まだ？</p><p>白瀬：１６８度。</p><p>日向：もっと右。</p><p>決まり：右？</p><p>日向：右。</p><p>決まり：右？</p><p>日向：そう。</p><p>白瀬：そこ。</p><p>結月：えと、緯度かこれって、経度は、さっきよりもちょっと距離ありません？</p><p>日向：計算が正しければ、今ここにいるはずなんだよな。</p><p>B：そこか？だいぶズレちゃってるね、思い出すわ、自分が初めて参加したのこと。</p><p>隊長：残りの三人はなんだと？</p><p>B：そう、お一人は元々参加させよとしただけどでしょう、いつの間仲間よくになったみたいだけど。</p><p>結月：他の隊員の人たちは時間競ってるってましたけど。</p><p>白瀬：でも、大切なのは時間よりも正確さだと思う。</p><p>日向：安全第一だもな。</p><p>白瀬：じゃ、行くよ、１、２、３９８、３９９、４００、はい、ここ。</p><p>決まり：左に二歩、はい、そこ！</p><p>日向：よ、素早い、しかし、よく分かったな、決まりがコンパス得意だって。</p><p>結月：なんかっぽいって言うか。</p><p>決まり：コンパスのエキスパートと呼んで、名付けてコンパサ。</p><br><p>〜：最初はグージャンケンボン。</p><p>決まり：よし、私ここ、修学旅行みたいだね。</p><p>日向：遊びに来たわけじゃないだぞ。</p><p>白瀬：テントで寝るのも立派な訓練の所。</p><p>決まり：でも、まだ８時前だよ、ほら、隊長も合宿の夜は親睦会やるって言ってたし。</p><p>日向：いいから、寝ろう！</p><p>決まり：なんか話そよ。</p><p>日向：こっち抜くな。</p><p>決まり：怖い話言っちゃう？</p><p>結月：軽く死なせますよ。</p><p>決まり：あ、もしかして結月ちゃん嫌いなの怖い話。</p><p>結月：うるかにしてください。</p><p>決まり：うるかにしてくださいってなに？</p><p>結月：一応先輩だから言い直したんです、もう言いたいことはわかるからいいじゃないですか。</p><p>決まり：うるかにしてください。</p><p>日向：いいから、やめろ、決まり。</p><p>決まり：白瀬ちゃんは寝っちゃった？聞こうと思ってたんだけど、白瀬ちゃんってさ、隊長さんと知り合いなの？</p><p>白瀬：どうして？</p><p>決まり：なんとなく。</p><p>白瀬：あの人はお母さんが高校のごろ知り合い、お母さんと一緒南極に行った人、あの人は帰って来て、お母さんだけは帰ってこなかった、それだけ。</p><p>決まり：満天、北極星どれ？</p><p>結月：ええと、北斗七星のなにか伸ばすしたんだっけ。</p><p>日向：カシュベヤだろう？</p><p>決まり：南極星は？</p><p>結月：南極星？あるんですか？</p><p>日向：一応あるよ、そんなにはっきりとは見えないらしいけど。</p><p>決まり：はは、どれ？</p><p>日向：ここから見えるわけないだろう、空にある星が全てと思うな。</p><p>決まり：日向ちゃんの言葉でしょう。</p><p>日向：ちょっとでき悪かったな。</p><p>隊長：こちは昭和基地、オオロラ隊、聞こえますか？どうぞ。</p><p>決まり：きた。</p><p>日向：こちはオオロラ隊、三宅です、こんど良好です、どうぞ。</p><p>隊長：例実交信です、異常ありませんか？そうぞ。</p><p>日向：本日、オオロラ隊四名、人員、装備、異常なしです、どうぞ。</p><p>隊長：わかりました、明けると〜体調に注意して、例実交信終わります、ご安全に。</p><p>日向：ご安全に。</p><p>結月：本当に来ましたね。</p><p>日向：お忘る所だ。</p><br><p>決まり：寒い、あの、なにが見えますか？白瀬ちゃんのお母さんってどんな人だったんですか？</p><p>隊長：どんなと聞こると、変な人ってと答えしか出てこないね。</p><p>決まり：白瀬ちゃんと似ってます？</p><p>隊長：そう、私は娘のことがよく知らなく、ただ、あのひつこさと思いこみ強さはそっくりね、めんどくさい。</p><p>決まり：いいですよね、めんどくさいの。</p><p>隊長：南極向の性格ね、あなたは。</p><p>決まり：本当ですか？</p><p>隊長：どうして南極に？</p><p>決まり：え？</p><p>隊長：あの子に誘われた？</p><p>決まり：はい、でも決めたのは私です、一緒に行きたいって、このまま高校生活が終わるの嫌だって、ここじゃない、どこかに行きたいって。</p><p>隊長：そう。</p><p>決まり：でも、日向ちゃんと知り合って、結月ちゃんと知り合って、観測隊の人の気持ちを知って、隊長と白瀬ちゃんのことを聞いて思いました、どこかじゃない、南極だって。私みんなと南極に行って。</p><p>決まり：みんな、起きて。</p><p>日向：なんだ？</p><p>結月：朝苦手なんです。</p><p>決まり：いいから、起きて、白瀬ちゃんも！早く、早く！</p><p>決まり：私、みんなと行きたい、みんなと一緒南極星を見つけて、オオロラ見て、かき氷を食べて、ペンギンと記念写真撮りたい！絶対行こう！</p><p>白瀬：ん。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 动漫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thymeleaf传值给bootstrap的modal</title>
      <link href="/2020/10/24/50cde902b31f/"/>
      <url>/2020/10/24/50cde902b31f/</url>
      
        <content type="html"><![CDATA[<p>给模态框传值是一个很常见的需求，尤其是在操作表格的时候，添加、编辑数据都需要给模态框传值。一般如果是html的话很好处理，在Thymeleaf里因为值是动态的所以遇到点问题。</p><span id="more"></span><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>这是模态框的定义：</p><pre><code class="html">&lt;!-- 修改数据 --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;edit_bill&quot; role=&quot;dialog&quot;&gt;    &lt;div class=&quot;modal-dialog&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;            &lt;div class=&quot;modal-header&quot;&gt;                &lt;p&gt;新增数据&lt;/p&gt;            &lt;/div&gt;            &lt;div class=&quot;modal-body&quot;&gt;                &lt;form th:action=&quot;@&#123;/bill/edit&#125;&quot; method=&quot;post&quot;&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;div class=&quot;form-group&quot;&gt;                            &lt;label for=&quot;billId1&quot;&gt;id&lt;/label&gt;                            &lt;input type=&quot;text&quot; name=&quot;billId&quot; class=&quot;form-control&quot; id=&quot;billId&quot; placeholder=&quot;&quot;&gt;                        &lt;/div&gt;                    &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交表单&lt;/button&gt;                &lt;/form&gt;            &lt;/div&gt;            &lt;div class=&quot;modal-footer&quot;&gt;                &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭                &lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>这是按钮的定义：</p><pre><code class="html">&lt;tr th:if=&quot;$&#123;not #lists.isEmpty(result.getData().getDataList())&#125;&quot;    th:each=&quot;bill, stat: $&#123;result.getData().getDataList()&#125;&quot;&gt;    &lt;td style=&quot;display: none&quot; th:text=&quot;$&#123;bill.billId&#125;&quot;&gt;Test001&lt;/td&gt;    &lt;td&gt;        &lt;div class=&quot;btn-group&quot;&gt;            &lt;button id=&quot;edit&quot; class=&quot;btn btn-info&quot; data-toggle=&quot;modal&quot; data-target=&quot;#edit_bill&quot; th:attr=&quot;data-bill-id=$&#123;bill.billId&#125;&quot;&gt;修改&lt;/button&gt;        &lt;/div&gt;    &lt;/td&gt;&lt;/tr&gt;</code></pre><p>想在点击修改按钮的时候将 <code>billId</code> 这个值传到弹出框里。</p><p>值得注意的是Thymeleaf中data-*的写法： </p><pre><code class="html">&lt;!-- 不是 --&gt;data-bill-id=&quot;$&#123;bill.billId&#125;&quot;&lt;!-- 而是 --&gt;th:attr=&quot;data-bill-id=$&#123;bill.billId&#125;&quot;</code></pre><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>点击按钮的时候执行通过事件取值，但是我没成功，甚至连log都没输出，应该是没有执行，不知道是不是和Thymeleaf有关。</p><pre><code class="javascript">$(document).ready(function()    $(&#39;#edit_bill&#39;).on(&#39;show.bs.modal&#39;, function (event) &#123;        var billId = $(event.relatedTarget.data(&#39;bill-id&#39;);        $(event.currentTarget).find(&#39;input[name=&quot;billId&quot;]&#39;).val(billId);    &#125;);&#125;);</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>这种写法能成功取到值，对js不是很了解，看不出两者有什么差别。</p><pre><code class="java">$(document).on(&quot;click&quot;, &quot;#edit&quot;, function() &#123;    var billId = $(this).data(&quot;bill-id&quot;);    $(&quot;#billId&quot;).val(billId);&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thymeleaf </tag>
            
            <tag> 模态框传值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.04安装Mariadb修改初始密码</title>
      <link href="/2020/10/22/15cf386d74ea/"/>
      <url>/2020/10/22/15cf386d74ea/</url>
      
        <content type="html"><![CDATA[<p>Ubuntu 18.04安装Mariadb修改初始密码</p><p>在Ubuntu环境下新安装Mariadb数据库之后，所有的配置文件里都没有默认密码，然后用root用户和空密码也登不进去，浪费了好长时间，将解决的过程记录一下。</p><p>MySQL版本：<strong>10.1.47-MariaDB-0+deb9u1 Debian 9.13</strong></p><p>在StackOverflow上找到的解决方法 &gt;&gt;&gt;  <a href="https://stackoverflow.com/questions/39281594/error-1698-28000-access-denied-for-user-rootlocalhost">ERROR 1698 (28000): Access denied for user ‘root‘@’localhost</a>‘](<a href="https://stackoverflow.com/questions/39281594/error-1698-28000-access-denied-for-user-rootlocalhost">https://stackoverflow.com/questions/39281594/error-1698-28000-access-denied-for-user-rootlocalhost</a>)</p><span id="more"></span><pre><code>zhulongkun20@v2ray:mysqld_safe --skip-grant-tableszhulongkun20@v2ray:sudo /etc/init.d/mysql restartzhulongkun20@v2ray:sudo mysql进入到 MySQL 后台MariaDB [(none)]&gt;执行SQL修改密码MariaDB [(none)]&gt; update mysql.user set password=PASSWORD(&quot;root&quot;) where user=&quot;root&quot;;刷新MariaDB [(none)]&gt; flush privileges;MariaDB [(none)]&gt; exitBye重启zhulongkun20@v2ray:/etc$ sudo /etc/init.d/mysql restart[ ok ] Restarting mysql (via systemctl): mysql.service.登录然后还是报错zhulongkun20@v2ray:mysql -uroot -pERROR 1698 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39;</code></pre><p>解决问题：</p><pre><code>zhulongkun20@v2ray:mysqld_safe --skip-grant-tableszhulongkun20@v2ray:sudo /etc/init.d/mysql restartzhulongkun20@v2ray:sudo mysql进入到 MySQL 后台MariaDB [(none)]&gt;MariaDB [(none)]&gt; use mysql;MariaDB [mysql]&gt; SELECT User, Host, plugin FROM mysql.user;+------+-----------+-------------+| User | Host      | plugin      |+------+-----------+-------------+| root | localhost | unix_socket |+------+-----------+-------------+1 row in set (0.00 sec)MariaDB [mysql]&gt; UPDATE user SET plugin=&#39;mysql_native_password&#39; WHERE User=&#39;root&#39;;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0MariaDB [mysql]&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.01 sec)然后退出MariaDB [mysql]&gt; exit杀掉所有进程后重启登录即可：zhulongkun20@v2ray:~$ mysql -uroot -p</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@PreAuthorize and @PostAuthorize</title>
      <link href="/2020/10/20/946f65fff5bf/"/>
      <url>/2020/10/20/946f65fff5bf/</url>
      
        <content type="html"><![CDATA[<p>@PreAuthorize 和 @PostAuthorize是SpringSecurity中常用的两个注解，简单了解一下他们的用法吧！</p><span id="more"></span><h2 id="开启验证"><a href="#开启验证" class="headerlink" title="开启验证"></a>开启验证</h2><pre><code class="java">package com.bill.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;/** * @author :  zhulongkun20@gmail.com * @create :  10-20-2020 15:27:16 * @description :  SpringSecurity配置类 * @since :  v1.0 */@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)public class SpringSecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        // 基于内存的方式构建两个用户，user/123456，admin/123456        auth.inMemoryAuthentication()                .passwordEncoder(passwordEncoder())                .withUser(&quot;admin&quot;)                .password(passwordEncoder().encode(&quot;123456&quot;))                .roles(&quot;admin&quot;);        auth.inMemoryAuthentication()                .passwordEncoder(passwordEncoder())                .withUser(&quot;user&quot;)                .password(passwordEncoder().encode(&quot;123456&quot;))                .roles(&quot;normal&quot;);    &#125;    @Bean    public PasswordEncoder passwordEncoder() &#123;        return new BCryptPasswordEncoder();    &#125;&#125;</code></pre><h2 id="PreAuthorize注解"><a href="#PreAuthorize注解" class="headerlink" title="@PreAuthorize注解"></a>@PreAuthorize注解</h2><pre><code class="java">package com.bill.controller;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * @author :  zhulongkun20@gmail.com * @create :  10-20-2020 15:22:13 * @description :  HomeController * @since :  v1.0 */@Controller@RequestMapping(&quot;/hello&quot;)public class HelloController &#123;    @GetMapping(&quot;/&quot;)    @ResponseBody    public String sayHello() &#123;        return &quot;Hello, spring security.&quot;;    &#125;    @GetMapping(&quot;/helloNormal&quot;)    @ResponseBody    @PreAuthorize(&quot;hasAnyRole(&#39;normal&#39;)&quot;)    public String helloNormal() &#123;        return &quot;Hello, normal.&quot;;    &#125;    @GetMapping(&quot;/helloAdmin&quot;)    @ResponseBody    @PreAuthorize(&quot;hasAnyRole(&#39;admin&#39;)&quot;)    public String helloAdmin() &#123;        return &quot;Hello, admin&quot;;    &#125;&#125;</code></pre><p>当@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)开启的时候，@PreAuthorize注解生效，支持SpringEL表达式，</p><pre><code class="java">// 只要有其中一个权限即可访问@PreAuthorize(&quot;hasAnyRole(&quot;admin&quot;, &quot;normal&quot;)&quot;)// 同时满足条件才可以访问@PreAuthorize(&quot;hasRole(&#39;admin&#39;) AND hasRole(&#39;normal&#39;)&quot;)</code></pre><h2 id="PostAuthorize"><a href="#PostAuthorize" class="headerlink" title="@PostAuthorize"></a>@PostAuthorize</h2><p>@PostAuthorize 注解使用并不多，在方法执行后再进行权限验证，适合验证带有返回值的权限，Spring EL 提供返回对象能够在表达式语言中获取返回的对象returnObject。</p><p>当@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)的时候，@PostAuthorize可以使用：</p><pre><code class="java">@GetMapping(&quot;/helloUser&quot;)@PostAuthorize(&quot;returnObject != null &amp;&amp;  returnObject.username == authentication.name&quot;)public User helloUser() &#123;    Object pricipal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();    User user;    if (&quot;anonymousUser&quot;.equals(pricipal)) &#123;        user = null;    &#125; else &#123;        user = (User) pricipal;    &#125;    return user;&#125;</code></pre><p>内置表达式：</p><table><thead><tr><th align="left">表达式</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">hasRole([role])</td><td align="left">如果有当前角色, 则返回 true(会自动加上 ROLE_ 前缀)</td></tr><tr><td align="left">hasAnyRole([role1, role2])</td><td align="left">如果有任一角色即可通过校验, 返回true,(会自动加上 ROLE_ 前缀)</td></tr><tr><td align="left">hasAuthority([authority])</td><td align="left">如果有指定权限, 则返回 true</td></tr><tr><td align="left">hasAnyAuthority([authority1, authority2])</td><td align="left">如果有任一指定权限, 则返回true</td></tr><tr><td align="left">principal</td><td align="left">获取当前用户的 principal 主体对象</td></tr><tr><td align="left">authentication</td><td align="left">获取当前用户的 authentication 对象,</td></tr><tr><td align="left">permitAll</td><td align="left">总是返回 true, 表示全部允许</td></tr><tr><td align="left">denyAll</td><td align="left">总是返回 false, 代表全部拒绝</td></tr><tr><td align="left">isAnonymous()</td><td align="left">如果是匿名访问, 返回true</td></tr><tr><td align="left">isRememberMe()</td><td align="left">如果是remember-me 自动认证, 则返回 true</td></tr><tr><td align="left">isAuthenticated()</td><td align="left">如果不是匿名访问, 则返回true</td></tr><tr><td align="left">isFullAuthenticated()</td><td align="left">如果不是匿名访问或remember-me认证登陆, 则返回true</td></tr><tr><td align="left">hasPermission(Object target, Object permission)</td><td align="left"></td></tr><tr><td align="left">hasPermission(Object target, String targetType, Object permission)</td><td align="left"></td></tr></tbody></table><h2 id="Secured"><a href="#Secured" class="headerlink" title="@Secured"></a>@Secured</h2><p>当@EnableGlobalMethodSecurity(securedEnabled &#x3D; true)的时候，@Secured可以使用。</p><pre><code class="java">@GetMapping(&quot;/helloUser&quot;)@Secured(&#123;&quot;ROLE_admin&quot;, &quot;ROLE_normal&quot;&#125;)public String helloUser() &#123;    return &quot;hello, user&quot;;&#125;</code></pre><p>拥有normal或者admin角色的用户都可以访问helloUser()方法。另外需要注意的是这里 <strong>匹配的字符串需要添加前缀“ROLE_“</strong>，如果我们要求，只有同时拥有admin &amp; normal的用户才能访问helloUser()方法，这时候@Secured就无能为力了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式</title>
      <link href="/2020/10/20/c1fbc1b9ca41/"/>
      <url>/2020/10/20/c1fbc1b9ca41/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式的意义"><a href="#设计模式的意义" class="headerlink" title="设计模式的意义"></a>设计模式的意义</h2><p>设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路，它不是语法规定，而是一套 <strong>用来提高代码可复用性、可维护性、可读性、稳健性以及安全性</strong> 的解决方案。</p><p>23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。</p><p>当然，软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择：</p><ul><li>对于简单的程序，可能写一个简单的算法要比引入某种设计模式更加容易；</li><li>但是对于大型项目开发或者框架设计，用设计模式来组织代码显然更好。</li></ul><span id="more"></span><h2 id="设计模式的要素"><a href="#设计模式的要素" class="headerlink" title="设计模式的要素"></a>设计模式的要素</h2><ul><li>模式的名称；</li><li>要解决的问题类型；</li><li>解决方案；</li><li>效率、安全及可移植性等优缺点评估。</li></ul><h2 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>软件实体应当对扩展开放，对修改封闭。（open for entension, but closed for modification.），使软件有一定的扩展性同时具备稳定性。</p><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。</p><p>里氏替换原则的主要作用如下：</p><ol><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>它克服了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li></ol><p><strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong></p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。</p><p>依赖倒置原则的主要作用如下：</p><ul><li>依赖倒置原则可以降低类间的耦合性。</li><li>依赖倒置原则可以提高系统的稳定性。</li><li>依赖倒置原则可以减少并行开发引起的风险。</li><li>依赖倒置原则可以提高代码的可读性和可维护性。</li></ul><pre><code class="java">public class DIPTest &#123;    public static void main(String[] args) &#123;        Customer wang = new Customer();        System.out.println(&quot;顾客购买以下商品：&quot;);        wang.shopping(new ShaoguanShop());        wang.shopping(new WuyuanShop());    &#125;&#125;//商店interface Shop &#123;    public String sell(); //卖&#125;//韶关网店class ShaoguanShop implements Shop &#123;    public String sell() &#123;        return &quot;韶关土特产：香菇、木耳……&quot;;    &#125;&#125;//婺源网店class WuyuanShop implements Shop &#123;    public String sell() &#123;        return &quot;婺源土特产：绿茶、酒糟鱼……&quot;;    &#125;&#125;//顾客class Customer &#123;    public void shopping(Shop shop) &#123;        //购物        System.out.println(shop.sell());    &#125;&#125;</code></pre><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。</p><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点：</p><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li><li>提高类的可读性。复杂性降低，自然其可读性会提高。</li><li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li><li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点：</p><ol><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ol><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p><p>单例模式有 3 个特点：</p><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点。</li></ol><p>单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面：</p><ul><li>需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。</li><li>某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。</li><li>某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li><li>频繁访问数据库或文件的对象。</li><li>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li></ul><p>两种实现方式：</p><pre><code class="java">public class SingletonMode &#123;    private static final SingletonMode instance = new SingletonMode();    private SingletonMode() &#123;    &#125;    public SingletonMode getInstance() &#123;        return instance;    &#125;&#125;</code></pre><pre><code class="java">public class SingletonMode &#123;    private static volatile SingletonMode singletonMode = null;    private SingletonMode() &#123;    &#125;    public SingletonMode getInstance() &#123;        if (singletonMode == null) &#123;            singletonMode = new SingletonMode();        &#125;        return singletonMode;    &#125;&#125;</code></pre><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确；</li><li>客户端无需知道所创建具体产品的类名，只需知道参数即可；</li><li>也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则；</li><li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度；</li><li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂；</li><li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ol><pre><code class="java">public interface Product &#123;    void showInfo();&#125;</code></pre><pre><code class="java">public class ProductA implements Product &#123;    @Override    public void showInfo() &#123;        System.out.println(&quot;A product&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class ProductB implements Product &#123;    @Override    public void showInfo() &#123;        System.out.println(&quot;B product&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class ProductFactory &#123;    public void makeProduct(Product product) &#123;        product.showInfo();    &#125;&#125;</code></pre><pre><code class="java">public class ProductFactoryTest &#123;    public static void main(String[] args) &#123;        ProductFactory productFactory = new ProductFactory();        productFactory.makeProduct(new ProductA());    &#125;&#125;</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li><li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li><li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>类的个数容易过多，增加复杂度</li><li>增加了系统的抽象性和理解难度</li><li>抽象产品只能生产一种产品，此弊端可使用<a href="http://c.biancheng.net/view/1351.html">抽象工厂模式</a>解决。</li></ul><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li><li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li><li>客户不关心创建产品的细节，只关心产品的品牌</li></ul><h4 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>工厂方法模式的主要角色如下：</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ol><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ol><p>抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。</p><p><img src="http://c.biancheng.net/uploads/allimg/181114/3-1Q11416002NW.gif"></p><pre><code class="java">public interface ProductTypeA &#123;    void show();&#125;</code></pre><pre><code class="java">public interface ProductTypeB &#123;    void show();&#125;</code></pre><pre><code class="java">public class ProductA implements ProductTypeA &#123;    @Override    public void show() &#123;        System.out.println(&quot;product a&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class ProductB implements ProductTypeB &#123;    @Override    public void show() &#123;        System.out.println(&quot;product b&quot;);    &#125;&#125;</code></pre><pre><code class="java">public interface ProductFacotry &#123;    ProductTypeA productA(ProductTypeA productTypeA);    ProductTypeB productB(ProductTypeB productTypeB);&#125;</code></pre><pre><code class="java">public class FacotryA implements ProductFacotry &#123;    @Override    public ProductTypeA productA(ProductTypeA productTypeA) &#123;        System.out.println(&quot;a product&quot;);        return null;    &#125;    @Override    public ProductTypeB productB(ProductTypeB productTypeB) &#123;        System.out.println(&quot;b product&quot;);        return null;    &#125;&#125;</code></pre><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的<a href="http://c.biancheng.net/design_pattern/">设计模式</a>被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p><p>该模式的主要优点如下：</p><ol><li>封装性好，构建和表示分离。</li><li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li><li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li></ol><p>其缺点如下：</p><ol><li>产品的组成部分必须相同，这限制了其使用范围。</li><li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li></ol><p>建造者（Builder）模式的主要角色如下。</p><ol><li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。</li><li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li><li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol><p><img src="http://c.biancheng.net/uploads/allimg/181114/3-1Q1141H441X4.gif"></p><pre><code class="java">public class Product &#123;    private String partA;    private String partB;    private String partC;    public void setPartA(String partA) &#123;        this.partA = partA;    &#125;    public void setPartB(String partB) &#123;        this.partB = partB;    &#125;    public void setPartC(String partC) &#123;        this.partC = partC;    &#125;&#125;</code></pre><pre><code class="java">public abstract class Builder &#123;    protected Product product = new Product();    public abstract void buildPartA();    public abstract void buildPartB();    public abstract void buildPartC();    public Product getResult() &#123;        return product;    &#125;&#125;</code></pre><pre><code class="java">public class ConcreteBuilder extends Builder &#123;    @Override    public void buildPartA() &#123;        product.setPartA(&quot;A&quot;);    &#125;    @Override    public void buildPartB() &#123;        product.setPartB(&quot;B&quot;);    &#125;    @Override    public void buildPartC() &#123;        product.setPartC(&quot;C&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class Director &#123;    private Builder builder;    public Director(Builder builder) &#123;        this.builder = builder;    &#125;    public Product construct() &#123;        builder.buildPartA();        builder.buildPartB();        builder.buildPartC();        return builder.getResult();    &#125;&#125;</code></pre><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>代理模式的主要优点有：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li><strong>代理对象可以扩展目标对象的功能</strong>；</li><li>代理模式能将客户端与目标对象分离，在一定程度 <strong>降低了系统的耦合度，增加了程序的可扩展性</strong>。</li></ul><p>其主要缺点是：</p><ul><li>代理模式会造成系统设计中类的数量增加；</li><li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li><li><strong>增加了系统的复杂度</strong>。</li></ul><p>代理模式的主要角色如下。</p><ol><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li></ol><p><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q115093011523.gif"></p><pre><code class="java">public interface Subject &#123;    void request();&#125;</code></pre><pre><code class="java">public class RealSubject implements Subject &#123;    @Override    public void request() &#123;        System.out.println(&quot;真实主题&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class Proxy implements Subject &#123;    private RealSubject realSubject;    @Override    public void request() &#123;        if (realSubject == null) &#123;            realSubject = new RealSubject();        &#125;        preRequest();        realSubject.request();        postRequest();    &#125;    public void preRequest() &#123;        System.out.println(&quot;访问之前的处理&quot;);    &#125;    public void postRequest() &#123;        System.out.println(&quot;访问之后的处理&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class ProxyTest &#123;    public static void main(String[] args) &#123;        Proxy proxy = new Proxy();        proxy.request();    &#125;&#125;</code></pre><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><p>该模式的主要优点如下：</p><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li><strong>复用了现存的类</strong>，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li><li>在很多业务场景中符合开闭原则。</li></ul><p>其缺点是：</p><ul><li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li><li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li></ul><p>类适配器：</p><p><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151045351c.gif"></p><p>对象适配器：</p><p><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151046105A.gif"></p><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p><p>装饰（Decorator）模式的主要优点有：</p><ul><li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用；</li><li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果；</li><li>装饰器模式完全遵守开闭原则；</li></ul><p>其主要缺点是：装饰模式会增加许多子类，过度使用会增加程序得复杂性。</p><p>装饰模式主要包含以下角色。</p><ol><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ol><p>测试代码：</p><pre><code class="java">public interface Component &#123;    void operation();&#125;public class ConcreteComponent implements Component &#123;    public ConcreteComponent() &#123;        System.out.println(&quot;创建具体构件角色&quot;);    &#125;    @Override    public void operation() &#123;        System.out.println(&quot;调用具体构件角色的方法operation()&quot;);    &#125;&#125;public class Decorator implements Component &#123;    private Component component;    public Decorator(Component component) &#123;        this.component = component;    &#125;    @Override    public void operation() &#123;        component.operation();    &#125;&#125;public class ConcreteDecorator extends Decorator &#123;    public ConcreteDecorator(Component component) &#123;        super(component);    &#125;    public void operation() &#123;        super.operation();        addFunction();    &#125;    public void addFunction() &#123;        System.out.println(&quot;添加功能&quot;);    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        Component component = new ConcreteComponent();        component.operation();        Component component1 = new ConcreteDecorator(component);        component1.operation();    &#125;&#125;</code></pre><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><strong>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</strong></p><p>在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。</p><p>如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。</p><p>策略模式的主要优点如下：</p><ol><li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li><li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li><li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li><li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li><li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li></ol><p>其主要缺点如下。</p><ol><li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li><li>策略模式造成很多的策略类。</li></ol><p>策略模式的主要角色如下。</p><ol><li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现；</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ol><p><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q116103K1205.gif"></p><p>代码：</p><pre><code class="java">public interface Strategy &#123;    void strategyMethod();&#125;public class ConcreteStrategyA implements Strategy &#123;    @Override    public void strategyMethod() &#123;        System.out.println(&quot;具体策略A&quot;);    &#125;&#125;public class ConcreteStrategyB implements Strategy &#123;    @Override    public void strategyMethod() &#123;        System.out.println(&quot;具体策略B&quot;);    &#125;&#125;public class Context &#123;    private Strategy strategy;    public void strategyMethod() &#123;        strategy.strategyMethod();    &#125;    public Strategy getStrategy() &#123;        return strategy;    &#125;    public void setStrategy(Strategy strategy) &#123;        this.strategy = strategy;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        Context context = new Context();        Strategy strategy = new ConcreteStrategyA();        context.setStrategy(strategy);        context.strategyMethod();        System.out.println(&quot;-----&quot;);        Strategy strategy1 = new ConcreteStrategyB();        context.setStrategy(strategy1);        context.strategyMethod();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV中的Canny边缘检测</title>
      <link href="/2020/10/19/05981d0183dd/"/>
      <url>/2020/10/19/05981d0183dd/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="噪声去除"><a href="#噪声去除" class="headerlink" title="噪声去除"></a>噪声去除</h2><p>由于边缘检测很容易受到噪声影响，所以第一步是使用 5x5 的高斯滤波器去除噪声。</p><p>用到的函数：cv2.GaussianBlur()</p><p>参数：</p><ul><li>src: 源图像</li><li>ksize: 卷积框</li><li>sigmaX：表现在高斯曲线上就是曲线越高越尖，表现在滤波效果上就是模糊程度小</li><li>sigmaY：表现在高斯曲线上就是曲线越矮越平缓，表现在滤波效果上就是模糊程度大</li></ul><pre><code class="python">cv2.GaussianBlur(img, (5, 5), 70, 70)</code></pre><span id="more"></span><h2 id="计算图像梯度"><a href="#计算图像梯度" class="headerlink" title="计算图像梯度"></a>计算图像梯度</h2><p>对平滑后的图像使用 Sobel 算子计算水平方向和竖直方向的一阶导数（图 </p><p>像梯度）（Gx 和 Gy）。根据得到的这两幅梯度图（Gx 和 Gy）找到边界的梯 </p><p>度和方向，公式如下： </p><p>$$ Edge Gradient(G) &#x3D; \sqrt(G_x^2 + G_y^2) $$</p><p>$$ Angle(\theta) &#x3D; tan^{-1} (\frac{G_x}{G_y} ) $$</p><p>($G_x, G_y$) 梯度的方向一般总是与边界垂直。梯度方向被归为四类：垂直，水平，和 两个对角线。</p><h2 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h2><p>在获得梯度的方向和大小之后，应该对整幅图像做一个扫描，去除那些非边界上的点。对每一个像素进行检查，看这个的梯度是不是周围具有相同梯度方向的点中最大的。</p><p><img src="https://images2.imgbox.com/75/ee/RxuqU0tS_o.png"></p><h2 id="滞后阈值"><a href="#滞后阈值" class="headerlink" title="滞后阈值"></a>滞后阈值</h2><p>现在要确定那些边界才是真正的边界。这时我们需要设置两个阈值：minVal 和 maxVal。当图像的灰度梯度高于 maxVal时被认为是真的边界，那些低于 minVal 的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。</p><p><img src="https://images2.imgbox.com/a3/09/Pt2LMJDg_o.png"></p><h2 id="OpenCV中的Canny算法"><a href="#OpenCV中的Canny算法" class="headerlink" title="OpenCV中的Canny算法"></a>OpenCV中的Canny算法</h2><p>在 OpenCV 中只需要一个函数：cv2.Canny()，就可以完成以上几步。让我们看如何使用这个函数。这个函数的第一个参数是输入图像。第二和第三个分别是 minVal 和 maxVal。第三个参数设置用来计算图像梯度的 Sobel卷积核的大小，默认值为 3。最后一个参数是 L2gradient，它可以用来设定求梯度大小的方程。如果设为 True，就会使用我们上面提到过的方程，否则使用方程：</p><p>$$ Edege Gradient(G) &#x3D; |G_x^2| + |G_y^2| $$</p><p>代替，默认值为 False。</p><pre><code class="python">import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&quot;../imgs/test.jpeg&quot;)cv2.namedWindow(&#39;image&#39;)def do_nothing(x):    passcv2.createTrackbar(&#39;minVal&#39;, &#39;image&#39;, 0, 500, do_nothing)cv2.createTrackbar(&#39;maxVal&#39;, &#39;image&#39;, 0, 500, do_nothing)while 1:    minVal = cv2.getTrackbarPos(&#39;minVal&#39;, &#39;image&#39;)    maxVal = cv2.getTrackbarPos(&#39;maxVal&#39;, &#39;image&#39;)    if minVal &gt; maxVal:        cv2.setTrackbarPos(&#39;minVal&#39;, &#39;image&#39;, maxVal)    dst = cv2.Canny(img, minVal, maxVal)    cv2.imshow(&#39;image&#39;, dst)    if cv2.waitKey(5) == ord(&#39;q&#39;):        breakcv2.destroyAllWindows()</code></pre><p>原图：</p><p><img src="https://images.happy365.day/24/04/17230041.jpeg" alt="原图"></p><p>结果：（可以通过调节滑动条来设置阈值 minVal 和 maxVal 进而来进行 Canny 边界检测。）</p><p><img src="https://images.happy365.day/24/04/17230115.png" alt="结果"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一小时学会Swagger</title>
      <link href="/2020/10/18/91fae9e8828f/"/>
      <url>/2020/10/18/91fae9e8828f/</url>
      
        <content type="html"><![CDATA[<p>2024-04-17 更新：视频已失效</p><p>网上无意间看到的Swagger教程，一口气全部看完了，讲得很不错。</p><span id="more"></span><blockquote><p>秦疆老师SpringBoot课程扩展之Swagger学习； 这可能是全网最详细的Swagger视频了 从生活到代码，从简单到深入。风趣幽默,通俗易懂。</p></blockquote><iframe src="//player.bilibili.com/player.html?aid=64841843&bvid=BV1Y441197Lw&cid=112543089&page=3" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="height:500px;width=600px"> </iframe><p>讲 new Docket().enable(true|false) 和dev | prod | test等环境下的使用的时候因为环境变化所以配置的端口号改变却还用8080端口访问项目导致 swagger 报错导致进不去项目。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《宇宙よりも遠い場所》台词-第三话</title>
      <link href="/2020/10/17/fc7568714eb6/"/>
      <url>/2020/10/17/fc7568714eb6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>无论何时，我们的第一步总是从好奇心开始。 不曾看过的风景，不曾听过的声音，不曾闻过的味道，不曾摸过的质感，不曾尝过的食物，以及不曾感受过的澎湃。 为了重拾不知何时忘却的记忆碎片和不知何时舍弃的感动的旅途。 在到达终点的时候，我们会想些什么呢？ 40度的咆哮，50度的疯狂，60度的呐喊，跨越荒芜的海源到达原生地域。 在地球的天边，远离文明的南方尽头。 这是向南极（比宇宙更远的地方）进发的四位女孩子的旅行物语。我们通过她们回想起生于明日的光辉！</p></blockquote><br><p>結月：軽く死ねますね。</p><span id="more"></span><p>決まり：高校生、南極、あるわけないよな。</p><p>報せ：どうぞ。</p><p>決まり：ありがとう、あつっ、なにホット。</p><p>報せ：や、おばあちゃんがまだ五月だから。</p><p>日向：五月も熱いものは熱い、私冷たいもの、後御茶菓子。</p><p>決まり：私もプッティン的ななにか。</p><p>報せ：やっぱり、なんかおかしくない？</p><p>日向：おかしい？あんな無茶な作戦をしつけておいてどの口がおかしい？</p><p>決まり：そうだよ、どれだけ恥ずかしかったと思ってるの？</p><p>報せ：しょうがない、他に方法がなかったから。</p><p>日向：それにしても、あの。</p><p>日向：ああ。</p><p>決まり：何々？</p><p>日向：女子高生、南極へ行く。</p><p>報せ：こてし予定されいる民間の南極観測隊に取材と共に女子高生が同行する。</p><p>決まり：同行するのはタレントの白石結月さん、南極への旅や昭和基地の生活など、ネット中継でリポート。</p><p>報せ：先捕ばれた。</p><p>決まり：こんなのあるんだ。この前隊員の人なにも言ってなかったけど。</p><p>日向：それを言ったらうるさいからな、これが。</p><p>報せ：リポート、記者、同行者、えーと、、白石結月、事務所は、ここに電話かけて。</p><p>日向：あ、かけてどうすんだよ。</p><p>報せ：私も同行できないか書きやて、南極観測隊員の娘で今女子高生、南極も詳しい。</p><p>日向：自分でかけろよ。</p><p>報せ：や、私はそう言うのはちょっと向いてないって言うか、人蒸しい。</p><p>日向：私こいつの性格だんだんわかる気がする。</p><p>決まり：私も。</p><p>日向：びー</p><p>報せ：えー、無理無理、、</p><p>日向：話せ、南極に行きたいんだろう。</p><p>報せ：ずるいです、、</p><p>A：はい、もしもし。</p><p>報せ：なにすんだよ。</p><p>結月：あのう、小淵沢白瀬さんですよね。</p><p>白瀬：はい、</p><p>結月：はじめまして、私白石結月と言います。</p><p>白瀬：白石？</p><p>日向：結月？</p><p>決まり：あれ、その名前、</p><p>決まり：ウィキにある、五歳から、CMなどで出演、フォローは３．8万人。</p><p>決まり：去年、「フォローバックは止まらない」歌手デビュ。</p><p>結月：軽く死ねますね、恥ずかしすぎて。</p><p>決まり：報せちゃん。</p><p>日向：写真写真！</p><p>結月：無断にSNSにアップするのは肖像権のに侵害になります。</p><p>決まり：後で色紙にサインと手形にいいですか？</p><p>日向：力士か？</p><p>白瀬：でも、どうしてこんなところに？</p><p>結月：はい、お話がありまして。</p><p>決まり：なに？</p><p>結月：私に代わりに南極に行きませんか？</p><p>日向：はい？</p><p>結月：南極、行きたいんですよね？</p><p>白瀬：どこに漏らしたの？掲示板？呟？Timeline?</p><p>決まり：私なにもしてないよ。</p><p>結月：あ、いえいえ、実はこの前、新宿で親睦会の時、私も呼ばれたんです。そこで皆さんのこと聞いて。</p><p>白瀬：なんだ。</p><p>日向：でも、変わるって。</p><p>結月：端的に言うと、行きたくないんです。北海道出身なので、寒いは飽き飽きますし。女子高生なら、私じゃなくても、企画の主旨が変わらないと思いますので。</p><p>白瀬：い、いいの？</p><p>日向：白瀬。</p><p>決まり：報せちゃん。きた！</p><p>白瀬：やた、やた、、だから言ったでしょう、私の作戦でやてれば、必ず行け。</p><p>決まり：でも。</p><p>白瀬：なにが無茶よ、なにが無理よ、行けたでしょう。やた、南極、ついに南極、待って待って、ペイギン。</p><p>決まり：痛そう。</p><p>日向：すいません、ばかで。</p><p>結月：いえいえ。</p><p>結月：出口はここだけですか？</p><p>白瀬：そうだけど。</p><p>結月：サンダル借ります、失礼します。</p><p>B：ご苦労様。</p><p>B：私、結月のマナージャーを務めております、白石民子と申します。</p><p>決まり：白石？</p><p>B：母でもあります。</p><p>日向：やっぱり。</p><p>結月：だから行かないって何度も言ってるでしょ。</p><p>B：そう言うわけにはは行かないの、仕事でしょ。</p><p>結月：もう、この人たちに譲れて言っちゃたし。</p><p>B：そんなこと、勝手にできると思ってるの？失礼。なんですか？</p><p>白瀬：いえ、その。</p><p>日向：南極のリポートですよね、こいつじゃダメですか？</p><p>決まり：かなり美人ですよ、ほら、芸能人みたい。</p><p>B：喋れます？</p><p>日向：も、もちろん。</p><p>白瀬：今、ここ、南極、天気は。</p><p>決まり：もしもし、聞こえませんよ。</p><p>日向：待って、しゃべりは私、私がやりますから。はい、こちら南極です、日本の皆さん見えますか？</p><p>B：ルクスは？</p><p>日向：え？</p><p>決まり：はっきり言った！</p><p>日向：うるさい！よし、このたら、これでどうだ？</p><p>B：失礼します。</p><p>日向：あら？</p><p>白瀬：なにやてるの？</p><p>決まり：あ、奇跡おきたと思ったんだよな。</p><p>日向：もうちょっと白瀬が喋りれていたらな。</p><p>決まり：それが嫌なら日向が、</p><p>日向：抜くていい。</p><p>決まり：思ってより気付く。</p><p>決まり：いっらしゃいます。</p><p>白瀬：きた！</p><p>日向：なにが？</p><p>決まり：説得？</p><p>白瀬：そう、あの子どうしても行かないって言ってらしくて。</p><p>B：説得してたら、あなたたちも同行者として、配信会はに推薦と言うことでどうでしょ。</p><p>白瀬：つまり、あの子行くと言わせれば。</p><p>決まり、日向：なるほど。</p><p>決まり：でも、結月ちゃんもうここにいないじゃないの。</p><p>白瀬：それが、日曜に東京で仕事があるから、土曜までホテルに泊まることしたらしくて。</p><p>日向：金と土、二日か。</p><p>白瀬：もたもた時間がない、行くよ。</p><p>決まり：もう十時すぎてるよ。</p><p>白瀬：じゃ、明日の朝、学校へ行く前、５時。</p><p>日向：待て待て、寝起き取るかよ。</p><p>白瀬：じゃ、６時？7時？いつでいいの？</p><p>日向：落ち着け。</p><p>日向：あれだけ嫌がてるってことはそれなりに行きたくない理由があるってことだろう。</p><p>白瀬：寒いから嫌だからじゃなくて？</p><p>日向：端的にって言ってただろう、他に言いたくない理由があるってことだよ。</p><p>決まり：日向ちゃん大人。</p><p>白瀬：理由って？</p><p>日向：それがわからないけどさ、まずそれを聞いてみるのが先なんじゃないのか。</p><p>決まり：理由が。</p><p>日向：な、やば、じゃな。</p><p>決まり：うん、また明日。</p><p>日向：どうした？</p><p>白瀬：自己嫌悪。</p><p>日向：あ？</p><p>白瀬：確かに、日向の言う通りだなと思ってたの、私さ、結局自分の気持ち優先させてばかりで、人のこと考えてないのこも。</p><p>日向：いまさら？冗談だよ。思いの強さとわがままは紙一重でって言うだろう。</p><p>白瀬：誰の言葉？</p><p>日向：私。</p><p>恵：今日はバイトは？</p><p>決まり：ないよ。</p><p>恵：じゃ、何か食べ行くか？</p><p>決まり：うん。</p><p>恵：南極か？ほら、大丈夫なの？</p><p>決まり：まあ、まだわからないけど、ごめんね、また今度。</p><p>日向：ここ？</p><p>白瀬：うん、三丸ご室。</p><p>決まり：どうする？ビビビ尾行？</p><p>日向：付けても意味ないだろう、偶然だ、偶然を装て。あれ、泊まってたんだ、どこいくの？</p><p>決まり：勉強？</p><p>結月：はい、学校いけない分追いつかないといけないので、ここだと、〜ありますし、夜も平気ですし。</p><p>決まり：偉いな。</p><p>結月：南極のことですよね、すみません、特に進展はなくて。</p><p>日向：ん、それはそれなんだけど。</p><p>白瀬：ちょっと、その前に、聞いておきたいことがあって。</p><p>結月：なんです？</p><p>白瀬：どうして行きたくないの？</p><p>結月：そんなに変ですか？</p><p>決まり：だって、南極行ったら、ペンギンいるよ、氷山もあるし、オオレルも見れるか。</p><p>結月：ははになにか言われましたね、行くよ説得してくれてなんとか。</p><p>白瀬：はい。</p><p>日向：弱い。</p><p>決まり：あ、でも、ほんとにききたいもあって、結月ちゃん行きたくない理由。</p><p>結月：聞いてどうするですか？</p><p>決まり：嫌なら、いいけど。</p><p>結月：多分皆さんはわからないと思いますけど、私友達いないです、今じゃないですよ、今まで、今まで一度も。4歳の頃からずっと子役の仕事として、でも忙しいから、友達と遊んでる暇がどんどんなくて、気付いたら、それを繰り返して。私ね、友達と喧嘩したことないですよ、するのはいつもお母さんばかり、だから、高校入ったら、高校で絶対に友達作ろうと思って、部活して、バイトして、友達と放課後買い食いして、カラオケって。でも、やっぱり、最初って大切じゃないのか、今頑張た入ってないと、そうゆ関係とか、グループとか、形ができちゃうって言うか。なんです？</p><p>決まり：だから、抱きしめたくなった。</p><p>結月：苦しい。</p><p>決まり：わかるよ、そう言うの、新学期とか私もすごく嫌だよ。</p><p>結月：わからないですよ。</p><p>決まり：わかるよ。</p><p>結月：分からないです、だから、皆さん、親友同士じゃないですか？</p><p>日向：親友？</p><p>結月：違うんですか？</p><p>日向：私たち出会って1ヶ月も経ってないぞ。</p><p>白瀬：一緒に遊びに行ってこともないし。</p><p>決まり：ただ同じところに向かおうとしているだけ、今のとことは、ね。</p><p>白瀬：ね。</p><p>決まり：ねー。</p><p>日向：遅くまで悪かったね。</p><p>白瀬：お母さん分かってるといいけど。</p><p>結月：こちらこそ、話せてなんか、ちょっとだけ落ち着けました、では。</p><p>決まり：バイバイ。</p><p>日向：で、これ、結論としてはどうだったんだ？</p><p>決まり：結論って？</p><p>日向：お前忘れのか？もともとは結月に説得しに来たんだろう？</p><p>決まり：お、そうだたんだ。あれ、でも、ここで結月ちゃんが断ることができれば、報せちゃんが代わりに、ん〜説得したら、一緒にいけて、あれ、でも、結月ちゃんが断ったら、報せちゃんが代わりに、なんかゴチャゴチャしてる。</p><p>日向：わかるよ。</p><p>白瀬：あの子が断ったら、どうせい別の芸能人見たいの人が代わりを務める。</p><p>決まり：あ、そうか。</p><p>白瀬：私たちは説得しかなかった、でも。</p><p>日向：ま、これでよかったじゃやない？</p><p>結月：初めてだ、あんなことされたの。友達って、あんな感じなのかな。</p><p>結月：決まりさん。</p><p>決まり：やっぱり、南極に行こう。</p><p>結月：なにやてるんです？怒られますよ。</p><p>日向：いいから、行くぞ。</p><p>白瀬：風強いから、早く。</p><p>結月：や、でも、私は。</p><p>決まり：手を伸ばして。</p><p>結月：変な夢。</p><p>決まり：おはよう。</p><p>結月：皆さん。</p><p>日向：だから言ったろう、早すぎるって、まだパジャンパジャン。</p><p>決まり：行ったのは白瀬ちゃんだよ。</p><p>白瀬：しかたないでしょ、東京まで行くんだから。</p><p>結月：東京？</p><p>決まり：ん、結月ちゃん東京で仕事だって言ってただから、もしよかったら、一緒に行こうかなって。</p><p>日向：いきなり押しかけて、ごめんな、こいつ連絡先聞いておきないから。</p><p>決まり：私？</p><p>白瀬：時間ある？</p><p>結月：はい。</p><p>決まり：ほんと？</p><p>決まり：じゃさじゃさ、東京に南極の、、</p><p>日向：ど、どうした？</p><p>日向：決まり！</p><p>白瀬：決まり！</p><p>決まり：え、私？だって、だって、</p><p>結月：だから、三人一緒なら行くっていてるの、一緒じゃかったら、行かないから。</p><p>決まり：はい、結月ちゃん、いくよ。</p><p>結月：はい。</p><p>白瀬：ペイギン。</p><p>結月：もふもふですね。</p><p>決まり：お、長い。</p><p>日向：これ中入れるぞ。</p><p>決まり：本当？お、結構狭いんだね。</p><p>白瀬：今はもっと新しい雪上車が使わってる見たいだけど。</p><p>日向：微速前進、ようそろ！</p><p>結月：船じゃないと思いますけど。</p><p>日向：二段ベッドは上だけだ。</p><p>決まり：室内は二十度以上だって、よかった。</p><p>結月：外はマイナス十度からね、鼻水出ますねきっと。</p><p>結月：もう少し寄ってください。</p><p>決まり：本物はもっと綺麗だろうね。</p><p>白瀬：もちろん、すごく綺麗だって、涙出てくるって、お母さん言ってた。</p><p>日向：でも、オオロラはなかなか見れないじゃないのか？</p><p>結月：聞いてことあります。</p><p>決まり：じゃ、もし本当に見ること出来たら、南極でオオロラを見た世界で唯一の高校生になれるかも。</p><p>結月：そうか、そうなったら、軽く死ねますね。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 动漫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV学习笔记（二）</title>
      <link href="/2020/10/17/e48dcc0e58b1/"/>
      <url>/2020/10/17/e48dcc0e58b1/</url>
      
        <content type="html"><![CDATA[<ul><li>移动</li><li>旋转</li><li>仿射变换</li><li>用到的函数：cv2.getPerspectiveTransform()</li></ul><span id="more"></span><h2 id="扩展和缩放"><a href="#扩展和缩放" class="headerlink" title="扩展和缩放"></a>扩展和缩放</h2><h3 id="cv2-resize-函数用法"><a href="#cv2-resize-函数用法" class="headerlink" title="cv2.resize()函数用法"></a>cv2.resize()函数用法</h3><pre><code class="python">void resize(InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR )</code></pre><pre><code>src：输入，原图像，即待改变大小的图像；dst：输出，改变大小之后的图像，这个图像和原图像具有相同的内容，只是大小和原图像不一样而已；dsize：输出图像的大小。如果这个参数不为0，那么就代表将原图像缩放到这个Size(width，height)指定的大小；如果这个参数为0，那么原图像缩放之后的大小就要通过下面的公式来计算：       dsize = Size(round(fx*src.cols), round(fy*src.rows))       其中，fx和fy就是下面要说的两个参数，是图像width方向和height方向的缩放比例。fx：width方向的缩放比例，如果它是0，那么它就会按照(double)dsize.width/src.cols来计算；fy：height方向的缩放比例，如果它是0，那么它就会按照(double)dsize.height/src.rows来计算；interpolation：这个是指定插值的方式，图像缩放之后，肯定像素要进行重新计算的，就靠这个参数来指定重新计算像素的方式，有以下几种：      INTER_NEAREST - 最邻近插值      INTER_LINEAR - 双线性插值，如果最后一个参数你不指定，默认使用这种方法      INTER_AREA -区域插值 resampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire’-free results. But when the image is zoomed, it is similar to the INTER_NEAREST method.      INTER_CUBIC - 4x4像素邻域内的双立方插值      INTER_LANCZOS4 - 8x8像素邻域内的Lanczos插值</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用cv2.resize()可以实现对图片的大小调整。</p><p>三种插值方法：</p><ol><li>cv2.INTER_AREA</li><li>cv2.INTER_LINEER</li><li>cv2.INTER_CUBIC</li></ol><pre><code class="python">import cv2import numpy as npimg = cv2.imread(&quot;../imgs/pi.png&quot;)result1 = cv2.resize(img, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_CUBIC)result2 = cv2.resize(img, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA)result3 = cv2.resize(img, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_LINEAR)# height, width = img.shape[0:2]# result = cv2.resize(img, (2 * width, 2 * height), interpolation=cv2.INTER_CUBIC)while 1:    cv2.imshow(&#39;INTER_CUBIC&#39;, result1)    cv2.imshow(&#39;INTER_AREA&#39;, result2)    cv2.imshow(&#39;INTER_LINEAR&#39;, result3)    # cv2.imshow(&#39;image&#39;, img)    if cv2.waitKey(4) == ord(&#39;q&#39;):        breakcv2.destroyAllWindows()</code></pre><p>结果如下：</p><p><img src="https://images.happy365.day/24/04/17225724.png" alt="结果"></p><p>-&gt;&gt;<a href="https://blog.csdn.net/guyuealian/article/details/85097633">OpenCV图像缩放resize各种插值方式的比较</a></p><h2 id="图像的平移"><a href="#图像的平移" class="headerlink" title="图像的平移"></a>图像的平移</h2><p>使用cv2.wrapAffine()实现图像的平移。</p><p>函数 cv2.warpAffine() 的第三个参数的是输出图像的大小，它的格式<br>应该是图像的（宽，高）。应该记住的是图像的宽对应的是列数，高对应的是行<br>数。</p><pre><code class="python">import cv2import numpy as npimg = cv2.imread(&quot;../imgs/pi.png&quot;, cv2.IMREAD_GRAYSCALE)height, width = img.shape# 平移矩阵 100x50M = np.float32([[1, 0, 100], [0, 1, 50]])result = cv2.warpAffine(img, M, (width, height), dst=None, borderMode=cv2.BORDER_REFLECT, borderValue=3)while 1:    cv2.imshow(&#39;result&#39;, result)    cv2.imshow(&#39;image&#39;, img)    if cv2.waitKey(0) == ord(&#39;q&#39;):        breakcv2.destroyAllWindows()</code></pre><p>结果如下：</p><p><img src="https://images.happy365.day/24/04/17225816.png" alt="结果"></p><h2 id="图像的旋转"><a href="#图像的旋转" class="headerlink" title="图像的旋转"></a>图像的旋转</h2><p>opencv中对图像的旋转主要是先通过getRotationMatrix2D函数得到图像的旋转矩阵，然后再通过仿射变换函数warpAffine得到旋转后的图像。</p><p><strong>参数说明</strong>：</p><p>getRotationMatrix2D:</p><ul><li>center–表示旋转的中心点</li><li>angle–表示旋转的角度degrees</li><li>scale–图像缩放因子</li></ul><p>warpAffine:</p><ul><li>src – 输入的图像</li><li>M – 2 X 3 的变换矩阵.</li><li>dsize – 输出的图像的size大小</li><li>dst – 输出的图像</li><li>flags – 输出图像的插值方法</li><li>borderMode – 图像边界的处理方式</li><li>borderValue – 当图像边界处理方式为<code>BORDER_CONSTANT</code> 时的填充值</li></ul><pre><code class="python">import cv2import numpy as npimg = cv2.imread(&#39;../imgs/pi.png&#39;, cv2.IMREAD_GRAYSCALE)height, width = img.shapeM = cv2.getRotationMatrix2D((width / 2, height / 2), 270, 0.8)result = cv2.warpAffine(img, M, dsize=None, dst=None, flags=cv2.BORDER_CONSTANT, borderValue=1)while 1:    cv2.imshow(&#39;result&#39;, result)    cv2.imshow(&#39;image&#39;, img)    if cv2.waitKey(0) == ord(&#39;q&#39;):        breakcv2.destroyAllWindows()</code></pre><p>输出结果：</p><p><img src="https://images.happy365.day/24/04/17225854.png" alt="运行结果"></p><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>在仿射变换中，原图中所有的平行线在结果图像中同样平行。为了创建这<br>个矩阵我们需要从原图像中找到三个点以及他们在输出图像中的位置。然后<br>cv2.getAffineTransform 会创建一个 2x3 的矩阵，最后这个矩阵会被传给<br>函数 cv2.warpAffine。</p><pre><code class="python">import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&quot;../imgs/pi.png&quot;)rows, cols, ch = img.shapepts1 = np.float32([[50, 50], [200, 50], [50, 200]])pts2 = np.float32([[10, 100], [200, 50], [100, 250]])M = cv2.getAffineTransform(pts1, pts2)dst = cv2.warpAffine(img, M, (cols, rows))plt.subplot(121, plt.imshow(img), plt.title(&#39;Input&#39;))plt.subplot(121, plt.imshow(img), plt.title(&#39;Output&#39;))plt.show()</code></pre><p>报错：</p><pre><code>    cols = int(cols)TypeError: int() argument must be a string, a bytes-like object or a number, not &#39;AxesImage&#39;</code></pre><h2 id="图像的翻转"><a href="#图像的翻转" class="headerlink" title="图像的翻转"></a>图像的翻转</h2><p><strong>参数说明</strong>：</p><ul><li>src – 输入的图像</li><li>dst – 输出的图像</li><li>flipCode – 翻转模式，flipCode&#x3D;&#x3D;0垂直翻转（沿X轴翻转），flipCode&gt;0水平翻转（沿Y轴翻转），flipCode&lt;0水平垂直翻转（先沿X轴翻转，再沿Y轴翻转，等价于旋转180°）</li></ul><pre><code class="python">import cv2import numpy as npimg = cv2.imread(&quot;../imgs/pi.png&quot;)flip_img = cv2.flip(img, 0)while 1:    cv2.imshow(&#39;image&#39;, img)    cv2.imshow(&#39;flip_img&#39;, flip_img)    if cv2.waitKey(0) == ord(&#39;q&#39;):        breakcv2.destroyAllWindows()</code></pre><p>结果：</p><p><img src="https://images.happy365.day/24/04/17225937.png" alt="结果"></p><p>!</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法进阶</title>
      <link href="/2020/10/16/2155ed03772c/"/>
      <url>/2020/10/16/2155ed03772c/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><span id="more"></span><h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><p>生成文章目录:</p><pre><code>[TOC]</code></pre><h2 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><pre><code>graph TBA[开始]--&gt;B(打开冰箱门)B--&gt;C(放入大象)C--&gt;D(光上冰箱门)D--&gt;E(结束)</code></pre><pre><code class="mermaid">graph TBA[开始]--&gt;B(打开冰箱门)B--&gt;C(放入大象)C--&gt;D(光上冰箱门)D--&gt;E(结束)</code></pre><pre><code>st=&gt;start: Startop1=&gt;operation: Identify objectsop2=&gt;operation: Investigate business processop3=&gt;operation: Sketchop4=&gt;operation: Discusscond=&gt;condition: Yes or Noop5=&gt;operation: Draw a chartop6=&gt;operation: Modifye=&gt;endst-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;condcond(yes)-&gt;op5-&gt;econd(no)-&gt;op6-&gt;op3</code></pre><pre><code class="flow">st=&gt;start: Startop1=&gt;operation: Identify objectsop2=&gt;operation: Investigate business processop3=&gt;operation: Sketchop4=&gt;operation: Discusscond=&gt;condition: Yes or Noop5=&gt;operation: Draw a chartop6=&gt;operation: Modifye=&gt;endst-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;condcond(yes)-&gt;op5-&gt;econd(no)-&gt;op6-&gt;op3</code></pre><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><pre><code>小程序 -&gt;&gt; 小程序: wx.login()获取code小程序 -&gt;&gt; 服务器: wx.request()发送code服务器 -&gt;&gt; 微信服务器: code + appid + secret微信服务器 -&gt;&gt; 服务器: openid服务器 -&gt;&gt; 服务器: 根据openid确定用户并生成token服务器 -&gt;&gt; 小程序: token</code></pre><pre><code class="sequence">小程序 -&gt;&gt; 小程序: wx.login()获取code小程序 -&gt;&gt; 服务器: wx.request()发送code服务器 -&gt;&gt; 微信服务器: code + appid + secret微信服务器 -&gt;&gt; 服务器: openid服务器 -&gt;&gt; 服务器: 根据openid确定用户并生成token服务器 -&gt;&gt; 小程序: token</code></pre><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><pre><code>[^keyword]:www.xxx.com</code></pre><p>示例：</p><p>[^1]: some description</p><h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><pre><code>- []- [x]</code></pre><ul><li><input disabled="" type="checkbox"> 待办事项一</li><li><input disabled="" type="checkbox"> 待办事项二</li><li><input checked="" disabled="" type="checkbox"> 已完成一</li></ul><h2 id="Latex公式"><a href="#Latex公式" class="headerlink" title="Latex公式"></a>Latex公式</h2><p>$ 表示行内公式</p><pre><code>$x^2 + y^2 = 1$</code></pre><p>$x^2 + y^2 &#x3D; 1$</p><p>$$ 整行公式</p><pre><code>$$ \sum_&#123;i=1&#125;^n a_i = 0 $$$$ f(x_1, x_x, \dots, x_n) = x_1^2 + x_2^2 + \dots + x_n^2 $$$$ \sum^&#123;j-1&#125;_&#123;k-0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125;&#123;z_k&#125;&#125; $$$ \sqrt&#123;3x-1&#125;+\sqrt[5]&#123;2y^5-4&#125; $$$ \cos (2\theta) = \cos^2 \theta - \sin^2 \theta $$输出带有分子分母的分数的语法为\frac&#123;分子&#125;&#123;分母&#125;，使用大括号把分子、分母都围住。$$ \lim\limits_&#123;x \to \infty&#125; \exp(-x) = 0 $$$$ \frac&#123;n!&#125;&#123;k!&#123;n-k&#125;!&#125; = \binom&#123;n&#125;&#123;k&#125; $$$$    \begin&#123;matrix&#125;    1 &amp; 2 &amp; 3 \\    4 &amp; 5 &amp; 6 \\    7 &amp; 8 &amp; 9    \end&#123;matrix&#125;$$</code></pre><p>$$ \sum_{i&#x3D;1}^n a_i &#x3D; 0  $$</p><p>$$ f(x_1, x_x, \dots, x_n) &#x3D; x_1^2 + x_2^2 + \dots + x_n^2 $$</p><p>$$ \sum^{j-1}<em>{k-0}{\widehat{\gamma}</em>{kj}{z_k}} $$</p><p>$\sqrt{3x-1}+\sqrt[5]{2y^5-4}$</p><p>$$\cos (2\theta) &#x3D; \cos^2 \theta - \sin^2 \theta$$</p><p>$$ \lim\limits_{x \to \infty} \exp(-x) &#x3D; 0 $$</p><p>$$ \frac{n!}{k!{n-k}!} &#x3D; \binom{n}{k} $$<br>$$<br>\begin{matrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置git初始化默认分支为main</title>
      <link href="/2020/10/09/cde85a939b5c/"/>
      <url>/2020/10/09/cde85a939b5c/</url>
      
        <content type="html"><![CDATA[<p>好久没上传代码到 GitHub 了，前两天新建了一个仓库，然后习惯性的执行 <code>git push origin master </code> , 过了好一会儿才在 GitHub 页面上看到两个分支：main 和 master。</p><p>这两天陆陆续续出现好几次，网上查了一下才知道从10月份起，GitHub 的默认分支名不再是master，而是main。据说是因为master这个词和种族主义有关系，现在的人真是玻璃心啊。</p><p>git 初始化默认分支名是master，每次新建仓库都要改默认分支名很麻烦，就查了一下设置 git 初始化分支名的方法，找到两种解决办法：</p><span id="more"></span><ul><li><p><strong>初始化后切换分支</strong> &gt;&gt; <a href="https://stackoverflow.com/a/42871621">https://stackoverflow.com/a/42871621</a></p><p>As you noticed, there is no parameter for <code>git init</code> for the branch name, so two commands will have to do.</p><pre><code class="shell">git initgit checkout -b trunk</code></pre><p>This creates a new repository with <code>trunk</code> as the current branch instead of <code>master</code>. The branch <code>master</code> does not actually exist–the branches don’t get created until they have at least one commit. Until the branch gets created, the branch only exists in <code>.git/HEAD</code>, which explains why the <code>master</code> branch will disappear when you switch to <code>trunk</code>.</p><p>If you’ve already committed, you can run <code>git branch -m</code> instead:</p><pre><code>git inittouch file.txtgit add file.txtgit commit -m &#39;commit 1&#39;git branch -m trunk</code></pre><p>This renames the branch from <code>master</code> to <code>trunk</code> once it’s created.</p><p>This does seem a bit clunky since the mechanism is different depending on whether the repository is empty, but it works.</p></li><li><p><strong>升级 git 使用 git 全局配置</strong> &gt;&gt; <a href="https://stackoverflow.com/a/63136920">https://stackoverflow.com/a/63136920</a></p><p>Since <strong>Git 2.28</strong> (released July 27, 2020) a new configuration option, <code>init.defaultBranch</code> is being introduced to replace the hard-coded term <code>master</code>.</p><p>Default remains to <code>master</code>!</p><p>The user can override the default value of the configuration variable with:</p><pre><code>$ git config --global init.defaultBranch main</code></pre><p>Read the git doc chapter for further details <a href="https://github.blog/2020-07-27-highlights-from-git-2-28/#introducing-init-defaultbranch">Introducing init.defaultBranch</a></p><p>升级 git 还要配置 zsh，太麻烦了，没试。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> GitHub </tag>
            
            <tag> 默认分支名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程学习笔记</title>
      <link href="/2020/10/08/00e11830a793/"/>
      <url>/2020/10/08/00e11830a793/</url>
      
        <content type="html"><![CDATA[<p>创建线程的两种方式：</p><ul><li>继承Thread类；</li><li>实现Runnable接口。</li></ul><span id="more"></span><ol><li>继承Thread类：</li></ol><pre><code class="java">public class MyThread extends Thread &#123;    public void run() &#123;        System.out.println(&quot;My thread.&quot;);    &#125;    public static void main(String[] args) &#123;        MyThread myThread = new MyThread();        myThread.start();    &#125;&#125;</code></pre><ol start="2"><li>当一个类已经继承了其他类时，就只能实现Runnable接口：</li></ol><pre><code class="java">public class MyThread extends OtherClass implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(&quot;my thread&quot;);    &#125;    public static void main(String[] args) &#123;        // 先创建一个Thread实例，再传入自己的MyThread实例        MyThread myThread = new MyThread();        new Thread(myThread).start();    &#125;&#125;</code></pre><p><em>Thread类实现了Runnable接口。</em></p><pre><code class="java">public class Thread implements Runnable &#123;    private volatile String name;    private int priority;    ...&#125;</code></pre><p>当线程有返回值时，必须实现Callable接口，执行Callable任务后返回Future对象，调用Future对象的get()方法获取返回值：</p><pre><code class="java">public class MyThread2 implements Callable &#123;    private int i;    MyThread2(int i) &#123;        this.i = i;    &#125;    @Override    public Object call() throws Exception &#123;        return i * i * i;    &#125;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        int taskSize = 10;        ExecutorService pool = Executors.newFixedThreadPool(taskSize);        List&lt;Future&gt; list = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; taskSize; i++) &#123;            Callable callable = new MyThread2(i);            Future future = pool.submit(callable);            list.add(future);        &#125;        pool.shutdown();        for (Future future : list) &#123;            System.out.println(future.get().toString());        &#125;    &#125;&#125;</code></pre><p><strong>new Thread的弊端如下：</strong></p><p>a. 每次new Thread新建对象性能差。<br>b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。<br>c. 缺乏更多功能，如定时执行、定期执行、线程中断。</p><p><strong>相比new Thread，Java提供的四种线程池的好处在于：</strong></p><p>a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。<br>b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。<br>c. 提供定时执行、定期执行、单线程、并发数控制等功能。</p><p>参见 &gt;&gt; <a href="https://blog.csdn.net/u011974987/article/details/51027795">Java 四种线程池的用法分析</a></p><p>Java提供的4种线程池：</p><ul><li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，<strong>可灵活回收空闲线程</strong>，若无可回收，则新建线程。</li><li>newFixedThreadPool：创建一个定长线程池，<strong>可控制线程最大并发数</strong>，超出的线程会在队列中等待。</li><li>newSchuduledThreadPool：创建一个定长线程池，<strong>支持定时及周期性任务执行</strong>。</li><li>newSingleThreadPool：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，<strong>保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</strong>。</li></ul><p>newCachedThreadPool</p><pre><code class="java">public class MyThread4 &#123;    public static void main(String[] args) &#123;        ExecutorService pool = Executors.newCachedThreadPool();        for (int i = 0; i &lt; 5; i++) &#123;            final int index = i;            try &#123;                Thread.sleep(i * 500);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            pool.execute(() -&gt; System.out.println(Thread.currentThread().getName() + &quot; &quot; + index));        &#125;    &#125;&#125;</code></pre><p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p><pre><code>pool-1-thread-1 0pool-1-thread-1 1pool-1-thread-1 2pool-1-thread-1 3pool-1-thread-1 4pool-1-thread-1 5pool-1-thread-1 6pool-1-thread-1 7pool-1-thread-1 8pool-1-thread-1 9</code></pre><p>newFixedThreadPool</p><pre><code class="java">ExecutorService pool = Executors.newFixedThreadPool(3);for (int i = 0; i &lt; 10; i++) &#123;    final int x = i;    pool.execute(() -&gt; &#123;        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread().getName() + &quot;  &quot; + x);    &#125;);&#125;</code></pre><p>任务数超出最大线程数，超出的线程会等待：</p><pre><code>pool-1-thread-2  1pool-1-thread-3  2pool-1-thread-1  0pool-1-thread-2  3pool-1-thread-1  5pool-1-thread-3  4pool-1-thread-2  6pool-1-thread-1  7pool-1-thread-3  8pool-1-thread-2  9</code></pre><p>newSchuduledThreadPool</p><pre><code class="java">ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);// 延迟 1 秒后每 3 秒执行一次pool.scheduleAtFixedRate(() -&gt; System.out.println(Thread.currentThread().getName()), 1, 3, TimeUnit.SECONDS);</code></pre><p>newSingleThreadPool</p><pre><code class="java">ExecutorService pool = Executors.newSingleThreadExecutor();for (int i = 0; i &lt; 10; i++) &#123;    final int index = i;    pool.execute(() -&gt; System.out.println(Thread.currentThread().getName() + &quot; &quot; + index));&#125;</code></pre><pre><code>pool-1-thread-1 0pool-1-thread-1 1pool-1-thread-1 2pool-1-thread-1 3pool-1-thread-1 4pool-1-thread-1 5pool-1-thread-1 6pool-1-thread-1 7pool-1-thread-1 8pool-1-thread-1 9</code></pre><p>线程的生命周期：</p><p>新建New：JVM分配内存，并初始化成员变量的值；</p><p>就绪Runnable：创建方法调用栈和程序计数器；</p><p>运行 Running：获得CPU，执行run()方法；</p><p>阻塞 Blocked：让出CPU时间片，停止运行；</p><p>死亡 Dead：正常结束，异常结束或调用stop()方法。</p><blockquote><p>wait()和sleep()的关键的区别在于，sleep()方法属于Thread类，wait()方法属于Object类，wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。更加明显的一个区别在于，<strong>当一个线程调用wait()方法的时候，会释放它锁持有的对象的管程和锁，但是调用sleep()方法的时候，不会释放他所持有的管程。</strong></p><p>而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</p></blockquote><p>终止线程的3种方式 &gt; <a href="https://blog.csdn.net/Smile_Miracle/article/details/71550548">Java中如何优雅正确的终止线程</a></p><ol><li><p>使用stop()方法</p><p>thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。</p></li><li><p>使用volatile标志位：</p><pre><code class="java">public class MyRunnable implements Runnable &#123;    public volatile boolean flag = true;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName() + &quot;创建&quot;);        try &#123;            Thread.sleep(1000L);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        while (flag) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + &quot;终止&quot;);    &#125;    public static void main(String[] args) throws InterruptedException &#123;        MyRunnable myRunnable = new MyRunnable();        for (int i = 0; i &lt; 3; i++) &#123;            Thread thread = new Thread(myRunnable, i + &quot; &quot;);            thread.start();        &#125;        Thread.sleep(2000L);        System.out.println(&quot;-------&quot;);        myRunnable.flag = false;    &#125;&#125;</code></pre><p>output</p><pre><code>0 创建2 创建1 创建-------2 终止0 终止1 终止</code></pre></li><li><p>使用interrupt方式</p><ol><li><p>线程处于阻塞状态时：</p><p>如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过break 来跳出循环，才能正常结束 run 方法。</p><pre><code class="java">public class MyThread5 extends Thread &#123;    @Override    public void run() &#123;        try &#123;            Thread.sleep(3000L);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) &#123;        MyThread5 thread5 = new MyThread5();        thread5.start();        boolean interrupted = thread5.isInterrupted();        if (!interrupted) &#123;            thread5.interrupt();        &#125;    &#125;&#125;outputjava.lang.InterruptedException: sleep interrupted    at java.base/java.lang.Thread.sleep(Native Method)    at ch4.MyThread5.run(MyThread5.java:12)</code></pre></li><li><p>线程未处于阻塞状态：</p><p>使用 isInterrupted()判断线程的中断标志来退出循环。当使用<br>interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p><pre><code class="java">public class MyThread5 extends Thread &#123;    public void run() &#123;        super.run();        try &#123;            System.out.println(&quot;线程开始。。。&quot;);            Thread.sleep(200000);            System.out.println(&quot;线程结束。&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是：&quot; + this.isInterrupted());            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) &#123;        MyThread5 thread5 = new MyThread5();        thread5.start();        thread5.interrupt();    &#125;&#125;output线程开始。。。在沉睡中被停止, 进入catch， 调用isInterrupted()方法的结果是：falsejava.lang.InterruptedException: sleep interrupted    at java.base/java.lang.Thread.sleep(Native Method)    at ch4.MyThread5.run(MyThread5.java:13)</code></pre></li></ol></li></ol><p>线程基本方法：</p><p>yield：线程的礼让指的是先将线程的资源让出去，让别的线程先执行。</p><pre><code class="java">public class ThreadMethod extends Thread &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            for (int x = 0; x &lt; 10; x++) &#123;                if (x % 3 == 0) &#123;                    Thread.yield(); //线程礼让                    System.out.println(&quot;玩耍线程礼让执行 ***********************&quot;);                &#125;                System.out.println(Thread.currentThread().getName() + &quot;、 x = &quot; + x);            &#125;        &#125;, &quot;玩耍的线程&quot;);        thread.start();        for (int x = 0; x &lt; 10; x++) &#123;            System.out.println(&quot;【霸道的main主线程】 x = &quot; + x);        &#125;    &#125;&#125;</code></pre><p>output</p><pre><code>玩耍线程礼让执行 ***********************【霸道的main主线程】 x = 0【霸道的main主线程】 x = 1【霸道的main主线程】 x = 2【霸道的main主线程】 x = 3【霸道的main主线程】 x = 4【霸道的main主线程】 x = 5【霸道的main主线程】 x = 6【霸道的main主线程】 x = 7【霸道的main主线程】 x = 8【霸道的main主线程】 x = 9玩耍的线程、 x = 0玩耍的线程、 x = 1玩耍的线程、 x = 2玩耍线程礼让执行 ***********************玩耍的线程、 x = 3玩耍的线程、 x = 4玩耍的线程、 x = 5玩耍线程礼让执行 ***********************玩耍的线程、 x = 6玩耍的线程、 x = 7玩耍的线程、 x = 8玩耍线程礼让执行 ***********************玩耍的线程、 x = 9</code></pre><p>join: 线程强制执行，指的当满足某些条件之后，某一个线程对象将一直可以独占资源，一直到该线程的程序执行结束。</p><pre><code class="java">public class ThreadMethod extends Thread &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread mainThread = Thread.currentThread(); //获得主线程        Thread thread = new Thread(() -&gt; &#123;            for (int x = 0; x &lt; 10; x++) &#123;                if (x == 3) &#123;  //如果x == 3，就强制执行主线程                    try &#123;                        mainThread.join();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                System.out.println(Thread.currentThread().getName() + &quot;、 x = &quot; + x);            &#125;        &#125;, &quot;玩耍的线程&quot;);        thread.start();        for (int x = 0; x &lt; 10; x++) &#123;            Thread.sleep(100L);            System.out.println(&quot;【霸道的main主线程】 x = &quot; + x);        &#125;    &#125;&#125;</code></pre><p>output</p><pre><code>玩耍的线程、 x = 0玩耍的线程、 x = 1玩耍的线程、 x = 2【霸道的main主线程】 x = 0【霸道的main主线程】 x = 1【霸道的main主线程】 x = 2【霸道的main主线程】 x = 3【霸道的main主线程】 x = 4【霸道的main主线程】 x = 5【霸道的main主线程】 x = 6【霸道的main主线程】 x = 7【霸道的main主线程】 x = 8【霸道的main主线程】 x = 9玩耍的线程、 x = 3玩耍的线程、 x = 4玩耍的线程、 x = 5玩耍的线程、 x = 6玩耍的线程、 x = 7玩耍的线程、 x = 8玩耍的线程、 x = 9</code></pre><p>sleep： 休眠的主要特点是可以自动实现线程的唤醒，以继续进行后续的处理。但是需要注意的是，如果现在有多个线程对象，休眠也是有多个先后顺序的。</p><p>wait和notify：</p><ul><li>synchronized关键词用于互斥访问。</li><li>为了让一个方法是同步的，简单的添加synchronized关键词到它们的声明上。那么同一个对象上没有两个同步方法的调用可以相互交错。</li><li>同步语句必须指定提供内在锁的对象。当使用synchronized(this)时候，必须避免使用同步其他对象方法的调用。</li><li>wait()告诉调用的线程放弃监视器和进入休眠状态，直到其他线程进入相同的监视器和调用notify()。</li><li>notify()唤醒在相同对象上第一个调用wait()的线程。</li></ul><pre><code class="java">public class ThreadA &#123;    public static void main(String[] args) &#123;        ThreadB b = new ThreadB();        b.start();        synchronized (b) &#123;            try &#123;                System.out.println(&quot;Waiting for b to complete...&quot;);                b.wait();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;Total is: &quot; + b.total);        &#125;    &#125;&#125;class ThreadB extends Thread &#123;    int total;    @Override    public void run() &#123;        synchronized (this) &#123;            for (int i = 0; i &lt; 100; i++) &#123;                total += i;            &#125;            notify();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七牛云备案域名过期导致图片无法查看和下载</title>
      <link href="/2020/09/30/e7b4fbbe1cc4/"/>
      <url>/2020/09/30/e7b4fbbe1cc4/</url>
      
        <content type="html"><![CDATA[<p>之前一直用七牛云做博客图床，七牛云做得还是挺不错的，速度快、稳定并且还有免费空间和流量。但是前段时间备案的域名被删除了。</p><span id="more"></span><p>域名删除影响非常大，之前在博客里引用的图片无法查看，并且登录到七牛云后台也无法预览、下载图片，整个服务完全不可用了。于是在网上查了许多资料找到了解决方法。</p><p>官方开发了工具来管理存储的文件，其中一个命令行工具叫“qrsctl”。可以通过命令行来做一些上传下载、移动复制和空间管理等操作。</p><p>安装及使用方法 &gt;&gt;  <a href="https://developer.qiniu.com/kodo/tools/1300/qrsctl">命令行辅助工具(qrsctl)</a></p><p>使用下面的shell脚本：</p><pre><code class="shell">#!/bin/bash# 将存储空间名称换为自己的空间名称imgs=`./qrsctl listprefix youyou-2608 &#39;&#39;`i=0 echo $imgs | tr &quot; &quot; &quot;\n&quot; | while read linedo    if(($i&gt;0))    then        echo $line        ./qrsctl get youyou-2608 $line ./$line    fi    i=$(($i+1))done</code></pre><p>给脚本添加执行权限，然后运行即可。</p><p>但是用脚本下载图片时遇到一个问题：名称中带有“&#x2F;”这种在Linux系统被用作目录分隔符的图片无法下载，会报“找不到该文件”的错误，因为它把“&#x2F;”前的部分当作目录、而把后半部分当作文件名，当然找不到文件了。</p><p>在七牛云提了工单之后，七牛云的工程师说是这个工具本身有问题。没办法，最后只能一个一个去改文件名（域名被删除后还能改文件名），然后再下载。不得不说，工作量不是一般的大。</p><p>最后就是图床的问题了，看了许多网上推荐的图床感觉都不太靠谱，倒下一个图床又需要重新折腾一遍。想着后面有时间自己搭建一个图床，这样比较安心一些。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 七牛云 </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《宇宙よりも遠い場所》台词-第二话</title>
      <link href="/2020/09/22/5ebab35fb54a/"/>
      <url>/2020/09/22/5ebab35fb54a/</url>
      
        <content type="html"><![CDATA[<p>第二話：歌舞伎町のフリマントル</p><p>我终于踏出这一步了，去往没有你的世界。</p><span id="more"></span><p>報せ：白瀬は十一月中旬に日本を出航、南極に向けて海を南下、途中フリーマントルに寄港。<br>決まり：オーストラリアだ。<br>報せ：ここで補給と観測隊員の乗り込みを行って、十二月の上旬、南極大陸に向けて出航するの。<br>決まり：日本から乗って行くんじゃなんだ。<br>報せ：それは昔の話、今はフリーマントルから乗船、帰るにはシドニーから飛行機って言うのが普通。<br>決まり：え〜<br>報せ：そこで、私たちは白瀬がフリーマントルに寄港する時期に合わせて日本を立ち、フリーマントルに向かう。<br>決まり：うんうん。<br>報せ：そして、ここで白瀬に乗り込み、南極へ。<br>決まり：乗れるの？<br>報せ：基本的に南極観測は国家事業、成員は自衛隊員が務め、観測隊員は厳しい審査と訓練に合格した人間だけ、高校生は絶対に無理。ただ、今年は特別。<br>決まり：今年は？民間南極観測隊、三年ぶりに発遣決まる。（その笑顔を見た時に、なんか心がブカブカした、あ、生しゃぶる言って、多分これだと思った。私は今、人生で一番途方もなくて、とんでもない大きい計画を立ってている。）<br>決まり：あれ、もしかして、 せいすいかん？<br>報せ：うん。<br>決まり：あは〜</p><p>決まり：あ〜これも十八歳以上か。<br>恵：なに？バイト？<br>決まり：おはよう、うん、昨日話したでしょう、飛行機代。報せちゃんが用意しとけって。<br>恵：南極か。<br>決まり：うん、行ってる間、学校を休むことになるから、出席数を稼いでおけって。あっ、なにこれ？超いい！<br>恵：なに？<br>決まり：高校生女子募集、接客業、男性とお喋りしたり、お散歩したりする仕事ですって、内容によっては、月100万以上も夢じゃないかも、お〜<br>恵：見るかったら終わりだぞ。<br>決まり：大丈夫だよ、バイトするって学校には届け出すから。<br>恵：なにも分かってないな、お金はともかくとして、行けるのか本当に？<br>決まり：うん！報せちゃん言ってた、その今年でる民間の南極観測隊っていうに知り合いがあるからって、あ。<br>恵：調べて見たけど、ヤバそうだぞ。<br>決まり：4年前、新基地完成と新型砕氷艦就航に伴い、民間に払い下げれた二代目白瀬と昭和基地だが、その維持費と活動費調達に苦慮し、三年ぶりに発遣した今回の観測隊も、前回スポンサーだった企業は次々と撤退を表明して終わり、このままでは、隊員の安全が確保されないので、計画をそのまま対する批判の声も相次いているって。<br>先生：玉木さん、玉木さん、、<br>決まり：はっはい！<br>先生：つづけを読んでいただけますまいか？<br>決まり：はっはい、資金面の問題と合わせて今後も、はわ〜<br>先生：はわ、の先を聞かせていただきます。</p><p>決まり：あ、まだこんなにある、書き取りなんて小学校以来だよ。<br>恵：授業中に読んでるからだろう。<br>決まり：だって、我慢できなかっただもん、それで？<br>恵：それでもなにもない、一応、今のところ計画が中止になったとは書いてないけど。<br>決まり：じゃ、大丈夫だね。<br>恵：そうか？仮に中止にならなかったとしても、そう簡単に乗れるか？いくら民間だからって。<br>決まり：ほら、報せちゃん観測隊員の娘だし。<br>恵：コンサートの間席者席じゃないんだから、そんなホイホイ乗せてくれるわけないと思うけどな。<br>決まり：そうか、だよね。<br>恵：この後、会うんだろう？一度ちゃんと聞いて見た方が良いぞ。<br>決まり：うん、分かった、はわ！</p><p>決まり：ごめん。<br>報せ：時間は厳守！南極いくなら尚更よ、数分の遅れが生死に関わるだから。<br>決まり：だから、先生に怒られたって送ったじゃん。<br>報せ：バイトは？<br>決まり：え？<br>報せ：今日までに決めるって。<br>決まり：そうだけど、とりあえず、オーストラリアまでの飛行機代でょう？夏休みに纏めてやればなんとか。<br>報せ：いざという時のために、お金が多い方がいい、私調べて置いたから。<br>決まり：ほんど？<br>報せ：高校生女子、接客業で、男性とおしゃべりしたり、お散歩したりするバイトなんだって、かなりの時給でしょう？<br>決まり：うん、そうだけど。<br>報せ：そ、そうなの？<br>決まり：や、私も恵ちゃんに襲わたんだけど、報せちゃんもちょっと抜きてるとこあるよね。<br>報せ：抜きてない、ただ知らなかっただけで。なに？それ。<br>決まり：友達、南極ほんとに行けるのかって心配してて。<br>報せ：疑うの？<br>決まり：疑うってじゃないけど、ただ、確証がないっていうか。ね、心配になるでしょう、それに仮に中止にならなかったとしても、乗れるのかって。<br>報せ：乗れる！だって、私は小渕沢貴子の娘だから。<br>決まり：本当に？それだけで？<br>報せ：絶対大丈夫！<br>決まり：そうかな、でも。<br>報せ：嫌になったらなったって、素直に言えばいいじゃない。<br>決まり：え？<br>報せ：それ私のせいにしようとして。<br>決まり：嫌になったんじゃないよ、ただ失敗したくない、やっぱりやめとけだって思たくない、「行って良かった」、「報せちゃんの計画に乗ってよかった」って思いたい、うん、、<br>報せ：ちゃんと状況は全部わかってる、作戦も考えてある。<br>決まり：ほんとに？<br>報せ：うん、今度ちゃんと説明するから、決まりは準備進めて。<br>決まり：うん、わかった！おっ</p><p>決まり：いっらしゃいませ、温めはいかがなされますか？<br>店員：まあ、いろいろこれから覚えてもらえば良いから、まず補充お願い、そこ三宅さんいるから、聞いて。<br>決まり：はい！<br>決まり：あのう、、<br>日向：うわ！<br>決まり：あの、今日から入ったことになった玉木です、よろしくお願いします！<br>日向：玉木？<br>決まり：玉木マリです。<br>日向：あ、それで決まり、はは、三宅日向です、何歳？<br>決まり：十六歳、高二です。<br>日向：一緒だ、よろしく！<br>決まり：よ、よろしく。<br>日向：だったら、西校だよね。<br>決まり：うん、多西。<br>日向：なんで急にバイト？<br>決まり：はうん、ちょっと必要っていうか、行きたいところがあって。<br>日向：うんん〜それってさ、もしかして、南極？<br>決まり：え？</p><p>報せ：行きたい？<br>決まり：うん、なんか前から私たちの話聞いてたみたいで。<br>日向：あ、そういう風にいったら、盗み聞きみたいだろう、違うからね、二人で大声で話てだから。<br>報せ：大声？<br>日向：嫌になってったら言えば良いじゃない？嫌になったんじゃないよ、、<br>決まり：良いよ、やりなくて！<br>日向：それで、気になっててさ、そして決まりがバイトで入って来たでしょう、これは運命だって思ったね私は。<br>報せ：言っておくけど、遊びじゃないから。<br>日向：分かってる。<br>報せ：命の危険だってあるし、旅費だってちゃんと払ってもらうるし、出発は十二月だから、学校を休むことにもなる。<br>日向：I’am OK!平気だよ、バイトでお金があるし、高校を行ってないし。<br>決まり：え！そうなの？<br>日向：そんなに驚くことないだろう、中にはいるんだよ、高校行ってない十六歳だって。<br>決まり：おう。<br>日向：あ、でも、間違えるなよ、勉強は絶対負けないから、高認も通るし、この前の模試は合格判定Aだし。<br>決まり：え！まだ高二なのに！<br>報せ：じゃ、大学は行くってこと？<br>日向：そう、合格しまくて、高校で怠けて落ちたやつらにザマミロって言うのが今のとこの夢。<br>決まり：あ〜<br>報せ：でも、だったら南極行って暇なんてないじゃない。<br>日向：そうだけど、まだ受験まで2年近くあるし、来年は本気で受験勉強だって考えると、一個ぐらいになかしときたいなって。<br>決まり：分かる、だよね、今年しなかったら、もうできないもんね。<br>日向：そう！お、良いのか？このままくまんとおでん作り終わって良いのか？俺の十六歳！<br>決まり：そうそう！<br>日向：お前とはうまいお酒飲めそうだ、飲んだことないけど。<br>決まり：私も！<br>報せ：うるさい！この計画を立ってたのは私なんだから、私の指示に従って。<br>決まり：別に下がろうって言ってないけど。<br>日向：なに？めんどくさいタイプ？<br>決まり：ちょっと、、<br>報せ：作戦の概要、今度の日曜日、決行するから。じゃ、日曜。<br>三人：うん！</p><p>決まり、日向：バイバイ！<br>決まり：どう思う、この作戦？<br>日向：さあ、なかなか難しそうと思うけどね。<br>決まり：だよね。<br>日向：でも、あの子私らよりは南極のこと知ってるだろうし、やるしかないじゃない？引き返せるうちは、旅ではない！引き返せなくなった時に、初めてそれは旅になるのだって言うし。<br>決まり：うわ〜なにそれ？名言っぽい、誰の言葉？<br>日向：私〜<br>決まり：なんだ、、<br>日向：でも、よかったよ。<br>決まり：え？<br>日向：私あなたたち二人のこと嫌いじゃなかったんだよね、ほら、あのコンビニ、多西近いから、生徒いっぱいくるじゃん。<br>決まり：うん。<br>日向：でも、二人だけはなんか別だなって、空気が違うって言うか。<br>決まり：そんなこと言われたの初めて。<br>日向：私さあ、集団の中でグチャグチャみたいなのは苦手ててさ、だから高校無理だたんだけど、二人はいいなあって。<br>決まり：良いって、なにが？<br>日向：うん、なんだろう、嘘ついてない感じ？って言われたら、良い気する？<br>決まり：そりゃ、、<br>日向：こうして日向ちゃんは人の心にとりるだよ、じゃね〜<br>決まり：うん、、</p><p>決まり：新宿だ！<br>日向：ギャラギャラするな！群馬だってバレる！<br>決まり：だって、なんかキラキラしてて、どこ見ていいのわかんない！<br>日向：落ち着け！<br>報せ：決まり、まって、おいで行かないで。<br>日向：おい、間違えてる！<br>決まり：か、歌舞伎町。<br>報せ：き、来たことないの？<br>決まり：夜来るのは初めてかも、一応恵ちゃん自留めるか持って言ってたけど。<br>日向：補導されたりしないか？私は良いけど、二人は学校にバレたらまずいだろう。<br>決まり：歩いてだけでも？<br>日向：場所が場所だからな。<br>報せ：平気、大学生って顔してれば。<br>路人：なに？遊びに来たの？ちょっとちょっとだけ、、<br>決まり：どうしよう？<br>日向：面白いから、ほっとこうか。<br>日向：あった、観測隊員親睦会合意一行さま。<br>決まり：ほんと？<br>報せ：よし！後は作戦通りに。<br>決まり：でも、これ一人を誘い出すってしか書いてないけど。<br>日向：どうするの？<br>報せ：それは、普通男子隊員が多いから、女子高生がこう、、<br>日向：まさか、誘惑しろって言うんじゃないだろうな。<br>決まり：まあ、報せちゃん美人だからな。<br>報せ：私？私はないない。<br>日向：待って、私たちのどっちが行かせるつもりだったのかよ！<br>決まり：無理だよ！<br>日向：来たぞ、そうする？<br>報せ：決まり、お願い！<br>決まり：そんな！<br>日向：決まり！<br>決まり：え？！<br>日向：昭和か？！<br>決まり：じゃ日向ちゃんやってよ！<br>日向：ほら、モタモタしていると行っちゃう！足だ、なまし！<br>決まり：パンツだもん。<br>日向：じゃ、胸だ、胸を挙上せよ、いい〜か！<br>決まり：だいたい胸なら、、<br>報せ：嫌だ、嫌だ、、<br>日向：行けよ、南極行かんだら。<br>決まり：そうだよ、ずるいよ、作戦考えた報せなんだから。<br>報せ：や、で、私はだめなの。<br>日向：なにがダメなんだよ。<br>決まり：そうだよ。<br>弓子：うん、あっ。<br>佳苗：お？報せちゃん？<br>弓子：しつこいね、あの子も。<br>ゆず：誰ですか？<br>日向：お辞儀してどんするんだよ？ここ学校か？優等生か？！<br>報せ：だから私はダメだって言ってるでしょう？<br>決まり：どうして？<br>報せ：顔がバレてるの、だから、見つかったらすぐに捕まって、、<br>弓子：うわ、三人もいる！<br>報せ：逃げて、<br>日向、決まり：え？<br>報せ：逃げて！<br>決まり：日向ちゃん、早い！<br>日向：一応短距離だったらな、別れた方が良いじゃないのか？<br>報せ：そうね。<br>日向：おじ会う場所は？<br>報せ：携帯で！<br>日向：おらい〜<br>決まり：まだ追って来る。<br>報せ：観測隊員だから、体力すごいし。<br>決まり：私たちも別れる？ あ、痛い。<br>報せ：あ、ごめん。<br>決まり：うん。<br>報せ：なに？<br>決まり：うん、ただ、楽しいなあって。<br>報せ：楽しい？<br>決まり：うん、なんかね、動いてる！<br>報せ：え？<br>決まり：私の青春動いてる気がする！そう、こう言うのだ！なにかが起きそうで、なにか起こせそうで、毎日見ている景色が、目も苦しく変わっていって。<br>路人A：やっぱ外飲み最高だね、美味しいね。<br>路人B：今日朝まで飲んで、、<br>日向：え？！<br>路人A、B：バイバイ！<br>報せ、日向、決まり：あっ！！</p><p>佳苗：そんなに息切らすまで走らなくても、別に命奪おうわけじゃないのに、奪いそうだけど。<br>決まり：だって、報せちゃんが。<br>日向：そうだよ、捕まったら撃ちこびこもんって。<br>報せ：そんなこと言ってない。<br>弓子：しかし、よくその作戦思いつくよね。<br>佳苗：つまり、男性隊員誑かして、協力させて見っこしよってこどでしょう？悪い女ね、誰が思いついたの？<br>佳苗：まっ、そうよね、あのね、報せちゃん、何度も話した通り、あなたを連れて行くことはできないの、たとえ民間でもね、隊員が厳しい条件があって。<br>報せ：分かってます！無理を言ってるのは分かってます！でも、どうしても行きたい、だって、お母さんが待ってる。<br>決まり：報せちゃん。<br>佳苗：なに、これ？<br>報せ：見た通りです、資金困ってるですよね、私たちをそのお金でスボサーにしてください、連れて行ってくれったら、そのお金あげますから。<br>弓子：よく考えるわね。<br>佳苗：分かった、十二月一日、フリーマントりきて。<br>報せ：ほんとですか？！<br>佳苗：なんって言うと思う？そんな心配してもらわなくても、私たちは行くわ、必ずね。<br>佳苗：貴子、、、</p><p>弓子：まあ、気持ちは分かるけどね。<br>佳苗：あれから3年。<br>弓子：で、ほんとに資金は大丈夫なの？<br>佳苗：さっき言ってたでしょう？まあ、大変だけど、いろいろ考えてるわ。<br>弓子：白石さん、、<br>佳苗：もう、その一環！</p><p>決まり：お母さん、か。<br>日向：まあ、落ち込むなよ、これでダメと決まってわけじゃない。<br>報せ：後一息で、もう少しこのお金を受けたりそうだった、後少しで絶対にうまく行って、、<br>日向：こいつ、ポッじてうちゃんだ。<br>決まり：だね〜<br>日向：まあ、そうじゃなきゃこんなことできないか。<br>決まり：だね！<br>日向：ただし、緊急動議、小淵沢報せのリーダー担任を解任を要求しまーす、賛成の人？<br>決まり：はい！<br>日向：賛成多数！よってた今よりリーダーを解任します！<br>報せ：え？！<br>日向：と言うわけで、南極いくぞ！<br>日向、決まり：おぉ！<br>報せ：え？！！</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 动漫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《宇宙よりも遠い場所》台词-第一话</title>
      <link href="/2020/01/05/a6ea8238f40c/"/>
      <url>/2020/01/05/a6ea8238f40c/</url>
      
        <content type="html"><![CDATA[<p>第一話：青春しゃくまんえん</p><p>決まり：淀んだ水が溜まっている、それが一気に流れて行くのが好きだった、決壊し、解放され、走り出す、ゆどみの中で拓得た力が爆発して、全てが、動き出す！</p><span id="more"></span><p>決まりの母：玉木マリさん、もう昼ですよう。<br>決まり：なんか、なんか怖い夢見た。<br>決の母：なに？<br>決まり：お母さんが濡れたタオル私の顔にかけて殺そうする夢。<br>決まりの母：それは怖っかたですね。昨日言ったようね、部屋片付けるって。<br>決まり：待ってよ！痛い、、、高校に入ったらしたいこと、日記をつける、一度だけ学校をサボる、あてのない旅に出る。<br>決まりの母：なんだそりゃ。なに？</p><br><p>恵：うん、で？<br>決まり：だから、高二になったのに、まだなにもしてないってこと気づいたわけ。<br>恵：中学の時も決まりなにもしなかったじゃん。<br>決まり：だからだよ、高校時代はなにかしなきゃって思ったの、なんとなくは良くないって。時間は限られているなのに、あの時の決心どこ行って話だよ。<br>恵：それで何するの？<br>決まり：とりあえず、実行しようと思って。<br>恵：東京？<br>決まり：うん、まずは東京なんて行って、それで当てのない旅に出る、思いのまま漂う。<br>恵：いつ？<br>決まり：痛っ！！</p><br><p>恵：明日？<br>決まり：うん、が、学校をサボって。<br>恵：まあ、いいんじゃないの？<br>決まり：ええ〜！休むだよ、ズル休みだよ。<br>恵：だからいいんじゃなの、そのぐらい。<br>決まり：そのぐらいって。<br>恵：まさか決まりしたことないのズル休み。<br>決まり：恵ちゃんあるの？<br>恵：あるでしょう。だでだって、一度ぐらい。<br>決まり：尊〜敬〜<br>恵：そういう目で見るな！<br>決まり：じゃさじゃさ、当てのない旅は？<br>恵：それはないかな。<br>決まり：じゃさじゃさじゃさ、、<br>恵：一緒には行かない。<br>決まり：なんで分かるの？<br>恵：分かるよ、決まりの考えそうなことぐらい、そう言うのは一人で行くから意味があるじゃない？<br>決まり：そうか。<br>恵：行けばいいじゃん、協力はしてあげるからさ。<br>決まり：うん！</p><br><p>決まり：ただいま〜、うん、ワクワクする〜明日駅のトイレどこで着替えるだあ、で、うわ〜海だ海だ！ヤバ、群馬だってバレる。（笑〜）<br>リン：どうしたのお姉ちゃん？<br>決まり：はぁ、なんでもない。</p><br><p>決まりの母：もう行くの？どうしたのそのカバン？<br>決まり：うん、友達から体操着借りてて。<br>決まりの母：また？<br>決まり：行ってきまーす。<br>恵：電話掛けて来るな。<br>決まり：だって。<br>恵：心配しなくても、学校には連絡入れて置いてあげたよ、真和色使って。<br>決まり：ほんと？<br>恵：泊りになる時はちゃんと食っちゅうら合わせてあげるから、心配しないで行って来い。<br>決まり：うん！私は旅に出る、トイレで着替え、学校と反対方向の電車に乗り、いつもの学校から私一人だけが飛び出して、当てのない旅に出る。まだ見たこともない場所へ。</p><br><p>恵：なんでここいる？<br>決まり：やあ、雨だし、てゆうか、やっぱりズル休みは行けないかなと言うか。<br>恵：行きたいところなかったの？<br>決まり：あったよ、たくさんあった、京都でも、沖縄でも、北海道でも。<br>恵：じゃあ、なんで行かなかった？<br>決まり：それはその、飛行機落ちるかもしれないし、新幹線大爆発するかもしれないし。<br>恵：隕石落ちるかもしないし？<br>決まり：分かってるよ分かってる。<br>恵：じゃ、なんでど？</p><br><p>恵：怖くなった？<br>決まり：ほら、私いつもそうじゃん、部活入る時も、ならいことする時も、受験でいい学校をチャレンジしようって時も、全部直前までくると怖くなって、やったないこと初めて、うまく行かなかったら、どうしようって、失敗したら、やだなあって、後悔するだなあって、ギリギリになると、いつも。<br>恵：まあ、それは悪いことじゃないと思うだけどな。<br>決まり：でも、私は嫌い、私のそうゆところ、大嫌い。<br>恵：じゃ。<br>決まり：うん。<br>恵：今度、どこかへ遊びに行く？<br>決まり：うん！<br>決まり：ちょっと、これ！</p><br><p>決まり：えっ！<br>恵：まじか、いくらある？<br>決まり：数えたら、ピッタリ百まん、<br>恵：百まん？！どうして持ってきた、警察だろう！<br>決まり：だって、気が導電してて。<br>恵：ものは良いようだな。<br>決まり：違うよ、ほんとほんとに導電してたの、て言うか、落としたのうちの学校のだったような。<br>恵：何年？<br>決まり：そこまでは分からない、後ろ姿ちら見ただけだし。<br>恵：ん。<br>恵：いる？<br>決まり：いない、、かな。髪はあそこの子くらいで、多分美人。<br>恵：後は？<br>決まり：良い匂いした、リース？<br>恵：それはな〜まあ、いいや、あの長さのかみだとそんなにいないと思うから、私一年の教室見て来る。<br>決まり：うん。</p><br><p>決まり：あ〜、落ち着かない、あ、この匂い。<br>決まり：や〜。<br>報せ：しゃくまん、しゃくまん。<br>決まり：ん。<br>報せ：百まん。<br>決まり：あ。<br>報せ：なに？なに？<br>決まり：あは、いえ、あのう。<br>報せ：それ。<br>決まり：いえ、実は昨日、、違うの、盗んだことじゃないよ、たまたま、、<br>報せ：ありがとう、ありがとう、ありがとう〜</p><br><p>決まり：南極？<br>報せ：それを書いたのは私のお母さん、南極観測隊員だったの、中学の時、行方不明になちゃったけどね。<br>決まり：そうなんだ。<br>報せ：結局見つからなくて、遺火もほとんどないままで、だから、私が行って見つけるの。<br>決まり：南極に？行けるの？<br>報せ：みんなそう言う。おばあちゃんも、友達も、先生も、先輩も、近所の人も。子供が行けると思ってるのかって、いくらかかると思ってるのかだって。<br>決まり：それで、百万。<br>報せ：うん、ずっとバイトしてね、私は行く、絶対に行って、無理だっていた全員にザマミロって言ってやる。受験終わって高校に入ったときにそう決まったの。</p><br><p>決まり：南極だよ、南極、すごいと思わない？地球の一番ハッシコだよ。<br>日向：566円になります〜<br>恵：小渕沢報せか？<br>決まり：うん、恵ちゃん知ってた？<br>恵：二組の「南極」って呼ばれてるあの子でしょう？<br>決まり：南極？<br>恵：結構有名だぞ、高校入ってたからずっと南極いく南極いくって。<br>決まり：確かに言ってた。<br>恵：行けるわけにはないのにね。<br>決まり：でも、百万あるだよ、それであの子絶対に行くって。<br>恵：行けないよ、南極だよ。それこそ、観測隊員にでもならなきゃ無理。<br>決まり：じゃ、なんで？<br>恵：そうね、だから変人って言われてるんでしょう、友達も作らず、放課後ずっとバイトして、お金貯めて。<br>決まり：ん、、</p><br><p>恵：どうか行ってく？<br>決まり：あ、うん、今日はちょっと。<br>決まり：うん、あった！</p><br><p>決まり：（笑）<br>報せ：私の自転車なんだけど。<br>A：お、そうなの？<br>A、B：南極号？<br>A：見張り代。<br>B：盗まらないように見てあげたんだよ。<br>A：サツドブ持ってるらしいじゃん。<br>B：そこし貸してくれない？ちょっとだけ。<br>決まり：あ、あのう〜こ、小渕沢さん、先生呼んでる、お金のことを聞きたいからって。<br>報せ：ほんと？<br>決まり：うん、うん、、、<br>A：気づくの早いつ、</p><br><p>報せ：じゃ、嘘なの？<br>決まり：うん。<br>報せ：びっくりさせないでよ、ほんとに先生にバレたかったと思ったでしょう。<br>決まり：眼魂だくしてあげるじゃん。<br>報せ：分かるわけないでしょう、でも、なんで？たまたま通りかかったでしょ？<br>決まり：うん、ちょっと見かけて、話したいこともあったし。<br>報せ：話したいこと？<br>決まり：私、あなたのことを応援してる！<br>報せ：え？<br>決まり：私ね、高校に入ったら、なにかしようって思ってた、今までしたことないこととか、なんかすごいこととか、でも、なにもできなくて、いざとなると、怖くなって、辞めちゃって。だから、あんなにみんなに言われて、馬鹿にされても、行くって本気で頑張れるってすごいと思う。うん！！<br>報せ：言いたい人には、言わせておけばいい、今に見てろうって熱くなれるから、そっちの方が、ずっといい。<br>決まり：なにか手伝えることない？あったら、言って！<br>報せ：じゃ、一緒に行く？<br>決まり：え？<br>報せ：前にも、何人かそう言うことくれた人がいった、でもみんなすぐいなくなるの、やっぱり無理だとか、友達に止められたとか、怖くなったとか、それが普通だと思う、だって、高校生だし、学校行ってるんだし、友達もいるだし。<br>決まり：違うよ、私はそんな簡単な気持ちで言い訳じゃなくて。<br>報せ：船の下見、次の土曜ここに来て、そうしたら、本気だって信じる。</p><br><p>決まり：砕氷艦白瀬、一般公開、、広島。<br>リン：お姉ちゃん、土曜だから、いつまでも寝て、、うわ〜<br>決まり：私は旅に出る、今度こそ、旅に出る、いつもと反対方向の電車に乗り、見たことはない風景を見るために。怖いけど、辞めちゃいたいけど、意味のないことかもしれなけど、でも、、</p><br><p>決まり：うわ〜こんなに大きいんだ。<br>報せ：赤道を抜きて、嵐を抜け、氷を割り、日本から14000キロ、宇宙よりも遥か遠い、誰も寄せ付けない、その場所へ。<br>決まり：どうやっていくつもり？<br>報せ：知りたい？<br>決まり：うん。（その口元がに似合いと笑う、私の青春が、動き出した！）</p><br><p>路人：三宅さん、こっち！<br>日向：はい！</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 动漫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派通过无刷电调驱动无刷电机</title>
      <link href="/2020/01/05/827e7c295051/"/>
      <url>/2020/01/05/827e7c295051/</url>
      
        <content type="html"><![CDATA[<p>今天尝试了使用无刷电调来驱动无刷电机，但是刚开始遇到点问题，没理解网上的博文，还好板子没被烧掉💦</p><p><a href="https://blog.csdn.net/qf0129/article/details/70769054">树莓派pwm控制无刷电机</a></p><span id="more"></span><h2 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h2><p>刚开始了卡在了连线这里，电调有两根电源线，连接12V电源，其中三根线连接树莓派，<strong>如果树莓派独立供电的话，电调只需要将信号控制线和地线连接到树莓派的GPIO口和GND口</strong>。</p><p>我刚开始连错了，树莓派独立供电的同时，将电调的5V输出端和GND线都连接到了树莓派上，板子突然自己开机了，才意识到接错了。后来想着不需要电调输出的电压，所以只接了信号控制线，5V输出和GND都没接，程序跑了但是电机没转动，也没信号声音。看了 <a href="https://www.cnblogs.com/raffeale/p/5585757.html">折腾了2个晚上无刷电调(ESC)，电机终于转起来了，特此记录一下</a> 才意识到电调的GND线是一定要接到树莓派的GND口的，然后电机就动了。</p><p>连接图：</p><p><img src="https://images.happy365.day/24/04/17222155.png" alt="连线图"></p><p><em>上面的图中电调的输入电压应该是12V，可以用4节5号电池串联。</em></p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>连接好之后，给树莓派通电，接通电调连接的电源，然后用RPi.GPIO.PWM()控制电机的转速。</p><p>测试代码：</p><pre><code class="python"># !/usr/bin/env python# _*_ coding:utf-8 _*_import RPi.GPIO as GPIOimport timepin = 18GPIO.setmode(GPIO.BCM)GPIO.setup(pin, GPIO.OUT)# 频率400Hzp = GPIO.PWM(pin, 400)p.start(0)dc = 10try:    for i in range(40):        dc += 2        print &#39;dc:&#39;, dc        p.ChangeDutyCycle(dc)        time.sleep(0.3)finally:    p.stop()    GPIO.cleanup()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派驱动4位数码管</title>
      <link href="/2020/01/04/12667216ab37/"/>
      <url>/2020/01/04/12667216ab37/</url>
      
        <content type="html"><![CDATA[<p>听歌：<a href="http://url.cn/5vzNt1p">宇宙を見上げて</a> （动画《比宇宙更远的地方》插入曲）</p><p>经过上个周末以及元旦一天的努力，手里的web项目也过半了，于是陆续准备了许多材料打算开始做基于树莓派和OpenCV的自主寻迹小车。正好今天周六数码显示管到了，于是想先摸索着点亮看看，之前也没搞过。往上资料不是很详细，花了两三个小时才搞明白，记录一下备忘。</p><span id="more"></span><br><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>树莓派（3b+）</li><li>4位数码显示管</li><li>T型扩展板（非必需）</li><li>12根母对母杜邦线</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://www.kawabangga.com/posts/1408">树莓派控制3641BS数码管显示数字</a></p><p>元件电路图：</p><p><img src="https://images.happy365.day/24/04/17221831.gif" alt="4位数码管电路原理图"></p><p>我自己买的共阴极的。</p><p>引脚：</p><p><img src="https://images.happy365.day/24/04/17221932.jpg" alt="引脚图"></p><p>引脚编号从下往上，从左往右然后再从右往左。</p><p>其中 12 号引脚控制第一个数字的显示，然后 9 -&gt; 2，8 -&gt; 3，6 -&gt; 4。</p><h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><p>在接线这儿犹豫了一会儿，因为担心接线接错了可能会直接烧毁数码显示器和树莓派，往上也没有找到详细的线路图。后来看了电路图后直接将所有引脚用母对母杜邦线接到了GPIO口。接完了了之后只测试了一个数字的显示，确认显示正常值后才开始写代码。</p><p>在我的3b+ T型扩展板上（用的BCM编码方式），连线是这样的：</p><table><thead><tr><th>树莓派引脚（BCM）</th><th>数码显示器引脚</th></tr></thead><tbody><tr><td>G18</td><td>11</td></tr><tr><td>G19</td><td>7</td></tr><tr><td>G20</td><td>4</td></tr><tr><td>G21</td><td>2</td></tr><tr><td>G22</td><td>1</td></tr><tr><td>G23</td><td>10</td></tr><tr><td>G24</td><td>5</td></tr><tr><td>G25</td><td>3</td></tr><tr><td>G13</td><td>12</td></tr><tr><td>G16</td><td>9</td></tr><tr><td>G17</td><td>8</td></tr><tr><td>G26</td><td>6</td></tr></tbody></table><h2 id="显示当前时间的代码"><a href="#显示当前时间的代码" class="headerlink" title="显示当前时间的代码"></a>显示当前时间的代码</h2><p>代码是从这里搬过来的，但是我把时间改成了小时+分钟的形式，然后这段代码有些bug，做了一些修改。</p><p><a href="https://www.kawabangga.com/posts/1408">树莓派控制3641BS数码管显示数字</a></p><p>最后修正后的代码如下，将高电位和低电位进行了反转；在Ln157到Ln176行增加了显示1, 2, 3, 4其中一个数字的时候，将其他三个数字选择置于高电平，是高电位哦；在程序退出时增加了RPi.GPIO.cleanup()，避免程序退出数码管依然显示。</p><pre><code class="python"># !/usr/bin/bin/env python# coding:utf-8import RPi.GPIO as GPIOimport time# mapping LED to GPIOLED_A = 18 # 11LED_B = 19 # 7LED_C = 20 # 4LED_D = 21 # 2LED_E = 22 # 1LED_F = 23 # 10LED_G = 24 # 5LED_DP = 25 # 3 # mapping public GPIODIGIT1 = 13 # 12DIGIT2 = 16 # 9DIGIT3 = 17 # 8DIGIT4 = 26 # 6 #sleep time - loop displeyt=0.001 GPIO.setmode(GPIO.BCM) GPIO.setup(LED_A, GPIO.OUT)GPIO.setup(LED_B, GPIO.OUT)GPIO.setup(LED_C, GPIO.OUT)GPIO.setup(LED_D, GPIO.OUT)GPIO.setup(LED_E, GPIO.OUT)GPIO.setup(LED_F, GPIO.OUT)GPIO.setup(LED_G, GPIO.OUT)GPIO.setup(LED_DP, GPIO.OUT)GPIO.setup(DIGIT1, GPIO.OUT)GPIO.setup(DIGIT2, GPIO.OUT)GPIO.setup(DIGIT3, GPIO.OUT)GPIO.setup(DIGIT4, GPIO.OUT) GPIO.output(DIGIT1, True)GPIO.output(DIGIT2, True)GPIO.output(DIGIT3, True)GPIO.output(DIGIT4, True)  def showDigit(no, num, showDotPoint=False):    GPIO.setup(LED_A, False)    GPIO.setup(LED_B, False)    GPIO.setup(LED_C, False)    GPIO.setup(LED_D, False)    GPIO.setup(LED_E, False)    GPIO.setup(LED_F, False)    GPIO.setup(LED_G, False)    GPIO.setup(LED_DP, False)    GPIO.output(DIGIT1, False)    GPIO.output(DIGIT2, False)    GPIO.output(DIGIT3, False)    GPIO.output(DIGIT4, False)     if (num == 0) :        GPIO.output(LED_A, True)        GPIO.output(LED_B, True)        GPIO.output(LED_C, True)        GPIO.output(LED_D, True)        GPIO.output(LED_E, True)        GPIO.output(LED_F, True)        GPIO.output(LED_G, False)        GPIO.output(LED_DP, showDotPoint)    elif (num == 1) :        GPIO.output(LED_A, False)        GPIO.output(LED_B, True)        GPIO.output(LED_C, True)        GPIO.output(LED_D, False)        GPIO.output(LED_E, False)        GPIO.output(LED_F, False)        GPIO.output(LED_G, False)        GPIO.output(LED_DP, showDotPoint)    elif (num == 2) :        GPIO.output(LED_A, True)        GPIO.output(LED_B, True)        GPIO.output(LED_C, False)        GPIO.output(LED_D, True)        GPIO.output(LED_E, True)        GPIO.output(LED_F, False)        GPIO.output(LED_G, True)        GPIO.output(LED_DP, showDotPoint)    elif (num == 3) :        GPIO.output(LED_A, True)        GPIO.output(LED_B, True)        GPIO.output(LED_C, True)        GPIO.output(LED_D, True)        GPIO.output(LED_E, False)        GPIO.output(LED_F, False)        GPIO.output(LED_G, True)        GPIO.output(LED_DP, showDotPoint)    elif (num == 4) :        GPIO.output(LED_A, False)        GPIO.output(LED_B, True)        GPIO.output(LED_C, True)        GPIO.output(LED_D, False)        GPIO.output(LED_E, False)        GPIO.output(LED_F, True)        GPIO.output(LED_G, True)        GPIO.output(LED_DP, showDotPoint)    elif (num == 5) :        GPIO.output(LED_A, True)        GPIO.output(LED_B, False)        GPIO.output(LED_C, True)        GPIO.output(LED_D, True)        GPIO.output(LED_E, False)        GPIO.output(LED_F, True)        GPIO.output(LED_G, True)        GPIO.output(LED_DP, showDotPoint)    elif (num == 6) :        GPIO.output(LED_A, True)        GPIO.output(LED_B, False)        GPIO.output(LED_C, True)        GPIO.output(LED_D, True)        GPIO.output(LED_E, True)        GPIO.output(LED_F, True)        GPIO.output(LED_G, True)        GPIO.output(LED_DP, showDotPoint)    elif (num == 7) :        GPIO.output(LED_A, True)        GPIO.output(LED_B, True)        GPIO.output(LED_C, True)        GPIO.output(LED_D, False)        GPIO.output(LED_E, False)        GPIO.output(LED_F, False)        GPIO.output(LED_G, False)        GPIO.output(LED_DP, showDotPoint)    elif (num == 8) :        GPIO.output(LED_A, True)        GPIO.output(LED_B, True)        GPIO.output(LED_C, True)        GPIO.output(LED_D, True)        GPIO.output(LED_E, True)        GPIO.output(LED_F, True)        GPIO.output(LED_G, True)        GPIO.output(LED_DP, showDotPoint)    elif (num == 9) :        GPIO.output(LED_A, True)        GPIO.output(LED_B, True)        GPIO.output(LED_C, True)        GPIO.output(LED_D, True)        GPIO.output(LED_E, False)        GPIO.output(LED_F, True)        GPIO.output(LED_G, True)        GPIO.output(LED_DP, showDotPoint)     if (no == 1) :        GPIO.output(DIGIT1, False)        GPIO.output(DIGIT2, True)        GPIO.output(DIGIT3, True)        GPIO.output(DIGIT4, True)    elif (no == 2) :        GPIO.output(DIGIT1, True)        GPIO.output(DIGIT2, False)        GPIO.output(DIGIT3, True)        GPIO.output(DIGIT4, True)    elif (no == 3) :        GPIO.output(DIGIT1, True)        GPIO.output(DIGIT2, True)        GPIO.output(DIGIT3, False)        GPIO.output(DIGIT4, True)    else :        GPIO.output(DIGIT1, True)        GPIO.output(DIGIT2, True)        GPIO.output(DIGIT3, True)        GPIO.output(DIGIT4, False) def display_time():    while True:        now = time.localtime(time.time())        time.sleep(t)        showDigit(1, int(time.strftime(&quot;%H&quot;, now)) / 10, False)        time.sleep(t)        showDigit(2, int(time.strftime(&quot;%H&quot;, now)) % 10, True)        time.sleep(t)        showDigit(3, int(time.strftime(&quot;%M&quot;, now)) / 10, False)        time.sleep(t)        showDigit(4, int(time.strftime(&quot;%M&quot;, now)) % 10, False)try:    display_time()finally:    GPIO.cleanup()</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>效果如下：</p><p><img src="https://images.happy365.day/24/04/17222047.png" alt="效果图"></p><p>可能是二极管余辉的原因？每个数字显示得都很不纯净，暂时先这样吧。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf分页模板</title>
      <link href="/2020/01/01/990f01d0c9f5/"/>
      <url>/2020/01/01/990f01d0c9f5/</url>
      
        <content type="html"><![CDATA[<p>经常在用 Thymeleaf 分页，很多基础的知识已经有点淡忘了，今天做到了分页部分，发现连最基础的逻辑比较都记不清了。于是花了点时间又看了下 Thymeleaf 的基础知识，做了一个相当简陋的分页，记录一下以后翻用。</p><span id="more"></span><p>分页工具类：</p><pre><code class="java">package com.bill.util;import lombok.Data;import java.util.List;/** * 分页工具类，获取分页相关数据项。 * * @author zhulongkun20@163.com * @since 2019/12/29 4:01 下午 */@Datapublic class PageHelper&lt;T&gt; &#123;    // 当前页码    private int currentPage;    // 每页数据量    private int pageSize;    // 总页数    private int totalPage;    // 总数据量    private int totalCount;    // 返回数据    private List&lt;T&gt; dataList;    // 是否为第一页    private boolean isFirstPage;    // 是否是最后一页    private boolean isLastPage;    // 是否有前一页    private boolean hasPreviousPage;    // 是否有后一页    private boolean hasNextPage;    public PageHelper(int currenPage, int pageSize, int totalCount, List&lt;T&gt; dataList) &#123;        this.currentPage = currenPage;        this.pageSize = pageSize;        this.totalCount = totalCount;        this.dataList = dataList;        if (totalCount % pageSize == 0) &#123;            this.totalPage = totalCount / pageSize;        &#125; else &#123;            this.totalPage = totalCount / pageSize + 1;        &#125;        this.isFirstPage = (currentPage == 1);        this.isLastPage = (currentPage == totalPage);        this.hasNextPage = !isLastPage;        this.hasPreviousPage = !isFirstPage;    &#125;&#125;</code></pre><p>Thymeleaf模板：</p><pre><code class="jsp">&lt;ul class=&quot;pagination&quot; style=&quot;float: right;&quot;&gt;    &lt;li&gt;        &lt;a href=&quot;#&quot; th:href=&quot;@&#123;billContent.do?page=1&#125;&quot;&gt;&amp;laquo;&lt;/a&gt;    &lt;/li&gt;    &lt;li th:if=&quot;$&#123;pageHelper.getCurrentPage() - 2&#125; &amp;gt; 0&quot;&gt;        &lt;a th:text=&quot;$&#123;pageHelper.getCurrentPage() - 2&#125;&quot;           th:href=&quot;@&#123;&#39;billContent.do?page=&#39; + $&#123;pageHelper.getCurrentPage() - 2&#125;&#125;&quot;&gt;1&lt;/a&gt;    &lt;/li&gt;    &lt;li th:if=&quot;$&#123;pageHelper.getCurrentPage() - 1&#125; &amp;gt; 0&quot;&gt;        &lt;a th:text=&quot;$&#123;pageHelper.getCurrentPage() - 1&#125;&quot;           th:href=&quot;@&#123;&#39;billContent.do?page=&#39; + $&#123;pageHelper.getCurrentPage() - 1&#125;&#125;&quot;&gt;1&lt;/a&gt;    &lt;/li&gt;    &lt;li class=&quot;active&quot;&gt;        &lt;a th:text=&quot;$&#123;pageHelper.getCurrentPage()&#125;&quot; th:href=&quot;@&#123;&#39;billContent.do?page=&#39; + $&#123;pageHelper.getCurrentPage()&#125;&#125;&quot;&gt;1&lt;/a&gt;    &lt;/li&gt;    &lt;li th:if=&quot;$&#123;pageHelper.getCurrentPage() + 1&#125; &amp;lt; $&#123;pageHelper.getTotalPage() + 1&#125;&quot;&gt;        &lt;a th:text=&quot;$&#123;pageHelper.getCurrentPage() + 1&#125;&quot;           th:href=&quot;@&#123;&#39;billContent.do?page=&#39; + $&#123;pageHelper.getCurrentPage() + 1&#125;&#125;&quot;&gt;1&lt;/a&gt;    &lt;/li&gt;    &lt;li th:if=&quot;$&#123;pageHelper.getCurrentPage() + 2&#125; &amp;lt; $&#123;pageHelper.getTotalPage() + 1&#125;&quot;&gt;        &lt;a th:text=&quot;$&#123;pageHelper.getCurrentPage() + 2&#125;&quot;           th:href=&quot;@&#123;&#39;billContent.do?page=&#39; + $&#123;pageHelper.getCurrentPage() + 2&#125;&#125;&quot;&gt;1&lt;/a&gt;    &lt;/li&gt;    &lt;li&gt;        &lt;a href=&quot;#&quot; th:href=&quot;@&#123;&#39;billContent.do?page=&#39; + $&#123;pageHelper.getTotalPage()&#125;&#125;&quot;&gt;&amp;raquo;&lt;/a&gt;    &lt;/li&gt;&lt;/ul&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac系统下更改MySQL字符集</title>
      <link href="/2019/12/31/ebfc8ee7e46b/"/>
      <url>/2019/12/31/ebfc8ee7e46b/</url>
      
        <content type="html"><![CDATA[<p>解决方案： <a href="https://zhuanlan.zhihu.com/p/34655552">Mac环境下的MySQL编码设置</a></p><span id="more"></span><p>昨天晚上造测试数据的时候，无意间加进去几条中文数据，然后在终端里select出来之后发现中文全部变成问号了。然后就上网搜“Mac系统下修改MySQL字符集”，很多教程的内容是：</p><ol><li><p>去 &#x2F;etc 目录下找是否有 my.cnf 文件；</p></li><li><p>如果没有的话去 &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files 文件夹下找 my-default.cnf 文件并复制到 &#x2F;etc&#x2F;my.cnf ，在[client]和[mysqld]标签下加上：</p><pre><code class="properties">default-character-set = utf8default-storage-engine = INNODBcharacter-set-server = utf8collation-server = utf8_general_ci </code></pre></li></ol><p>但是我本地的 &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files 目录下并没有 .cnf 文件，后来才知道是版本的问题，我本地装的 MySQL 是 5.7.28 ，已经没有了这个文件。</p><p>解决方案：</p><p>先在系统偏好设置里停掉 MySQL 服务，然后自己在 &#x2F;etc 下创建一个 my.cnf 文件，保存之后再重启 MySQL 即可。</p><pre><code class="properties"># Example MySQL config file for medium systems. # # This is for a system with little memory (32M - 64M) where MySQL plays # an important part, or systems up to 128M where MySQL is used together with # other programs (such as a web server) # # MySQL programs look for option files in a set of # locations which depend on the deployment platform. # You can copy this option file to one of those # locations. For information about these locations, see: # http://dev.mysql.com/doc/mysql/en/option-files.html # # In this file, you can use all long options that a program supports. # If you want to know which options a program supports, run the program # with the &quot;--help&quot; option. # The following options will be passed to all MySQL clients [client]default-character-set=utf8#password = your_password port = 3306 socket = /tmp/mysql.sock # Here follows entries for some specific programs # The MySQL server [mysqld]character-set-server=utf8init_connect=&#39;SET NAMES utf8port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8 init_connect=&#39;SET NAMES utf8&#39; # Don&#39;t listen on a TCP/IP port at all. This can be a security enhancement, # if all processes that need to connect to mysqld run on the same host. # All interaction with mysqld must be made via Unix sockets or named pipes. # Note that using this option without enabling named pipes on Windows # (via the &quot;enable-named-pipe&quot; option) will render mysqld useless! # #skip-networking# Replication Master Server (default) # binary logging is required for replication log-bin=mysql-bin# binary logging format - mixed recommended binlog_format=mixed# required unique id between 1 and 2^32 - 1 # defaults to 1 if master-host is not set # but will not function as a master if omitted server-id = 1# Replication Slave (comment out master section to use this) # # To configure this host as a replication slave, you can choose between # two methods : # # 1) Use the CHANGE MASTER TO command (fully described in our manual) - # the syntax is: # # CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;, # MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ; # # where you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and # &lt;port&gt; by the master&#39;s port number (3306 by default). # # Example: # # CHANGE MASTER TO MASTER_HOST=&#39;125.564.12.1&#39;, MASTER_PORT=3306, # MASTER_USER=&#39;joe&#39;, MASTER_PASSWORD=&#39;secret&#39;; # # OR # # 2) Set the variables below. However, in case you choose this method, then # start replication for the first time (even unsuccessfully, for example # if you mistyped the password in master-password and the slave fails to # connect), the slave will create a master.info file, and any later # change in this file to the variables&#39; values below will be ignored and # overridden by the content of the master.info file, unless you shutdown # the slave server, delete master.info and restart the slaver server. # For that reason, you may want to leave the lines below untouched # (commented) and instead use CHANGE MASTER TO (see above) # # required unique id between 2 and 2^32 - 1 # (and different from the master) # defaults to 2 if master-host is set # but will not function as a slave if omitted #server-id = 2 # # The replication master for this slave - required #master-host = &lt;hostname&gt; # # The username the slave will use for authentication when connecting # to the master - required #master-user = &lt;username&gt; # # The password the slave will authenticate with when connecting to # the master - required #master-password = &lt;password&gt; # # The port the master is listening on. # optional - defaults to 3306 #master-port = &lt;port&gt; # # binary logging - not required for slaves, but recommended #log-bin=mysql-bin# Uncomment the following if you are using InnoDB tables #innodb_data_home_dir = /usr/local/mysql/data #innodb_data_file_path = ibdata1:10M:autoextend #innodb_log_group_home_dir = /usr/local/mysql/data # You can set .._buffer_pool_size up to 50 - 80 % # of RAM but beware of setting memory usage too high #innodb_buffer_pool_size = 16M #innodb_additional_mem_pool_size = 2M # Set .._log_file_size to 25 % of buffer pool size #innodb_log_file_size = 5M #innodb_log_buffer_size = 8M #innodb_flush_log_at_trx_commit = 1 #innodb_lock_wait_timeout = 50[mysqldump] quick max_allowed_packet = 16M[mysql] no-auto-rehash # Remove the next comment character if you are not familiar with SQL #safe-updates default-character-set=utf8[myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M[mysqlhotcopy] interactive-timeout</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 字符集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV打不开摄像头:Process finished with exit code 134</title>
      <link href="/2019/12/29/b463591ba3aa/"/>
      <url>/2019/12/29/b463591ba3aa/</url>
      
        <content type="html"><![CDATA[<p>报错信息：</p><pre><code>Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</code></pre><span id="more"></span><p>一个在树莓派上完全没有问题的打开摄像头的脚本，在笔记本上跑时报错，摄像头无法打开：</p><pre><code class="python">#!/usr/bin/env python# _*_ coding:utf-8 _*_import cv2import numpycamera = cv2.VideoCapture(0)while True:    ret, frame = camera.read()    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)    cv2.imshow(&#39;frame&#39;, frame)    if cv2.waitKey(1) == ord(&#39;q&#39;):        break</code></pre><p>这个问题困扰了很久，外网上查了很久也没有找到解决方案。因为树莓派上挂了摄像头，插拔不是很方便，并且公司的显示器是VGA接口，所以今天出门没带树莓派。下午打开PyCharm想继续学习一下OpenCV，但是又被这个错给拦住了。</p><p><img src="https://images.happy365.day/24/04/17225513.png" alt="报错信息"></p><p>无意间想到会不会是Python没有权限调用系统摄像头导致的，然后在终端用管理员权限跑一下这个脚本，然后系统弹出一个弹窗，大概意思是询问<strong>“是否允许Python调用摄像头”</strong>，我还想思考一会儿，然后终端就报错了：</p><p><img src="https://images.happy365.day/24/04/17225607.png" alt="提示"></p><pre><code>Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</code></pre><p>原来之前一直都是因为权限的原因，然后点了允许，之后就不报错了。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将YouTube直播转播到bilibili的想法及尝试</title>
      <link href="/2019/12/17/50aa8cdba5d5/"/>
      <url>/2019/12/17/50aa8cdba5d5/</url>
      
        <content type="html"><![CDATA[<p>将YouTube直播转播到bilibili的想法及尝试</p><p>周末的时候本来在学习Swift的，不经意间打开Youtube直播，看到 大阪伊丹国际机场的 live camera 直播，出于对民航的兴趣，觉得直播里的陆空对话可以很好的打发时间，于是产生了能否24小时将Youtube的直播转播到墙内的疑问，带着这个疑问折腾了两天。</p><span id="more"></span><iframe width="560" height="315" src="https://www.youtube.com/embed/pV2RaaoxyF8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><大阪国际机场live camera含陆空对话>(需要梯子)<p>在往上搜了一些资料，发现已经有很多人实现了我的想法，而且做法也超级简单：</p><ul><li>YouTube 直播地址</li><li>一个海外vps</li><li>youtube-dl</li><li>ffmpeg</li><li>bilibili直播地址</li></ul><p>用youtube-dl获取直播m3u8文件，然后用ffmpeg不断读取流数据，然后推流到bilibili直播：</p><pre><code class="bash">ffmpeg -re -i &quot;$(youtube-dl -f 95 -g &quot;https://www.youtube.com/watch?v=pV2RaaoxyF8&quot;)&quot; -c:v copy -c:a aac -b:v 5000k -ar 44100 -ab 320k -ac 2 -strict -2 -flags +global_header -bsf:a aac_adtstoasc -bufsize 3000k -f flv &quot;rtmp://txy.live-send.acg.tv/live-txy/?streamname=xxxx&amp;key=yyyy&quot;</code></pre><p>用这个命令就可以实现上面的功能。</p><p>但是在实际使用操作过程中，总是在发送了100帧数据左右开始报错：</p><pre><code class="bash">[tls @ 0x5566d890ffe0] The TLS connection was non-properly terminated.[tls @ 0x5566d8fd25a0] The TLS connection was non-properly terminated.[tls @ 0x5566d8fd25a0] The specified session has been invalidated for some reason.av_interleaved_write_frame(): Broken pipeError writing trailer of rtmp://txy.live-send.acg.tv/live-txy/?streamname=xxxx[aac @ 0x5566d8cf45e0] Qavg: 65536.000Conversion failed!</code></pre><p>TLS连接被关闭，在搜了一大堆资料后我依然怀疑是youtube没有正确的关闭连接，导致报错。还做了很多其他的验证：</p><ul><li>尝试在树莓派上安装ffmpeg往bilibili推流，直播了一个网上将近十来个小时，没有任何问题。</li><li>在香港vps上将一段已经下载好的视频推流到bilibili，有问题。</li><li>在美国vps上将一段已经下载好的视频推到bilibili，有问题。</li><li>在香港vps上将一段已经下载好的视频推流到YouTube，没有问题。</li><li>在美国vps上将一段已经下载好的视频推流到YouTube，没有问题。</li><li>在香港和美国vps上换了和树莓派相同版本的v4.1.1 ffmpeg重复上述操作，结果不变。</li></ul><p>将google搜索到的结果几乎都看了一遍，也没找到多少有价值的信息。</p><p>今天晚上在思考其他解决方案的时候，看到bilibili专栏的文章，尝试了作者用java写的jar包，也报相同的错误，于是联系了作者，才得知，原来这个方法已经失效了。</p><blockquote><p> <strong>这个脚本早就报废了的，现在B站只有官方py或者报备了的才可以从海外推。目前转播man已经失业，有更好转播的方案。爱丽丝</strong></p></blockquote><p>原来上面的报错是因为bilibili掐断了连接导致的。不过这也打消了我最初的疑虑：侵权问题。</p><p>这个想法可能要先放一段时间了，目前的想法是想尝试一下用 OpenCV 和 ffmpeg 能不能实现，不知道什么时候才能重新捡起来（逃）。</p>]]></content>
      
      
      <categories>
          
          <category> 玩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YouTube </tag>
            
            <tag> 转播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装OpenCV-Python</title>
      <link href="/2019/11/10/f4be4362a6d4/"/>
      <url>/2019/11/10/f4be4362a6d4/</url>
      
        <content type="html"><![CDATA[<p>之前在MacOS上安装OpenCV还比较顺利，直接在PyCharm里用pip安装就成功了。但是在树莓派上安装OpenCV一直依赖关系的错。最终在重新安装完Raspberry OS之后，用清华的源安装成功了。</p><span id="more"></span><h2 id="更换清华源"><a href="#更换清华源" class="headerlink" title="更换清华源"></a>更换清华源</h2><p>官方资料：<a href="https://mirror.tuna.tsinghua.edu.cn/help/raspbian/">Raspbian 镜像使用帮助</a></p><p>设置：</p><pre><code class="bash"># 编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代：deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contribdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib# 编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代：deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</code></pre><h2 id="安装OpenCV-Python"><a href="#安装OpenCV-Python" class="headerlink" title="安装OpenCV-Python"></a>安装OpenCV-Python</h2><p>执行命令：</p><pre><code class="bash"># 安装必要软件sudo apt-get install -y libjasper-dev libqtgui4 libqt4-test# 安装OpenCVsudo apt install python-opencv</code></pre><p>3b+更换为国内源的话大概一两分钟，就安装完成了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>利用OpenCV打开摄像头，并读取视频数据显示出来：</p><pre><code class="python"># !/usr/bin/env python# _*_ coding:utf-8 _*_import cv2import numpy as npcap = cv2.VideoCapture(0)if not cap.isOpened():    print(&quot;camera is still closed.&quot;)while cap.isOpened():    ret, frame = cap.read()    if ret == True:        cv2.imshow(&#39;Frame&#39;, frame)        if cv2.waitKey(25) &amp; 0xFF == ord(&#39;q&#39;):            break    else:        breakcap.release()cv2.destroyAllWindows()</code></pre><p>如果是利用终端命令通过ssh远程执行的话，会出错：cannot open display，因为ssh无法打开窗口，在树莓派终端执行不会报错。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换七牛云过期SSL证书</title>
      <link href="/2019/11/10/c81d6b423cb8/"/>
      <url>/2019/11/10/c81d6b423cb8/</url>
      
        <content type="html"><![CDATA[<p>更换七牛云过期SSL证书</p><p>转眼博客已经跑了一年了，最近又是域名到期、又是SSL证书到期。</p><p>刚给域名续了5年的费，存储在七牛云的图片因为SSL证书到期加载不出来了。提示“存在隐私安全隐患”，通过图片外链访问也无法加载图片，Chrome直接拒绝连接。</p><p>一年前配置的，流程有些忘了，今天晚上又摸索了一遍。</p><span id="more"></span><h2 id="七牛云申请证书"><a href="#七牛云申请证书" class="headerlink" title="七牛云申请证书"></a>七牛云申请证书</h2><p>据说七牛云不支持阿里云申请的证书，所以没在阿里云申请，直接在七牛云申请了TrustAisa的一年免费证书。</p><p>具体流程：</p><p>登录七牛云 &gt; SSL证书服务 &gt; 购买证书 &gt; 填写必要信息购买指向目标域名的证书（选择TrustAsia免费证书，验证方式选择DNS验证，个人信息可以随便填，貌似不需要验证）</p><h2 id="添加域名验证"><a href="#添加域名验证" class="headerlink" title="添加域名验证"></a>添加域名验证</h2><p>到域名解析里添加对应的TEXT类型的记录，记录值为申请证书时指定的值。我直接将以前的值变更成了新的值。</p><h2 id="应用SSL证书"><a href="#应用SSL证书" class="headerlink" title="应用SSL证书"></a>应用SSL证书</h2><p>大概十分钟左右证书签发成功后，到 对象存储 &gt; 域名管理 &gt; 配置 &gt; HTTPS 配置 &gt; 强制 HTTPS &gt; 可更换证书列表里选择刚才申请的证书，然后应用。等待几分钟之后，便能通过HTTPS访问存储内容了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 七牛云 </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS下RIME输入法的配置</title>
      <link href="/2019/11/09/0a20e4822955/"/>
      <url>/2019/11/09/0a20e4822955/</url>
      
        <content type="html"><![CDATA[<p>之前一直用的搜狗输入法，不得不说，搜狗输入法确实做得很不错，精准快速。但是毕竟是国产软件，联网之后隐私方面存在安全隐患💦。本想直接设置成单机版以避免输入法上传输入记录，但是貌似防火墙和改hosts文件对搜狗都不管用。于是在网上查了一下，知道了 <strong>RIME输入法</strong> 。</p><span id="more"></span><p>看到配置比较复杂，我也是犹豫了半天才下定决心搞一下的。还差 emoji表情的输入 没搞定，只弄好了基础的中文输入以及词库的扩展，以后真正有需要了再配置吧。</p><p>比较好的参考资料：</p><ul><li><p><a href="https://github.com/rime/squirrel">GitHub主页</a></p></li><li><p><a href="http://ju.outofmemory.cn/entry/178796">给 Rime 添加第三方词库</a></p></li><li><p><a href="https://lonelygo.github.io/2015-01-28-Rime_Input/">Rime输入法—Squirrel词库添加及配置</a> （虽然有点旧了，但是很详细，推荐）</p></li></ul><p>安装完体验了两个小时，输入体验很不错，没遇到什么问题，以后应该会一直用下去。</p><p>各种软件还是去国产化吧，对待国产软件，有替代则替代，能不用则不用。</p>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 输入法 </tag>
            
            <tag> RIME </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scp-Linux文件复制命令</title>
      <link href="/2019/11/03/fa1ed4d5833c/"/>
      <url>/2019/11/03/fa1ed4d5833c/</url>
      
        <content type="html"><![CDATA[<p>scp — Linux文件复制命令</p><blockquote><p>用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。</p></blockquote><span id="more"></span><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul><li>-P: 端口号</li><li>-r: 递归复制</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code class="bash"># 上传文件scp -r -P xxxx /home/local_user/file_path remote_user@remote_host_addr:/home/remote_user/file_path# 下载文件时将 source 和 target 调换一下scp -r -P xxxx remote_user@remote_host_addr:/home/remote_user/file_path /home/local_user/file_path</code></pre><h2 id="Permission-denied-问题"><a href="#Permission-denied-问题" class="headerlink" title="Permission denied 问题"></a>Permission denied 问题</h2><p>今天下午上传文件到服务器的时候一直报这个错：</p><pre><code class="bash">scp -P xxxx file.torrent test@test:/home# 输出test@test.com&#39;s password: scp: /home/25316538e6498c7645e3da963253977d.torrent: Permission deniedv</code></pre><p>保证密码输入正确并且重试了好几次都报同样的错，才想起来以前遇到这个问题，是因为当前用户对目标目录没有操作权限导致的，只要把目标路径改到当前用户目录下就好了。</p><pre><code class="bash">scp -P xxxx file.torrent test@test:/home/test/Downloads</code></pre><p>参考：<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/scp.html">18. scp 跨机远程拷贝</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> scp命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV——cv2.inRange()函数</title>
      <link href="/2019/10/14/17a198a5f3dd/"/>
      <url>/2019/10/14/17a198a5f3dd/</url>
      
        <content type="html"><![CDATA[<p>在图像中提取目标物时可以用该函数去除背景。</p><p>有三个参数：</p><ul><li>hsv_img：颜色空间为 HSV 的图像；</li><li>lower：下阈值，图像中低于此值的颜色值变为 0；</li><li>uppper：上阈值，图像中高于此值的颜色值变为 0。</li></ul><span id="more"></span><p>颜色值在此范围内的全部设置为255，然后利用得到背景和原图片进行位操作，即可得到原图中目标。</p><p>常用方式：</p><pre><code class="python">img = cv2.imread(img_path, 0)img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)lower = [0, 100, 100]uppper = [200, 255, 255]# 利用上下阈值去除背景部分mask = cv2.inRange(img_hsv, lower, upper)# 利用位运算得到目标物体target = cv2.bitwise_and(img, img, mask=mask)cv2.imshow(&quot;mask&quot;, mask)cv2.imshow(&quot;target&quot;, target)</code></pre><p>上下阈值的获取：</p><pre><code class="python">import cv2import numpy as npcolor = np.array([[[xxx, xxx, xxx]]])hsv_color = cv2.cvtColor(color, cv2.COLOR_RGB2HSV)print(hsv_color)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV 学习笔记（一）</title>
      <link href="/2019/10/12/b432dd49420f/"/>
      <url>/2019/10/12/b432dd49420f/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/OpenCV">OpenCV — 维基百科</a> </p><p><strong>OpenCV</strong>的全称是Open Source Computer Vision Library，是一个跨平台的<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89">计算机视觉</a>库。OpenCV是由<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E7%89%B9%E5%B0%94">英特尔公司</a>发起并参与开发，以<a href="https://zh.wikipedia.org/wiki/BSD%E8%AE%B8%E5%8F%AF%E8%AF%81">BSD许可证</a>授权发行，可以在商业和研究领域中免费使用。OpenCV可用于开发实时的<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86">图像处理</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89">计算机视觉</a>以及<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB">模式识别</a>程序。</p><span id="more"></span><h2 id="读取和显示图像"><a href="#读取和显示图像" class="headerlink" title="读取和显示图像"></a>读取和显示图像</h2><ul><li>cv2.imread()：读取</li><li>cv2.imwrite()：写入</li><li>cv2.imshow()：显示</li></ul><pre><code class="python">img = cv2.imread(img_path, 0)cv2.namedWindow(&quot;imview&quot;, cv2.WINDOW_NORMAL)cv2.imshow(&quot;imview&quot;, img)k = cv2.waitKey(0)if k == ord(&quot;s&quot;):  cv2.imwrite(&quot;other.jpg&quot;, img)cv2.destroyAllWindows()</code></pre><h2 id="视频的操作"><a href="#视频的操作" class="headerlink" title="视频的操作"></a>视频的操作</h2><h3 id="从摄像头读取视频"><a href="#从摄像头读取视频" class="headerlink" title="从摄像头读取视频"></a>从摄像头读取视频</h3><ul><li>cv2.VideoCapture(0).read()</li><li>cv2.cvtColor()</li><li>cv2.imshow()</li><li>cap.get(propId)</li></ul><pre><code class="python">def create_video():    cap = cv2.VideoCapture(0)    while True:        ret, frame = cap.read()        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)        cv2.imshow(&quot;frame&quot;, gray)        if cv2.waitKey() == ord(&quot;q&quot;):            break    cap.release()    cv2.destroyAllWindows()       def video():    cap = cv2.VideoCapture(0)    fourcc = cv2.VideoWriter_fourcc(*&#39;XVID&#39;)    out = cv2.VideoWriter(&quot;output.avi&quot;, fourcc, 20, 0, (640, 480))    while (cap.isOpened()):        ret, frame = cap.read()        if ret:            frame = cv2.flip(frame, 0)            out.write(frame)            cv2.imshow(&quot;video&quot;, frame)            if cv2.waitKey(0) == ord(&quot;q&quot;):                break        else:            break    cap.release()    out.release()    cv2.destroyAllWindows()</code></pre><h3 id="从文件中获取视频"><a href="#从文件中获取视频" class="headerlink" title="从文件中获取视频"></a>从文件中获取视频</h3><p>cv2.VideoCapture(0)表示打开默认设备，将设备索引号改成视频文件的名称就能从视频文件中读取视频，使用 waitKey()控制播放速度（通常25 ms）。</p><h2 id="OpenCV-中的绘图函数"><a href="#OpenCV-中的绘图函数" class="headerlink" title="OpenCV 中的绘图函数"></a>OpenCV 中的绘图函数</h2><p>学会以下函数的使用：</p><ul><li>cv2.line()</li><li>cv2.circle()</li><li>cv2.rectangle()</li><li>cv2.ellipse()</li><li>cv2.putText()</li></ul><p>参数：上面所有的绘图函数都需要的参数：</p><ul><li>img ：画布</li><li>color : 指定的颜色，RGB-&gt;(255, 255, 0)</li><li>linetype : 线条的类型，8连接，抗锯齿等。lineType&#x3D;cv2.LINE_AA（抗锯齿）。</li></ul><h3 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h3><p>画一条直线需要指定直线的起点和终点：</p><pre><code class="python">def draw_line2():    canvas = np.zeros((300, 300, 3), dtype=&quot;uint8&quot;)    green = (0, 255, 0)    cv2.line(canvas, (20, 20), (150, 150), color=green)    cv2.imshow(&quot;green line&quot;, canvas)    cv2.waitKey(0)</code></pre><h3 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h3><p>绘制矩形需要指定两个点的坐标：</p><pre><code class="python">def draw_rectangle():    canvas = np.zeros((300, 300, 3), dtype=&quot;uint8&quot;)    color = (126, 126, 126)    cv2.rectangle(canvas, (80, 80), (250, 270), color=color)    cv2.imshow(&quot;rectangle&quot;, canvas)    cv2.waitKey(0)</code></pre><h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><p>绘制圆形需要指定圆心坐标和半径大小：</p><pre><code class="python">def draw_circle():    canvas = np.zeros((300, 300, 3), dtype=&quot;uint8&quot;)    color = (100, 100, 100)    cv2.circle(canvas, (150, 140), 100, color=color)    cv2.imshow(&quot;circle&quot;, canvas)    cv2.waitKey(0)</code></pre><h3 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h3><p>绘制椭圆需要指定的参数：</p><ol><li>中心点坐标</li><li>长轴和短轴</li><li>沿逆时针方向旋转的角度</li><li>顺时针方向起始角度和结束角度</li></ol><pre><code class="python">def draw_ellipse():    canvas = np.zeros((400, 400, 3), dtype=&quot;uint8&quot;)    color = (100, 100, 100)    cv2.ellipse(canvas, (200, 200), (100, 150), 0, 0, 360, color)    cv2.imshow(&quot;ellipse&quot;, canvas)    cv2.waitKey(0)</code></pre><h3 id="在图片中添加文字"><a href="#在图片中添加文字" class="headerlink" title="在图片中添加文字"></a>在图片中添加文字</h3><p>所需参数：</p><ul><li>添加的文本</li><li>绘制的位置</li><li>字体类型</li><li>字体大小</li><li>文字的一般属性（颜色，粗细，线条类型等）</li></ul><pre><code class="python">def put_text():    canvas = np.zeros((300, 600, 3), dtype=&quot;uint8&quot;)    font = cv2.FONT_HERSHEY_SIMPLEX    cv2.putText(canvas, &#39;Kanna Makino&#39;, (10, 100), font, 2, (100, 100, 100), 2)    cv2.imshow(&quot;put text&quot;, canvas)    cv2.waitKey(0)    cv2.destroyAllWindows()</code></pre><h2 id="简单的鼠标事件"><a href="#简单的鼠标事件" class="headerlink" title="简单的鼠标事件"></a>简单的鼠标事件</h2><ul><li>学习使用 OpenCV 处理鼠标事件</li><li>函数：<strong>cv2.setMouseCallback()</strong></li></ul><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>鼠标事件可以获得事件对应的坐标和事件名称。</p><pre><code class="python">def draw_circle(event, x, y, flags, params):    if event == cv2.EVENT_LBUTTONDBLCLK:        cv2.circle(img, (x, y), 100, (255, 255, 255), -1, lineType=cv2.LINE_AA)img = np.zeros((512, 512, 3), dtype=&quot;uint8&quot;)cv2.namedWindow(&#39;image&#39;)cv2.setMouseCallback(&#39;image&#39;, draw_circle)while 1:    cv2.imshow(&#39;image&#39;, img)    if cv2.waitKey(20) &amp; 0xFF == 27:        breakcv2.destroyAllWindows()</code></pre><h2 id="用滑动条做调色板"><a href="#用滑动条做调色板" class="headerlink" title="用滑动条做调色板"></a>用滑动条做调色板</h2><p>学习目标：</p><ul><li>学会把滑动条绑定到 OpenCV 的窗口</li><li>cv2.getTrackbarPos()</li><li>cv2.createTrackbar()</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code class="python">#!/usr/bin/env python# _*_cdoing:utf-8_*_import numpy as npimport cv2def nothing(x):    passimg = np.zeros((500, 312, 3), dtype=&quot;uint8&quot;)cv2.namedWindow(&quot;image&quot;)cv2.createTrackbar(&quot;R&quot;, &quot;image&quot;, 0, 255, nothing)cv2.createTrackbar(&quot;G&quot;, &quot;image&quot;, 0, 255, nothing)cv2.createTrackbar(&quot;B&quot;, &quot;image&quot;, 0, 255, nothing)switch = &#39;0:OFF\n1:ON&#39;cv2.createTrackbar(switch, &quot;image&quot;, 0, 1, nothing)while 1:    cv2.imshow(&quot;image&quot;, img)    k = cv2.waitKey(1) &amp; 0xFF    if k == 27:        break    r = cv2.getTrackbarPos(&quot;R&quot;, &quot;image&quot;)    g = cv2.getTrackbarPos(&quot;G&quot;, &quot;image&quot;)    b = cv2.getTrackbarPos(&quot;B&quot;, &quot;image&quot;)    s = cv2.getTrackbarPos(switch, &quot;image&quot;)    if s == 0:        img[:] = 0    else:        img[:] = [r, g, b]cv2.destroyAllWindows()</code></pre><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><blockquote><p>创建一个画板，可以选择各种颜色的画笔进行绘画操作。</p></blockquote><p>代码：</p><pre><code class="python">def draw_circle(event, x, y, flag, params):  pass</code></pre><h2 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h2><h2 id="图像的基础操作"><a href="#图像的基础操作" class="headerlink" title="图像的基础操作"></a>图像的基础操作</h2><p>学习目标：</p><ul><li>获取像素的值并修改</li><li>获取图像的属性（信息）</li><li>图像的 ROI（）</li><li>图像通道的拆分与合并</li></ul><h3 id="获取图像的像素"><a href="#获取图像的像素" class="headerlink" title="获取图像的像素"></a>获取图像的像素</h3><pre><code class="python">img = cv2.imread(&quot;/Users/youyou2608/Pictures/pi.png&quot;)print(img.item(10, 10, 2))img.itemset((10, 10, 2), 100)print(img.item(10, 10, 2))# 图像的属性：行，列，通道，图像数据类型，像素数目等print(img.shape)# 像素数目print(img.size)# 图像的数据类型print(img.dtype)####### 输出 ######0100(487, 423, 3)618003uint8</code></pre><h3 id="图像的-ROI"><a href="#图像的-ROI" class="headerlink" title="图像的 ROI"></a>图像的 ROI</h3><p>有时对图像的某一特定区域进行搜索比在一张图像中搜索有更高的准确性和性能。</p><pre><code class="python">img = cv2.imread(&quot;/Users/youyou2608/Pictures/pi.png&quot;)temp = img[100:300, 10:100]img[0:200, 100:190] = tempcv2.imshow(&quot;image&quot;, img)cv2.waitKey(100000)</code></pre><h3 id="拆分及合并图像通道"><a href="#拆分及合并图像通道" class="headerlink" title="拆分及合并图像通道"></a>拆分及合并图像通道</h3><p>对 BGR 三个通道分别进行操作。</p><pre><code class="python"># 将图片所有共色通道值都设置为0img = cv2.imread(&quot;/Users/youyou2608/Pictures/pi.png&quot;)img[0:300, 0:200, 2] = 0cv2.imshow(&quot;image&quot;, img)</code></pre><h2 id="图像上的算术运算"><a href="#图像上的算术运算" class="headerlink" title="图像上的算术运算"></a>图像上的算术运算</h2><ul><li>学习图像上的加法、减法和位运算等</li><li>cv2.add()</li><li>cv2.addWeighted()</li></ul><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>进行加法的两幅图像的大小、类型必须一致。</p><pre><code class="python">x = np.uint([250])y = np.uint([20])print(cv2.add(x, y))  # [[255]]</code></pre><h3 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h3><p>图像混合其实也是加法，但是不同的是两幅图像的权重不同。</p><p>函数：cv2.addWeighted()</p><pre><code class="python">img1 = cv2.read(&quot;img1.png&quot;)img2 = cv2.read(&quot;img2.png&quot;)dst = cv2.addWeighted(img1, 0.7, img2, 0.3, 0)cv2.imshow(&quot;image&quot;, dst)cv2.waitKey(0)cv2.destroyAllWindows()</code></pre><p>后续…</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 mjpg-streamer 的树莓派视频监控</title>
      <link href="/2019/08/05/51553fb1e82e/"/>
      <url>/2019/08/05/51553fb1e82e/</url>
      
        <content type="html"><![CDATA[<h2 id="视频监控搭建"><a href="#视频监控搭建" class="headerlink" title="视频监控搭建"></a>视频监控搭建</h2><p>本来想用 python 来做的，但是 VLC 串流不知道是不是设置的问题，视频采集是正常的，但是接收端接收到的视频一团糊，在无意间知道了 <strong>mjpg-streamer</strong> 这个项目，GitHub 地址：<a href="https://github.com/jacksonliam/mjpg-streamer%E3%80%82">https://github.com/jacksonliam/mjpg-streamer。</a></p><span id="more"></span><p>安装方法参照GitHub：</p><pre><code class="shell">sudo apt-get install cmake libjpeg8-devsudo apt-get install gcc g++cd mjpg-streamer-experimentalmakesudo make install</code></pre><p>安装完之后就可以直接启动了：</p><pre><code class="shell">./mjpg_streamer -o &quot;output_http.so -w ./www&quot; -i &quot;input_raspicam.so&quot;</code></pre><p>默认使用8080端口，浏览器打开地址：</p><pre><code class="shell">http://192.168.0.103:8080/?action=stream</code></pre><p>就能实时查看树莓派摄像头采集到的视频。</p><h2 id="外网访问"><a href="#外网访问" class="headerlink" title="外网访问"></a>外网访问</h2><p>在局域网内，直接访问树莓派的 ip 地址就能查看视频，但是如果想从外网访问的话，还需要做点手脚。</p><p>使用 frp 反向隧道进行内网穿透。</p><p>先分别在vps 和树莓派上安装frp 服务：</p><pre><code class="shell">wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gz</code></pre><p>解压上面下载的文件。</p><p>服务器端配置文件：</p><pre><code>进去目录vi  frps.ini[common]bind_port = 7000         # frp与客户端绑定进行通信的端口auto_token = frp7vhost_http_port = 9000   # http 访问端口</code></pre><p>树莓派配置文件：</p><pre><code>1.进去目录2.vi frpc.ini[common]server_addr = 云服务器的IP   # frps所在的服务器的 IPserver_port = 7000                 # frp与服务器绑定进行通信的端口[ssh]type = tcplocal_ip = 192.168.0.103        # Pi所在局域网IPlocal_port = 22                       # 本地端口remote_port = 6000               # ssh远程访问端口[web]type = httplocal_port = 8080                   # web 服务对应的端口——mjpg-streamer所需端口custom_domains = 云服务器IP   # frps所在的服务器的 IP</code></pre><p>依次启动服务器端的 frp，树莓派视频采集，树莓派端 frp。</p><pre><code class="shell">./frps -c ./frps.ini./mjpg_streamer -o &quot;output_http.so -w ./www&quot; -i &quot;input_raspicam.so&quot;./frpc -c ./frpc.ini</code></pre><p>然后打开浏览器访问：<a href="http://xxx.xxx.xxx.xxx:9000/stream.html">http://xxx.xxx.xxx.xxx:9000/stream.html</a> ，不知道是不是因为 VPS 在国外的原因，延迟有3 s 这样子。。</p><p>注意：<strong>树莓派只能运行 arm 架构的 frp（<a href="http://diannaobos.iok.la:81/frp/frp-v0.20.0/frp_0.20.0_linux_arm.tar.gz">树莓派frp</a>）</strong>。</p><hr><p>参考：</p><p><a href="https://blog.csdn.net/weixin_40535588/article/details/89296894">基于树莓派+mjpg+frp+阿里云服务器的远程监控</a></p><p><a href="https://www.jianshu.com/p/069c61315e8a">树莓派上MJPG-streamer安装手顺</a></p>]]></content>
      
      
      <categories>
          
          <category> 玩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> mjpg-streamer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给树莓派安装Ubuntu MATE系统</title>
      <link href="/2019/06/11/2ebdd260ab5f/"/>
      <url>/2019/06/11/2ebdd260ab5f/</url>
      
        <content type="html"><![CDATA[<p>给树莓派安装Ubantu MATE操作系统</p><p>由于平时用的是Ubuntu系统，对这个系统比较熟悉，也想给树莓派也装这个系统，Linux下做SD卡启动盘网上资料比较少，担心发生对笔记本磁盘的误操作，最后在官网上找到了教程。</p><span id="more"></span><h2 id="下载系统"><a href="#下载系统" class="headerlink" title="下载系统"></a>下载系统</h2><p><a href="https://ubuntu-mate.org/raspberry-pi"><a href="https://ubuntu-mate.org/raspberry-pi/">Ubuntu MATE for the Raspberry Pi Model B 2, 3 and 3+</a></a></p><h2 id="安装工具并写入系统"><a href="#安装工具并写入系统" class="headerlink" title="安装工具并写入系统"></a>安装工具并写入系统</h2><pre><code>sudo apt-get install gddrescue xz-utilsunxz --verbose ubuntu-mate-18.04.2-beta1-desktop-armhf+raspi-ext4.img.xzsudo ddrescue -D --force ubuntu-mate-18.04.2-beta1-desktop-armhf+raspi-ext4.img /dev/sdx</code></pre><p><code>/dev/sda</code>代表笔记本的磁盘，SD卡的盘符一般<code>/dev/sdb1</code>。</p><h2 id="显示屏无反应"><a href="#显示屏无反应" class="headerlink" title="显示屏无反应"></a>显示屏无反应</h2><p>网上说可能是 config.txt 设置问题，和显示器的分辨率之类的有关，但是写入了镜像之后再将SD卡插入到PC，已经无法挂载，报错：</p><pre><code>sudo mount /dev/sdb1 /mnt/sdb1mount: /mnt/sdb1: wrong fs type, bad option, bad superblock on /dev/sdb1, missing codepage or helper program, or other error.</code></pre><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>进不去SD卡，挂载错误，说是文件类型错误。</p><p>安装工具：</p><p><code>sudo apt-get install nfs-common</code></p><p>仍然是无法读取。</p><p>先安装 <code>gnome-disk-utility</code> ，在终端执行 <code>./gnome-disk-utility</code> ，选择 <code>Restore Image...</code> ，写入镜像。</p><p>写完之后，退出SD卡。</p><p>将写入镜像的SD卡插入树莓派，连接显示器，接通电源，成功进入系统引导界面，清新的绿色界面。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> Ubuntu MATE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再记Hexo博客恢复</title>
      <link href="/2019/06/09/4f2c0153c7ad/"/>
      <url>/2019/06/09/4f2c0153c7ad/</url>
      
        <content type="html"><![CDATA[<p>从官网下载 Nodejs <strong>二进制</strong> 文件（.tar.xz），解压到 &#x2F;opt 目录下，添加连接：</p><p><code>sudo tar -xvf xxxx.tar.xz</code></p><p><code>sudo ln -s /opt/node-linux-x64xxxx/bin/node /usr/local/bin/node</code></p><p><code>sudo ln -s /opt/node..../bin/npm /usr/local/bin/npm</code></p><p>然后进入博客文件夹，执行</p><p><code>sudo npm install</code></p><p>即可完成恢复。</p><hr><p>折腾了半天一直各种报错，没想到这么简单。。</p>]]></content>
      
      
      <categories>
          
          <category> 博客维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客恢复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我在JavaScript中踩过的坑</title>
      <link href="/2019/05/19/4cbde4db3917/"/>
      <url>/2019/05/19/4cbde4db3917/</url>
      
        <content type="html"><![CDATA[<p>我在Javascript中踩过的坑！</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>时至今日也没有系统深入的学习过JavaScript，虽然常用，但是也只停留在最基础的使用上。没有系统深入的了解，必然要踩一些前端众所周知，却让小白绞尽脑汁地大坑！</p><p>今天又在坑里摸了一天，记录一下，权当是写日记了。</p><p>最近连续加班，确实有些身心俱疲；加上昨天下午的“午后小睡”导致晚上失眠，到快四点钟才睡着，今天早上快十点钟还躺在床上。</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>正在逛Twitter，做毕设地学妹给我提了两个需求：</p><ul><li>登陆页面的表单检验；</li><li>注册页面的重复用户名检测。</li></ul><h2 id="问题：从Ajax中返回值"><a href="#问题：从Ajax中返回值" class="headerlink" title="问题：从Ajax中返回值"></a>问题：从Ajax中返回值</h2><p>用JQuery.validate插件给登陆表单加了校验，挺简单，同样的方法给注册界面加个校验，唯一不同的是需要使用ajax从后台请求到用户名是否已经存在，也挺简单。</p><p>于是乎，有了下面这段代码：</p><pre><code class="javascript">// do something$.validator.addMethod(&quot;checkUniqueUsername&quot;, function(value, element, params) &#123;    return this.optional(element) || checkUniqueUsername(value);&#125;, &quot;用户名已被占用！&quot;);function checkUniqueUsername(username) &#123;    if (username !== null &amp;&amp; username !== undefined &amp;&amp; username !== &#39;&#39;) &#123;        var data = &#123;&#39;loginname&#39;: username&#125;;        $.ajax(&#123;            type: &#39;post&#39;,            url: &#39;/checkloginname&#39;,            data: JSON.stringify(data),            dataType: &#39;json&#39;,            contentType: &#39;application/json&#39;,            success: function (res) &#123;                return (parseInt(res.tip) === 0);            &#125;        &#125;);    &#125; else &#123;        return false;    &#125;&#125;</code></pre><p>三五分钟，就写完了代码，跑一跑测一下准备验收了。诡异的事情出现了，<code>checkUniqueUsername()</code>总是返回false。</p><h2 id="Ajax中return的结果"><a href="#Ajax中return的结果" class="headerlink" title="Ajax中return的结果"></a>Ajax中return的结果</h2><p>没事，静下心来慢慢调，就这几行代码，怎么说也要给你调得明明白白的。调试后发现<code>parseInt(res.tip)===0</code>是true，可是return 之后函数的返回值是false，这没道理啊！</p><p>网上查了一下，原来是在<strong>ajax中直接return并不是return到外层函数中</strong>，不深究，改个写法，于是有了v2版本：</p><pre><code class="javascript">// do something$.validator.addMethod(&quot;checkUniqueUsername&quot;, function(value, element, params) &#123;    return this.optional(element) || checkUniqueUsername(value);&#125;, &quot;用户名已被占用！&quot;);function checkUniqueUsername(username) &#123;    if (username !== null &amp;&amp; username !== undefined &amp;&amp; username !== &#39;&#39;) &#123;        var result = false;        var data = &#123;&#39;loginname&#39;: username&#125;;        $.ajax(&#123;            type: &#39;post&#39;,            url: &#39;/checkloginname&#39;,            data: JSON.stringify(data),            dataType: &#39;json&#39;,            contentType: &#39;application/json&#39;,            success: function (res) &#123;                result = (parseInt(res.tip) === 0);            &#125;        &#125;);        return result;    &#125; else &#123;        return false;    &#125;&#125;</code></pre><p>检查了一下，再也想不出还能有什么问题了，那就跑一下吧。诡异的结果又出现了，函数返回值依旧是false，心态崩了，这就好比 <code>var count = 1; console.log(count);</code>却输出了2一样，难以置信！</p><h2 id="Ajax同步和异步"><a href="#Ajax同步和异步" class="headerlink" title="Ajax同步和异步"></a>Ajax同步和异步</h2><p>查了半天，终于看到一个答案：<strong>ajax的同步和异步。</strong>可谓是一语惊醒梦中人，我责备自己为什么调试了这么久，却没有想到这个方向，而且同步异步的坑已经不是第一次踩了。v3版本终于解决了这个问题，失之毫厘，差之千里。</p><pre><code class="javascript">// do something$.validator.addMethod(&quot;checkUniqueUsername&quot;, function(value, element, params) &#123;    return this.optional(element) || checkUniqueUsername(value);&#125;, &quot;用户名已被占用！&quot;);function checkUniqueUsername(username) &#123;    if (username !== null &amp;&amp; username !== undefined &amp;&amp; username !== &#39;&#39;) &#123;        var result = false;        var data = &#123;&#39;loginname&#39;: username&#125;;        $.ajax(&#123;            type: &#39;post&#39;,            url: &#39;/checkloginname&#39;,            data: JSON.stringify(data),            dataType: &#39;json&#39;,            contentType: &#39;application/json&#39;,            async: false,            success: function (res) &#123;                result = (parseInt(res.tip) === 0);            &#125;        &#125;);        return result;    &#125; else &#123;        return false;    &#125;&#125;</code></pre><p>但是每次运行控制台都会出现JQuery的提示：<strong>使用同步会降低用户体验</strong>，总归是有个解决办法，有时间再深究一下吧。</p><h2 id="JavaScript浮点运算"><a href="#JavaScript浮点运算" class="headerlink" title="JavaScript浮点运算"></a>JavaScript浮点运算</h2><p>今天的经历让我回想起了去年遇到的一个JavaScript的问题，当时在做一个现金流管理系统，遇到一个需求是根据固定利息和浮动利息自动计算出最终利息，随便输了几组数据测试，没有出现异样，但是最后一组数据的时候出现了诡异的结果！<code>4.1 + 4.3 = 8.399999999999999</code>，这真是见了鬼了。。很久之前学过的知识这分钟哪里回想得起来。上网查了才发现原来是JavaScript的设计缺陷导致的问题，也都提出了几种解决方案。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>平时用Java习惯了，思维方式有些不灵活，从对Python的理解中也能看出来。</p><p>总之，遇到问题，要发散思维，尽量快速的去确定调查的方向，最终尽快的解决问题。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解简单例子</title>
      <link href="/2019/05/15/099b84bf427d/"/>
      <url>/2019/05/15/099b84bf427d/</url>
      
        <content type="html"><![CDATA[<p>了解Java注解（@Annotation）</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>为什么突然想起来注解呢？今天上午同事遇到一个和注解相关的问题，JSP页面传值到后台后（其实前后端并不分离），但是在POJO类上的校验注解值不满足的条件下也通过了，让我给帮忙看看。因为其他组的同事相同的通用代码并没有这个问题，而且对注解的处理是封装在框架中的，所以一开始便排除了问题在后台思路，转向页面传值去调查。虽然最后找到原因是因为没有清空Eclipse的.class文件重新编译，但是感觉已经对之前学过的注解部分的知识生疏了。刚好今天没加班，就赶紧复习一下。</p></blockquote><p>本想在网上找两篇文章回忆一下，但是好像例子写得都不完整。刚好前段时间刚买了一本《Java编程思想》，就赶紧翻开看了一下，一直记得书里给出的例子也是数据库字段注解相关的。</p><span id="more"></span><h2 id="相关概念及原理"><a href="#相关概念及原理" class="headerlink" title="相关概念及原理"></a>相关概念及原理</h2><p>参见 &#x3D;&#x3D;&gt; 《Java编程思想》第二十章&lt;注解&gt;。</p><p>四个元注解：</p><ul><li>@Target</li><li>@Retention</li><li>@Document</li><li>Inherited</li></ul><p>注解主要是用户按自己的需求来实现。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>先创建两个注解，@Digits和@NotEmpty，用来注解属性是否满足给定条件。</p><p>代码如下：</p><pre><code class="java">package com.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * &lt;p&gt; * 标注一个字段只能为数字，且最大长度为maxLength，最大小数位为fraction * 默认没有小数位 * &lt;/p&gt; * * @author zhulongkun20@163.com * @since 2019-05-14 21:42 */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Digits &#123;    public int maxLength();    public int fraction() default 0;&#125;</code></pre><pre><code class="java">package com.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * &lt;p&gt; * 标注一个字段不能为空 * &lt;/p&gt; * * @author zhulongkun20@163.com * @since 2019-05-14 21:47 */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface NotEmpty &#123;&#125;</code></pre><p>定义一个处理类处理自定义注解：（主要利用反射机制）</p><pre><code class="java">package com.Annotation;import java.lang.annotation.Annotation;import java.lang.reflect.Field;/** * &lt;p&gt; * 处理自定义注解 * &lt;/p&gt; * * @author zhulongkun20@163.com * @since 2019-05-14 21:59 */public class AnnotationProcesser &#123;    public void process(Table table) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException &#123;        Class clazz = table.getClass();        if (clazz == null) &#123;            throw new ClassNotFoundException(&quot;class not found!&quot;);        &#125;        Field[] fields = clazz.getDeclaredFields();        String fieldName;        for (Field field : fields) &#123;            System.out.println(&quot;--------------------------&quot;);            field.setAccessible(true);            Annotation[] annotations = field.getDeclaredAnnotations();            fieldName = field.getName();            System.out.println(&quot;--&gt; info: into &quot; + fieldName);            for (Annotation annotation : annotations) &#123;                System.out.println(&quot;--&gt; info: &quot; + annotation.annotationType());                if (annotation instanceof Digits) &#123;                    System.out.println(&quot;--&gt; info: get @Digits annotation on &quot; + fieldName);                    int maxLength = ((Digits) annotation).maxLength();                    int annotatedFraction = ((Digits) annotation).fraction();                    String[] fraction = String.valueOf(table.getCount()).split(&quot;\\.&quot;);                    if (String.valueOf(table.getCount()).length() &gt; maxLength) &#123;                        System.out.println(&quot;--&gt; error: maxLength exceed!&quot;);                    &#125;                    if (fraction.length &gt; 1 &amp;&amp; fraction[1].length() &gt; annotatedFraction) &#123;                        System.out.println(&quot;--&gt; error：fraction length exceed!&quot;);                    &#125; else &#123;                        System.out.println(&quot;--&gt; info: &quot; + fieldName + &quot; validate success!&quot;);                    &#125;                &#125; else if (annotation instanceof NotEmpty) &#123;                    System.out.println(&quot;--&gt; info: get @NotEmpty annotation on &quot; + fieldName);                    if (table.getDescription() == null || &quot;&quot;.equals(table.getDescription())) &#123;                        System.out.println(&quot;--&gt; error: empty is not allowed!&quot;);                    &#125; else &#123;                        System.out.println(&quot;--&gt; info: &quot; + fieldName + &quot; validate success!&quot;);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>主测试类：（<strong>省略getter和setter</strong>）</p><pre><code class="java">package com.Annotation;/** * &lt;p&gt; * 自定义注解测试类 * &lt;/p&gt; * * @author zhulongkun20@163.com * @since 2019-05-14 21:49 */public class Table &#123;    @Digits(maxLength = 6, fraction = 2)    private double count;    @NotEmpty    private String description;    public Table(double count, String description) &#123;        this.count = count;        this.description = description;    &#125;    public static void main(String[] args) throws IllegalAccessException, ClassNotFoundException, NoSuchFieldException &#123;        Table testTable1 = new Table(1234567, &quot;description1&quot;);        Table testTable2 = new Table(12.001, &quot;description2&quot;);        Table testTable3 = new Table(123.01, &quot;description3&quot;);        Table testTable4 = new Table(123.01, null);        Table testTable5 = new Table(123.01, &quot;description5&quot;);        AnnotationProcesser processer = new AnnotationProcesser();        processer.process(testTable1);        processer.process(testTable2);        processer.process(testTable3);        processer.process(testTable4);        processer.process(testTable5);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax返回error可能原因分析</title>
      <link href="/2019/05/12/519dad321718/"/>
      <url>/2019/05/12/519dad321718/</url>
      
        <content type="html"><![CDATA[<p>ajax总是进入error的可能原因</p><p>后台返回：</p><pre><code class="verilog">Successfully completed request</code></pre><p>前端ajax总是执行error部分的代码。</p><p>原因：</p><p>后台只返回了 “success” 字符串，不是规范的json格式，所以没有执行预期逻辑。</p><p>最好在后台返回 <strong>严格规范</strong> 的json防止此类错误。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot中使用Swagger2构建强大的RESTful API文档</title>
      <link href="/2019/04/29/8d4c26cd94d1/"/>
      <url>/2019/04/29/8d4c26cd94d1/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot中使用Swagger2构建强大的RESTful API文档</p><p>由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。</p><span id="more"></span><p>这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题：</p><ul><li>由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。</li><li>随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。</li></ul><p>为了解决上面这样的问题，本文将介绍RESTful API的重磅好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。具体效果如下图所示：</p><p><img src="http://blog.didispace.com/content/images/2016/04/swagger2_1.png"></p><p><img src="http://blog.didispace.com/content/images/2016/04/swagger2_1.png"></p><p>下面来具体介绍，如果在Spring Boot中使用Swagger2。首先，我们需要一个Spring Boot实现的RESTful API工程，若您没有做过这类内容，建议先阅读<br><a href="http://blog.didispace.com/springbootrestfulapi/">Spring Boot构建一个较为复杂的RESTful APIs和单元测试</a>。</p><p>下面的内容我们会以<a href="http://git.oschina.net/didispace/SpringBoot-Learning">教程样例</a>中的Chapter3-1-1进行下面的实验（Chpater3-1-5是我们的结果工程，亦可参考）。</p><h4 id="添加Swagger2依赖"><a href="#添加Swagger2依赖" class="headerlink" title="添加Swagger2依赖"></a>添加Swagger2依赖</h4><p>在<code>pom.xml</code>中加入Swagger2的依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="创建Swagger2配置类"><a href="#创建Swagger2配置类" class="headerlink" title="创建Swagger2配置类"></a>创建Swagger2配置类</h4><p>在<code>Application.java</code>同级创建Swagger2的配置类<code>Swagger2</code>。</p><pre><code class="java">@Configuration@EnableSwagger2public class Swagger2 &#123;    @Bean    public Docket createRestApi() &#123;        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.didispace.web&quot;))                .paths(PathSelectors.any())                .build();    &#125;    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()                .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)                .description(&quot;更多Spring Boot相关文章请关注：http://blog.didispace.com/&quot;)                .termsOfServiceUrl(&quot;http://blog.didispace.com/&quot;)                .contact(&quot;程序猿DD&quot;)                .version(&quot;1.0&quot;)                .build();    &#125;&#125;</code></pre><p>如上代码所示，通过<code>@Configuration</code>注解，让Spring来加载该类配置。再通过<code>@EnableSwagger2</code>注解来启用Swagger2。</p><p>再通过<code>createRestApi</code>函数创建<code>Docket</code>的Bean之后，<code>apiInfo()</code>用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。<code>select()</code>函数返回一个<code>ApiSelectorBuilder</code>实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被<code>@ApiIgnore</code>指定的请求）。</p><h4 id="添加文档内容"><a href="#添加文档内容" class="headerlink" title="添加文档内容"></a>添加文档内容</h4><p>在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过<code>@ApiOperation</code>注解来给API增加说明、通过<code>@ApiImplicitParams</code>、<code>@ApiImplicitParam</code>注解来给参数增加说明。</p><pre><code class="java">@RestController@RequestMapping(value=&quot;/users&quot;)     // 通过这里配置使下面的映射都在/users下，可去除public class UserController &#123;    static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;());    @ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;&quot;)    @RequestMapping(value=&#123;&quot;&quot;&#125;, method=RequestMethod.GET)    public List&lt;User&gt; getUserList() &#123;        List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values());        return r;    &#125;    @ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)    @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)    @RequestMapping(value=&quot;&quot;, method=RequestMethod.POST)    public String postUser(@RequestBody User user) &#123;        users.put(user.getId(), user);        return &quot;success&quot;;    &#125;    @ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;)    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;)    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.GET)    public User getUser(@PathVariable Long id) &#123;        return users.get(id);    &#125;    @ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)    @ApiImplicitParams(&#123;            @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;),            @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)    &#125;)    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.PUT)    public String putUser(@PathVariable Long id, @RequestBody User user) &#123;        User u = users.get(id);        u.setName(user.getName());        u.setAge(user.getAge());        users.put(id, u);        return &quot;success&quot;;    &#125;    @ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除对象&quot;)    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;)    @RequestMapping(value=&quot;/&#123;id&#125;&quot;, method=RequestMethod.DELETE)    public String deleteUser(@PathVariable Long id) &#123;        users.remove(id);        return &quot;success&quot;;    &#125;&#125;</code></pre><p>完成上述代码添加上，启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a><br>。就能看到前文所展示的RESTful API的页面。我们可以再点开具体的API请求，以POST类型的&#x2F;users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示。</p><p><img src="http://blog.didispace.com/content/images/2016/04/swagger2_2.png" alt="alt"><img src="http://blog.didispace.com/content/images/2016/04/swagger2_2.png"></p><h4 id="API文档访问与调试"><a href="#API文档访问与调试" class="headerlink" title="API文档访问与调试"></a>API文档访问与调试</h4><p>在上图请求的页面中，我们看到user的Value是个输入框？是的，Swagger除了查看接口功能外，还提供了调试测试功能，我们可以点击上图中右侧的Model Schema（黄色区域：它指明了User的数据结构），此时Value中就有了user对象的模板，我们只需要稍适修改，点击下方<code>“Try it out！”</code>按钮，即可完成了一次请求调用！</p><p>此时，你也可以通过几个GET请求来验证之前的POST请求是否正确。</p><p>相比为这些接口编写文档的工作，我们增加的配置内容是非常少而且精简的，对于原有代码的侵入也在忍受范围之内。因此，在构建RESTful API的同时，加入swagger来对API文档进行管理，是个不错的选择。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>本文的相关例子可以查看下面仓库中的<code>chapter3-1-5</code>目录：</p><ul><li>Github：<a href="https://github.com/dyc87112/SpringBoot-Learning/tree/1.x">https://github.com/dyc87112/SpringBoot-Learning</a></li><li>Gitee：<a href="https://gitee.com/didispace/SpringBoot-Learning/tree/1.x">https://gitee.com/didispace/SpringBoot-Learning</a></li></ul><p><strong>如果您觉得本文不错，欢迎Star支持，您的关注是我坚持的动力！</strong></p><h4 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h4><ul><li><a href="http://swagger.io/">Swagger官方网站</a></li></ul><p>无作者本人授权请勿转载。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
            <tag> 接口文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次Tomcat 8005端口Cannot assign requested address的经历</title>
      <link href="/2019/04/24/270d63d75e4d/"/>
      <url>/2019/04/24/270d63d75e4d/</url>
      
        <content type="html"><![CDATA[<p>记一次Tomcat 8005端口Cannot assign requested address : Jvm Bind的经历</p><span id="more"></span><p>一个正在做毕设的老乡遇到的问题：Tomcat启动的时候，报了[8005] Jvm Bind相关的异常，大概内容是端口已被占用的意思。</p><p>一. 先从运行&#x2F;bin&#x2F;shutdown.bat，再次关闭Tomcat，重新启动问题依然存在；</p><p>二. netstat -ano查看端口使用情况，未发现8080,8009,8005相关的端口被占用；</p><p>三. 打开任务管理器，确认javaw.exe未在运行，问题依然存在；</p><p>四. 重启机器，问题依然存在；</p><p>五. 参照：[<a href="https://www.cnblogs.com/heshan664754022/p/3807672.html">Tomcat启动报错:严重: StandardServer.await: create[8005] java.net.BindException: Cannot assign requested address](https://www.cnblogs.com/heshan664754022/p/3807672.html)</a> ， ping了localhost，发现收到的响应来自ipp[47.89.54.215]，打开C:&#x2F;windows&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts，发现以下内容：</p><pre><code>47.89.54.215       localhost47.89.54.215hao.360.cn47.89.54.215www.hao123.com47.89.54.215www.3600.com47.89.54.215www.114la.com47.89.54.215www.duba.com47.89.54.215www.hao360.cn47.89.54.215123.sogou.com47.89.54.215web.sogou.com47.89.54.215www.hao123.cn47.89.54.215hao.qq.com47.89.54.215www.1616.net47.89.54.215hao.rising.cn47.89.54.215daohang.qq.com</code></pre><p>看到daohang.qq，hao123，duba，hao360，123.sougou之类的字眼，国内流氓软件那么多？”的问题又浮现在脑海。</p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> 端口占用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA Terminal闪退</title>
      <link href="/2019/04/09/742f0f81c190/"/>
      <url>/2019/04/09/742f0f81c190/</url>
      
        <content type="html"><![CDATA[<p>IDEA Terminal 闪退，可以试下下面的方法：</p><ol><li><p>查看help &gt; Show Log in File，查看日志；</p></li><li><p>查看File &gt; Settings &gt; Terminal &gt; shell path，&#x3D;&gt; &#x2F;bin&#x2F;bash，重启终端。</p></li></ol><p> <a href="https://youtrack.jetbrains.com/issue/IDEA-202821">Black Terminal or Terminal doesnot work</a> </p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> terminal闪退 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git配置代理</title>
      <link href="/2019/04/06/28424001055f/"/>
      <url>/2019/04/06/28424001055f/</url>
      
        <content type="html"><![CDATA[<p>给sublime安装插件的时候又碰到git clone速度过慢的问题，记录一哈！</p><span id="more"></span><ol><li><p>打开ss全局代理；</p></li><li><p>到 <a href="https://www.ipaddress.com/">IPAddress.com</a> 根据 github.global.ssl.fastly.net 获取github服务器地址；</p></li><li><p>在 &#x2F;etc&#x2F;hosts 或者C:&#x2F;windows&#x2F;system32&#x2F;driver&#x2F;etc&#x2F;hosts 文件中添加对应的记录：</p><p>ip github.global.ssl.fastly.net</p></li><li><p>设置git代理：</p></li></ol><pre><code class="shell">   # http和https协议代理：   git config --global http.proxy http://127.0.0.1:1080   git config --global https.proxy http://127.0.0.1:1080      # sock5的情况   git config --global http.proxy socks5://127.0.0.1:1080   git config --global https.proxy socks5://127.0.0.1:1080      # 取消代理   git config --global unset http.proxy   git config --global unset https.proxy      # ssh协议代理：在用户目录下建立如下文件 ~/.ssh/config，对 GitHub 的域名做单独的处理   # 这里必须是 github.com，因为这个跟我们 clone 代码时的链接有关   Host github.com      # 如果用默认端口，这里是 github.com，如果想用443端口，这里就是 ssh.github.com 详见 https://help.github.com/articles/using-ssh-over-the-https-port/      HostName github.com      User git      # 如果是 HTTP 代理，把下面这行取消注释，并把 proxyport 改成自己的 http 代理的端口        ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=6667      # 如果是 socks5 代理，则把下面这行取消注释，并把 6666 改成自己 socks5 代理的端口        ProxyCommand nc -v -x 127.0.0.1:6666 %h %p</code></pre><p>&#x3D;&#x3D;&gt;&gt; <a href="https://imciel.com/2016/06/28/git-proxy/">设置 git 代理</a> </p><p>在Ubuntu下需要在网络设置里打开网络代理设置代理主机：socks5:&#x2F;&#x2F;127.0.0.1:1080</p>]]></content>
      
      
      <categories>
          
          <category> 工具软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在新机器中恢复Hexo博客</title>
      <link href="/2019/03/03/385663560223/"/>
      <url>/2019/03/03/385663560223/</url>
      
        <content type="html"><![CDATA[<h2 id="在新机器上恢复Hexo博客"><a href="#在新机器上恢复Hexo博客" class="headerlink" title="在新机器上恢复Hexo博客"></a>在新机器上恢复Hexo博客</h2><h3 id="准备源文件"><a href="#准备源文件" class="headerlink" title="准备源文件"></a>准备源文件</h3><p>可以备份到github或者coding，或者使用云盘同步（例如坚果云）。</p><span id="more"></span><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><pre><code class="shell">##安装npmsudo apt install npm##安装hexosudo apt install -g hexo-cli##克隆源文件git clone user@github.com/repo/##在仓库中添加SSH key##安装部署插件npm install hexo-deployer-git --save##RSS订阅插件npm install hexo-generator-feed --save##站点地图插件npm install hexo-generator-sitemap --save##安装本地服务器npm install hexo-server --save##生成index.html插件$ npm install hexo-generator-archive --save##搜索功能插件npm install hexo-generator-searchdb --save</code></pre><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><pre><code class="shell">hexo clean##预览hexo shexo g -d</code></pre><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p>遇到一个问题：生成后访问 <a href="http://localhost:4000/">http://localhost:4000</a> 出现白版和”Cannot GET &#x2F;“，”&#x2F;“是因为在public 目录下少了index.html文件，再次生成还是无效后，确认是少了组件：</p><pre><code class="shell">npm install hexo-generator-index</code></pre><p>参见：<a href="https://www.jianshu.com/p/af83fc73e525">【完美解决】Hexo博客出现“Cannot GET&#x2F;xxx”错误</a></p><p>吐槽一下coding和腾讯云之间的账号互通问题，一阵瞎引导，竟然创建了一个新账号，以前的项目找不回来，两个网站之间来回绕了几遍，无意间又用邮箱登录上去了，之前都是能自动跳转登录的，现在还和CSDN一样开始恰烂钱，强制绑定微信和手机号，无语。</p>]]></content>
      
      
      <categories>
          
          <category> 博客维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客恢复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想——第十四章——类型信息</title>
      <link href="/2019/02/01/c61bac95725c/"/>
      <url>/2019/02/01/c61bac95725c/</url>
      
        <content type="html"><![CDATA[<h1 id="第十四章-类型信息"><a href="#第十四章-类型信息" class="headerlink" title="第十四章 类型信息"></a>第十四章 类型信息</h1><hr><blockquote><p>运行时类型信息可以使得你可以在程序运行时发现和使用类型信息。</p></blockquote><p>本章主要讨论Java如何让我们在运行时识别对象和类的信息，主要有两种方式：</p><ol><li>“传统的RTTI”，假定我们在编译时已经知道了所有的类型；</li><li>“反射机制”，允许在运行时发现和使用类的信息。</li></ol><span id="more"></span><h2 id="14-1-为什么需要RTTI-Run-Time-Type-Identification"><a href="#14-1-为什么需要RTTI-Run-Time-Type-Identification" class="headerlink" title="14.1 为什么需要RTTI(Run-Time Type Identification)"></a>14.1 为什么需要RTTI(Run-Time Type Identification)</h2><p>RTTI提供类型维护的信息，为多态机制提供实现基础。多态的实现主要是通过向上转型，通过泛化父类来引用子类对象。</p><pre><code class="java">package com.typeinfo;import java.util.Arrays;import java.util.List;/** * @author zhulongkun20@163.com * @since 2018-06-06 14:52 */public class Shapes &#123;    public static void main(String[] args) &#123;        List&lt;Shape&gt; shapeList = Arrays.asList(new Circle(), new Square(), new Triangle());        shapeList.forEach(Shape::draw);    &#125;&#125;abstract class Shape &#123;    void draw() &#123;        System.out.println(this + &quot;.draw.&quot;);    &#125;    public abstract String toString();&#125;class Circle extends Shape &#123;    @Override    public String toString() &#123;        return &quot;Circle&quot;;    &#125;&#125;class Triangle extends Shape &#123;    @Override    public String toString() &#123;        return &quot;Triangle&quot;;    &#125;&#125;class Square extends Shape &#123;    @Override    public String toString() &#123;        return &quot;Square&quot;;    &#125;&#125;</code></pre><p>output:</p><pre><code class="java">Circle.draw.Square.draw.Triangle.draw.Process finished with exit code 0</code></pre><h2 id="14-2-Class对象"><a href="#14-2-Class对象" class="headerlink" title="14.2 Class对象"></a>14.2 Class对象</h2><p>RTTI的功能主要是由Class类实现的，每个类都是Class类的一个对象。所有的类都是在第一次使用时被”类加载器”动态的加载到JVM中的，当程序创建第一个类的成员引用时，便会加载这个类，这说明构造器是类的静态方法。使用new创建的类的新对象也会被当作类的静态成员，因此Java是动态加载的。首先检查类的Class对象是否加载，如果尚未加载，默认的类的加载器会查找同名的.class文件,一旦某个类的Class对象被载入内存，便会用来创建这个类的所有对象。</p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 17:07 */public class SweetShop &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;inside main.&quot;);        new Candy();        System.out.println(&quot;after create candy&quot;);        new Candy();        System.out.println(&quot;after create candy2&quot;);        try&#123;            Class.forName(&quot;com.typeinfo.Gum&quot;);        &#125;catch (ClassNotFoundException e) &#123;            System.out.println(&quot;Class Gum not found.&quot;);        &#125;        System.out.println(&quot;after create after gum.&quot;);        new Cookie();        System.out.println(&quot;after create cookie&quot;);    &#125;&#125;class Candy &#123;    static &#123;        System.out.println(&quot;Loading candy.&quot;);    &#125;&#125;class Gum &#123;    static &#123;        System.out.println(&quot;Loading gum.&quot;);    &#125;&#125;class Cookie &#123;    static &#123;        System.out.println(&quot;Loading cookie.&quot;);    &#125;&#125;</code></pre><p>output:</p><pre><code class="java">inside main.Loading candy.after create candyafter create candy2Loading gum.after create after gum.Loading cookie.after create cookieProcess finished with exit code 0</code></pre><p>从输出中可以看出，Java中的类都是在需要时才被加载的。forName()是Class类的一个静态成员，调用该方法可以返回相应类的实例。<br>无论何时，若要使用类型信息，必须持有Class对象的引用，Class.forName()是实现此功能的便捷方式，因为不需要再为了获取Class引用而持有该类型的引用。如果已经拥有一个类型的对象，可以使用getClass()来获取Class引用，返回表示该对象的实际类型的Class引用。</p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 18:22 */public class ToyTest &#123;    private static void printInfo(Class cc) &#123;        System.out.println(&quot;Class name: &quot; + cc.getName() + &quot; is interface? [&quot; + cc.isInterface() + &quot;]&quot;);        System.out.println(&quot;Simple name: &quot; + cc.getSimpleName());        System.out.println(&quot;Canonical name: &quot; + cc.getCanonicalName());        System.out.println(&quot;---------------&quot;);    &#125;    public static void main(String[] args) &#123;        Class c = null;        try &#123;            c = Class.forName(&quot;com.typeinfo.FancyToy&quot;);        &#125; catch (ClassNotFoundException e) &#123;            System.out.println(&quot;class not found.&quot;);        &#125;        assert c != null;        printInfo(c);        for (Class face : c.getInterfaces()) &#123;            printInfo(face);        &#125;        Class up = c.getSuperclass();        Object object = null;        try &#123;            object = up.newInstance();        &#125; catch (InstantiationException e) &#123;            System.out.println(&quot;获取实例失败.&quot;);        &#125; catch (IllegalAccessException e) &#123;            System.out.println(&quot;无法访问.&quot;);        &#125;        assert object != null;        printInfo(object.getClass());    &#125;&#125;interface HasBatteries &#123;&#125;interface WaterProof &#123;&#125;interface Shoots &#123;&#125;class Toy &#123;    Toy() &#123;    &#125;    Toy(int i) &#123;    &#125;&#125;class FancyToy extends Toy implements HasBatteries, WaterProof, Shoots &#123;    FancyToy() &#123;        super(1);    &#125;&#125;</code></pre><h2 id="output-javaClass-name-com-typeinfo-FancyToy-is-interface-false-Simple-name-FancyToyCanonical-name-com-typeinfo-FancyToy"><a href="#output-javaClass-name-com-typeinfo-FancyToy-is-interface-false-Simple-name-FancyToyCanonical-name-com-typeinfo-FancyToy" class="headerlink" title="output:&#96;&#96;&#96;javaClass name: com.typeinfo.FancyToy is interface? [false]Simple name: FancyToyCanonical name: com.typeinfo.FancyToy"></a>output:<br>&#96;&#96;&#96;java<br>Class name: com.typeinfo.FancyToy is interface? [false]<br>Simple name: FancyToy<br>Canonical name: com.typeinfo.FancyToy</h2><h2 id="Class-name-com-typeinfo-HasBatteries-is-interface-true-Simple-name-HasBatteriesCanonical-name-com-typeinfo-HasBatteries"><a href="#Class-name-com-typeinfo-HasBatteries-is-interface-true-Simple-name-HasBatteriesCanonical-name-com-typeinfo-HasBatteries" class="headerlink" title="Class name: com.typeinfo.HasBatteries is interface? [true]Simple name: HasBatteriesCanonical name: com.typeinfo.HasBatteries"></a>Class name: com.typeinfo.HasBatteries is interface? [true]<br>Simple name: HasBatteries<br>Canonical name: com.typeinfo.HasBatteries</h2><h2 id="Class-name-com-typeinfo-WaterProof-is-interface-true-Simple-name-WaterProofCanonical-name-com-typeinfo-WaterProof"><a href="#Class-name-com-typeinfo-WaterProof-is-interface-true-Simple-name-WaterProofCanonical-name-com-typeinfo-WaterProof" class="headerlink" title="Class name: com.typeinfo.WaterProof is interface? [true]Simple name: WaterProofCanonical name: com.typeinfo.WaterProof"></a>Class name: com.typeinfo.WaterProof is interface? [true]<br>Simple name: WaterProof<br>Canonical name: com.typeinfo.WaterProof</h2><h2 id="Class-name-com-typeinfo-Shoots-is-interface-true-Simple-name-ShootsCanonical-name-com-typeinfo-Shoots"><a href="#Class-name-com-typeinfo-Shoots-is-interface-true-Simple-name-ShootsCanonical-name-com-typeinfo-Shoots" class="headerlink" title="Class name: com.typeinfo.Shoots is interface? [true]Simple name: ShootsCanonical name: com.typeinfo.Shoots"></a>Class name: com.typeinfo.Shoots is interface? [true]<br>Simple name: Shoots<br>Canonical name: com.typeinfo.Shoots</h2><h2 id="Class-name-com-typeinfo-Toy-is-interface-false-Simple-name-ToyCanonical-name-com-typeinfo-Toy"><a href="#Class-name-com-typeinfo-Toy-is-interface-false-Simple-name-ToyCanonical-name-com-typeinfo-Toy" class="headerlink" title="Class name: com.typeinfo.Toy is interface? [false]Simple name: ToyCanonical name: com.typeinfo.Toy"></a>Class name: com.typeinfo.Toy is interface? [false]<br>Simple name: Toy<br>Canonical name: com.typeinfo.Toy</h2><p>Process finished with exit code 0</p><pre><code>在给forName()方法传递类名是必须使用全限定名。Class类常用方法列表：| 方法               | 描述                               || ------------------ | ---------------------------------- || getName()          | 获取全限定类名                     || getSimpleName()    | 获取不含包类名                     || getCanonicalName() | 含包名的全限定名                   || getInterfaces()    | Class对象所包含的接口              || isInterface()      | 判断Class对象是否是接口            || newInstance()      | 虚拟构造器(该类必须含有默认构造器) || getSuperClass()    | 间接获取Class对象基类              |### 14.2.1 类字面常量Java还提供了另一种方法来生成Class对象的引用，即使用类字面常量，例如```javaFancyToy.class;</code></pre><p>这样做更加简单、安全，因为它在编译器就会受到检查，因此不需要异常检查，同时根除了对forNam()方法的调用，因此更加高效。<br>类字面常量方法不仅适用于普通的类，也适用于接口，基本数据类型，数组。对于基本包装类型的Class对象。还有一个标准字段TYPE，TYPE字段是一个引用，指向对应的基本类型Class对象。<br><strong>建议使用.class方法，与普通类保持一致</strong></p><table><thead><tr><th>字面常量</th><th>标准TYPE字段</th></tr></thead><tbody><tr><td>boolean.class</td><td>Boolean.class</td></tr><tr><td>char.class</td><td>Char.class</td></tr><tr><td>byte.class</td><td>Byte.class</td></tr><tr><td>short.class</td><td>Short.class</td></tr><tr><td>int.class</td><td>Integer.class</td></tr><tr><td>long.class</td><td>Long.class</td></tr><tr><td>float.class</td><td>Flocat.class</td></tr><tr><td>double.class</td><td>Double.class</td></tr><tr><td>void.class</td><td>Void.class</td></tr></tbody></table><p>当使用.class来创建Class对象引用时，不会自动初始化该Class对象，包含三个过程的准备：</p><ol><li><strong>加载</strong>：由类加载器执行，查找字节码，为字节码创建Class对象；</li><li><strong>链接</strong>：验证类中的字节码，为静态域分配空间，如果必须的话，将解析这个类创建的对其他类的所有引用；</li><li><strong>初始化</strong>：如果该类具有超类，则对其进行初始化，执行静态初始化和静态初始化块。初始化被延迟到对静态方法或者非静态数据域进行首次引用时执行。</li></ol><pre><code class="java">package com.typeinfo;import java.util.Random;/** * @author zhulongkun20@163.com * @since 2018-06-07 19:07 */public class ClassInitailization &#123;    public static Random random = new Random(47);    public static void main(String[] args) throws ClassNotFoundException &#123;        Class initable = Initable.class;        System.out.println(&quot;after create initable ref.&quot;);        System.out.println(Initable.staticFinal);        System.out.println(Initable.staticFinal2);        System.out.println(Initable2.staticNonFinal);        Class initable3 = Class.forName(&quot;com.typeinfo.Initable3&quot;);        System.out.println(&quot;after create initable3.&quot;);        System.out.println(Initable3.staticNonFinal);    &#125;&#125;class Initable &#123;    static final int staticFinal = 47;    static final int staticFinal2 = ClassInitailization.random.nextInt(1000);    static &#123;        System.out.println(&quot;Initializing initable.&quot;);    &#125;&#125;class Initable2 &#123;    static int staticNonFinal = 147;    static &#123;        System.out.println(&quot;initializing initable2.&quot;);    &#125;&#125;class Initable3 &#123;    static int staticNonFinal = 74;    static &#123;        System.out.println(&quot;initializing initable3.&quot;);    &#125;&#125;</code></pre><p>output:</p><pre><code class="java">after create initable ref.47Initializing initable.258initializing initable2.147initializing initable3.after create initable3.74Process finished with exit code 0</code></pre><p>初始化有效的体现了”惰性”，从Initable的引用创建中知道<strong>使用.class创建Class引用不会引发初始化</strong>，但是为了产生引用，<strong>Class.forName()立即进行了初始化</strong>。<br><strong>如果一个static final值是编译期常量，那么这个值不需要对类进行初始化就可以进行读取。但是将一个域设置为static final不足以确保这种行为</strong>，如Initable.staticFinal2的访问强制类进行了初始化。<br>如果一个常量是static但不是final的，那么在对它进行访问时，总是要求在对它进行读取前，先进行链接(分配存储空间)和初始化(初始化该域磁盘)。</p><h3 id="14-2-2-泛化的Class引用"><a href="#14-2-2-泛化的Class引用" class="headerlink" title="14.2.2 泛化的Class引用"></a>14.2.2 泛化的Class引用</h3><p>Class引用所表示的就是它所指向的类的确切类型，可以制造类的实例，包含类的静态成员和方法代码。<br>在Java SE5中Class引用的类型变得更加具体，这是通过允许你Class引用所指向的Class对象引用类型进行限定实现的。</p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 19:36 */public class GenericClassReference &#123;    public static void main(String[] args) &#123;        Class intClass = int.class;        Class&lt;Integer&gt; genericIntClass = int.class;        genericIntClass = Integer.class;        intClass = double.class;        //genericIntClass = double.class;  //编译错误    &#125;&#125;</code></pre><p><strong>普通的类引用不会产生警告，尽管泛型类引用只能指向其声明的类型，但是普通的类引用可以被重新赋值为其他任何类型的引用，因此通过使用泛型，可以强制编译器进行类型检查。</strong></p><p>如果希望稍微放宽这种限制，如：</p><pre><code class="java">Class&lt;Number&gt; c = int.class;</code></pre><p>上述代码产生了编译错误，因为Integer Class对象不是Number Class的子类。<br>为了能够在使用泛化的Class引用时放宽限制，可以使用泛型通配符。</p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 19:46 */public class WildcardClassReference &#123;    public static void main(String[] args) &#123;        Class&lt;? extends Number&gt; c = int.class;        c = double.class;    &#125;&#125;</code></pre><p>上述代码没有产生任何警告信息。Class<?>优于普通的Class，并且两者等价。**Class<?>的好处是它表示你并非碰巧或者处于疏忽而使用了一个非具体的类型。**为了创建一个Class引用，它被限定为某种类型，和extends结合，可以创建一个范围。<br><strong>使用泛型可以促使编译器在编译器提供类型检查。</strong></p><p>将泛型用于Class对象，newInstance()方法返回的将是具体的类型而不是Object。但是这种具体类型有些许限制，由具体类型的Class引用getSuperClass()返回的类型是Object类型。</p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 20:04 */public class GenericToyTest &#123;    public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123;        Class&lt;FancyToy&gt; fancyToyClass = FancyToy.class;        FancyToy fancyToy = fancyToyClass.newInstance();        Class&lt;? super FancyToy&gt; c = fancyToyClass.getSuperclass();//        Class&lt;Toy&gt; toyClass = fancyToyClass.getSuperclass();   编译错误        Object object = fancyToyClass.getSuperclass();    &#125;&#125;</code></pre><h3 id="14-2-3-新的转型语法"><a href="#14-2-3-新的转型语法" class="headerlink" title="14.2.3 新的转型语法"></a>14.2.3 新的转型语法</h3><p>Java SE5还添加了用于Class引用转型的语法，即cast()方法。cast()方法接收参数对象，并将其转型为Class引用的类型。<br>在Java SE5中另一个最没用的新特性就是Class.asSubclass，该方法允许你将一个类对象转为更加具体的对象类型。</p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 20:12 */public class ClassCasts &#123;    Building building = new House();    Class&lt;House&gt; houseClass = House.class;    House house = houseClass.cast(building);&#125;class Building&#123;&#125;class House extends Building &#123;&#125;</code></pre><h2 id="14-3-类型转换前先做检查"><a href="#14-3-类型转换前先做检查" class="headerlink" title="14.3 类型转换前先做检查"></a>14.3 类型转换前先做检查</h2><p>迄今为止，RTTI的形式包括：</p><ol><li>传统的类型转换；</li><li>代表对象的类型的Class对象；</li><li>关键字instanceof：判断一个对象是不是某个特定类型的实例。</li></ol><pre><code class="java">if(x instaceof Dog) &#123;    (Dog)x.bark();&#125;</code></pre><p>instanceof有比较严格的限制，只可将其与命名类型比较，而不能与Class对象比较。</p><h2 id="14-5-instanceof和Class的等价性"><a href="#14-5-instanceof和Class的等价性" class="headerlink" title="14.5 instanceof和Class的等价性"></a>14.5 instanceof和Class的等价性</h2><p>instanceof()和isInstance()方法生成的结果完全一样，equals和&#x3D;&#x3D;也完全一样。但是<strong>instanceof保持了类型的概念，而&#x3D;&#x3D;比较的是实际的Class对象，没有考虑继承。</strong></p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 20:51 */public class FamilyVsExactType &#123;    static void test(Object object) &#123;        System.out.println(&quot;Testing object of type :&quot; + object.getClass());        System.out.println(&quot;object instanceof Base: &quot; + (object instanceof Base));        System.out.println(&quot;object instanceof Derived :&quot; + (object instanceof Derived));        System.out.println(&quot;Base.isInstance(object): &quot; + Base.class.isInstance(object));        System.out.println(&quot;Derived.isInstance(object): &quot; + Derived.class.isInstance(object));        System.out.println(&quot;object.getClass() == Base.class(): &quot; + (object.getClass() == Base.class));        System.out.println(&quot;object.getClass() == Derived.class(): &quot; + (object.getClass() == Derived.class));        System.out.println(&quot;object.getClass().equals(Base.class()): &quot; + (object.getClass().equals(Base.class)));        System.out.println(&quot;object.getClass().equals(Derived.class()): &quot; + (object.getClass().equals(Derived.class)));    &#125;    public static void main(String[] args) &#123;        test(new Base());        test(new Derived());    &#125;&#125;class Base &#123;&#125;class Derived extends Base &#123;&#125;</code></pre><p>output:</p><pre><code class="java">Testing object of type :class com.typeinfo.Baseobject instanceof Base: trueobject instanceof Derived :falseBase.isInstance(object): trueDerived.isInstance(object): falseobject.getClass() == Base.class(): trueobject.getClass() == Derived.class(): falseobject.getClass().equals(Base.class()): trueobject.getClass().equals(Derived.class()): falseTesting object of type :class com.typeinfo.Derivedobject instanceof Base: trueobject instanceof Derived :trueBase.isInstance(object): trueDerived.isInstance(object): trueobject.getClass() == Base.class(): falseobject.getClass() == Derived.class(): trueobject.getClass().equals(Base.class()): falseobject.getClass().equals(Derived.class()): trueProcess finished with exit code 0</code></pre><h2 id="14-6-反射：运行时的类信息"><a href="#14-6-反射：运行时的类信息" class="headerlink" title="14.6 反射：运行时的类信息"></a>14.6 反射：运行时的类信息</h2><p>RTTI的限制：如果需要知道某个对象的确切类型，可以使用RTTI，但是有一个限制：这个类型在编译时必须是可知的。如果获取了持有一个不在程序空间内的对象的引用或者这个类在你的程序运行许久之后才出现，此时则无法使用RTTI。</p><p>为什么需要反射？</p><ol><li>解决RTTI的限制；</li><li>希望提供在跨网络的平台上创建和运行对象的能力，即*远程方法调用(RMI)*。</li></ol><p>Class类与Java.lang.Reflect类库对反射进行了支持，该类库包含Field、Method和Constructor等类。可以用invoke()调用与Method关联的方法，调用getField()、getMethods()和getConstructor()等方法返回表示字段、方法和构造方法的数组。</p><p><strong>RTTI与反射之间真正的区别在于对于RTTI来说，编译器在编译时打开和检查.class文件，而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。</strong></p><h3 id="14-6-1-类方法提取器"><a href="#14-6-1-类方法提取器" class="headerlink" title="14.6.1 类方法提取器"></a>14.6.1 类方法提取器</h3><pre><code class="java">package com.typeinfo;import java.lang.reflect.Constructor;import java.lang.reflect.Method;/** * @author zhulongkun20@163.com * @since 2018-06-08 9:45 */public class ShowMethods &#123;    private static String usage = &quot;usage&quot;;    public static void main(String[] args) &#123;        if (args.length &lt; 1) &#123;            System.out.println(usage);            System.exit(0);        &#125;        try &#123;            Class&lt;?&gt; c = Class.forName(args[0]);            Method[] methods = c.getMethods();            Constructor[] constructors = c.getConstructors();            if (args.length == 1) &#123;                for (Method method : methods) &#123;                    System.out.println(method.toString());                &#125;                for (Constructor constructor : constructors) &#123;                    System.out.println(constructor.toString());                &#125;            &#125; else &#123;                for (Method method : methods) &#123;                    if (method.toString().contains(args[1])) &#123;                        System.out.println(method.toString());                    &#125;                &#125;                for (Constructor constructor : constructors) &#123;                    if (constructor.toString().contains(args[1])) &#123;                        System.out.println(constructor.toString());                    &#125;                &#125;            &#125;        &#125; catch (ClassNotFoundException e) &#123;            System.out.println(&quot;No such class.&quot;);        &#125;    &#125;&#125;</code></pre><p>output:</p><pre><code class="java">public boolean java.lang.String.equals(java.lang.Object)public java.lang.String java.lang.String.toString()public int java.lang.String.hashCode()public int java.lang.String.compareTo(java.lang.String)public int java.lang.String.compareTo(java.lang.Object)public int java.lang.String.indexOf(java.lang.String,int)public int java.lang.String.indexOf(java.lang.String)public int java.lang.String.indexOf(int,int)public int java.lang.String.indexOf(int)public static java.lang.String java.lang.String.valueOf(int)public static java.lang.String java.lang.String.valueOf(long)public static java.lang.String java.lang.String.valueOf(float)public static java.lang.String java.lang.String.valueOf(boolean)public static java.lang.String java.lang.String.valueOf(char[])public static java.lang.String java.lang.String.valueOf(char[],int,int)public static java.lang.String java.lang.String.valueOf(java.lang.Object)public static java.lang.String java.lang.String.valueOf(char)public static java.lang.String java.lang.String.valueOf(double)public char java.lang.String.charAt(int)public int java.lang.String.codePointAt(int)public int java.lang.String.codePointBefore(int)public int java.lang.String.codePointCount(int,int)public int java.lang.String.compareToIgnoreCase(java.lang.String)public java.lang.String java.lang.String.concat(java.lang.String)public boolean java.lang.String.contains(java.lang.CharSequence)public boolean java.lang.String.contentEquals(java.lang.CharSequence)public boolean java.lang.String.contentEquals(java.lang.StringBuffer)public static java.lang.String java.lang.String.copyValueOf(char[])public static java.lang.String java.lang.String.copyValueOf(char[],int,int)public boolean java.lang.String.endsWith(java.lang.String)public boolean java.lang.String.equalsIgnoreCase(java.lang.String)public static java.lang.String java.lang.String.format(java.util.Locale,java.lang.String,java.lang.Object[])public static java.lang.String java.lang.String.format(java.lang.String,java.lang.Object[])public void java.lang.String.getBytes(int,int,byte[],int)public byte[] java.lang.String.getBytes(java.nio.charset.Charset)public byte[] java.lang.String.getBytes(java.lang.String) throws java.io.UnsupportedEncodingExceptionpublic byte[] java.lang.String.getBytes()public void java.lang.String.getChars(int,int,char[],int)public native java.lang.String java.lang.String.intern()public boolean java.lang.String.isEmpty()public static java.lang.String java.lang.String.join(java.lang.CharSequence,java.lang.CharSequence[])public static java.lang.String java.lang.String.join(java.lang.CharSequence,java.lang.Iterable)public int java.lang.String.lastIndexOf(int)public int java.lang.String.lastIndexOf(java.lang.String)public int java.lang.String.lastIndexOf(java.lang.String,int)public int java.lang.String.lastIndexOf(int,int)public int java.lang.String.length()public boolean java.lang.String.matches(java.lang.String)public int java.lang.String.offsetByCodePoints(int,int)public boolean java.lang.String.regionMatches(int,java.lang.String,int,int)public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int)public java.lang.String java.lang.String.replace(char,char)public java.lang.String java.lang.String.replace(java.lang.CharSequence,java.lang.CharSequence)public java.lang.String java.lang.String.replaceAll(java.lang.String,java.lang.String)public java.lang.String java.lang.String.replaceFirst(java.lang.String,java.lang.String)public java.lang.String[] java.lang.String.split(java.lang.String)public java.lang.String[] java.lang.String.split(java.lang.String,int)public boolean java.lang.String.startsWith(java.lang.String,int)public boolean java.lang.String.startsWith(java.lang.String)public java.lang.CharSequence java.lang.String.subSequence(int,int)public java.lang.String java.lang.String.substring(int)public java.lang.String java.lang.String.substring(int,int)public char[] java.lang.String.toCharArray()public java.lang.String java.lang.String.toLowerCase(java.util.Locale)public java.lang.String java.lang.String.toLowerCase()public java.lang.String java.lang.String.toUpperCase()public java.lang.String java.lang.String.toUpperCase(java.util.Locale)public java.lang.String java.lang.String.trim()public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll()public default java.util.stream.IntStream java.lang.CharSequence.chars()public default java.util.stream.IntStream java.lang.CharSequence.codePoints()public java.lang.String(byte[],int,int)public java.lang.String(byte[],java.nio.charset.Charset)public java.lang.String(byte[],java.lang.String) throws java.io.UnsupportedEncodingExceptionpublic java.lang.String(byte[],int,int,java.nio.charset.Charset)public java.lang.String(byte[],int,int,java.lang.String) throws java.io.UnsupportedEncodingExceptionpublic java.lang.String(java.lang.StringBuilder)public java.lang.String(java.lang.StringBuffer)public java.lang.String(byte[])public java.lang.String(int[],int,int)public java.lang.String()public java.lang.String(char[])public java.lang.String(java.lang.String)public java.lang.String(char[],int,int)public java.lang.String(byte[],int)public java.lang.String(byte[],int,int,int)Process finished with exit code 0</code></pre><p>参数为java.lang.String，在idea中设置运行参数：Edit Configurations&gt;Configuration&gt;Program arguments，需要填写某个类的全限定名。</p><h2 id="14-7-动态代理"><a href="#14-7-动态代理" class="headerlink" title="14.7 动态代理"></a>14.7 动态代理</h2><p>代理是基本的设计模式之一，是用来代替实际对象的对象，通常涉及与实际对象的通信，充当中间人的角色。</p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-08 10:22 */public class SimpleProxyDemo &#123;    public static void consumer(Interface inter) &#123;        inter.doSomething();        inter.somethingElse(&quot;banana&quot;);    &#125;    public static void main(String[] args) &#123;        consumer(new RealObject());        consumer(new ProxyObject(new RealObject()));    &#125;&#125;interface Interface &#123;    void doSomething();    void somethingElse(String arg);&#125;class RealObject implements Interface &#123;    @Override    public void doSomething() &#123;        System.out.println(&quot;do something.&quot;);    &#125;    @Override    public void somethingElse(String arg) &#123;        System.out.println(&quot;do something else :&quot; + arg);    &#125;&#125;class ProxyObject implements Interface &#123;    private Interface proxied;    public ProxyObject(Interface proxied) &#123;        this.proxied = proxied;    &#125;    @Override    public void doSomething() &#123;        System.out.println(&quot;proxy object do something.&quot;);        proxied.doSomething();    &#125;    @Override    public void somethingElse(String arg) &#123;        System.out.println(&quot;proxy object do something else: &quot; + arg);        proxied.somethingElse(arg);    &#125;&#125;</code></pre><p>output:</p><pre><code class="java">do something.do something else :bananaproxy object do something.do something.proxy object do something else: bananado something else :bananaProcess finished with exit code 0</code></pre><p>当想要执行一些额外操作，同时想将这些操作从”实际”对象中分离出去时，或者想要更加容易的做出修改时代理是很有用的。</p><p>通过调用静态方法Proxy.newProxyInstance()可以创建动态代理对象，<br>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)<br>Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler.</p><pre><code class="java">package com.typeinfo;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @author zhulongkun20@163.com * @since 2018-06-08 10:35 */public class SimpleDynamicProxy &#123;    public static void consumer(Interface inter) &#123;        inter.doSomething();        inter.somethingElse(&quot;Banana&quot;);    &#125;    public static void main(String[] args) &#123;        RealObject realObject = new RealObject();        consumer(realObject);        Interface proxy = (Interface) Proxy.newProxyInstance(Interface.class.getClassLoader(),                new Class[]&#123;Interface.class&#125;, new DynamicProxyHandler(realObject));        consumer(proxy);    &#125;&#125;class DynamicProxyHandler implements InvocationHandler &#123;    private Object proxied;    public DynamicProxyHandler(Object proxied) &#123;        this.proxied = proxied;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;proxy: &quot; + proxy.getClass() + &quot; .method: &quot; + method + &quot; .args: &quot; + args);        if (args != null) &#123;            for (Object object : args) &#123;                System.out.println(object + &quot;   &quot;);            &#125;        &#125;        return method.invoke(proxied, args);    &#125;&#125;</code></pre><p>output:</p><pre><code class="java">do something.do something else :Bananaproxy: class com.typeinfo.$Proxy0 .method: public abstract void com.typeinfo.Interface.doSomething() .args: nulldo something.proxy: class com.typeinfo.$Proxy0 .method: public abstract void com.typeinfo.Interface.somethingElse(java.lang.String) .args: [Ljava.lang.Object;@12a3a380Banana   do something else :BananaProcess finished with exit code 0</code></pre><h2 id="14-8-空对象"><a href="#14-8-空对象" class="headerlink" title="14.8 空对象"></a>14.8 空对象</h2><p>当时用内置的null去表示空对象时，在每次使用这个对象的时候都需要先判断该对象是否为null，并且判断除了用来产生NullPointerException之外，没有任何帮助，还会产生大量冗余代码。我们希望有一个空对象，可以接收传传给它所代表的对象，但是将返回表示该对象不存在的任何真实对象的值。<br>最简单的是创建一个标记接口。</p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:02 */public class NullPerson extends Person implements Null &#123;    private NullPerson() &#123;        super(&quot;None&quot;, &quot;None&quot;, &quot;None&quot;);    &#125;    public String toString() &#123;        return &quot;NullPerson&quot;;    &#125;    public static final Person Null = new NullPerson();&#125;interface Null &#123;&#125;class Person &#123;    public final String first;    public final String last;    public final String address;    public Person(String first, String last, String address) &#123;        this.first = first;        this.last = last;        this.address = address;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;first=&#39;&quot; + first + &#39;\&#39;&#39; +                &quot;, last=&#39;&quot; + last + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h2 id="14-9-接口与类型信息"><a href="#14-9-接口与类型信息" class="headerlink" title="14.9 接口与类型信息"></a>14.9 接口与类型信息</h2><p>interface的一种重要目标就是允许隔离构件，进而降低耦合度，如果编写接口，那么可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去。</p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:13 */public class InterfaceViolation &#123;    public static void main(String[] args) &#123;        A a = new B();        a.f();        System.out.println(a.getClass().getCanonicalName());        if (a instanceof B) &#123;            B b = (B) a;            b.g();        &#125;    &#125;&#125;interface A &#123;    void f();&#125;class B implements A &#123;    @Override    public void f() &#123;    &#125;    public void g() &#123;    &#125;&#125;</code></pre><p>a被当作B实现，通过转型为B，可以调用A中不存在的方法。<br>一种解决方法是直接声明，使用实际的类而不是接口。最简单的方式是对实现使用包访问权限，这样在包外便无法访问。</p><pre><code class="java">package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:27 */public class HiddenC &#123;    public static A makeA() &#123;        return new C();    &#125;&#125;class C implements A &#123;    @Override    public void f() &#123;    &#125;    public void g() &#123;    &#125;    void u() &#123;    &#125;        protected void v() &#123;    &#125;        private void w() &#123;    &#125;&#125;</code></pre><p>即使从makeA()返回的是C类型，在包外依然无法使用A之外的任何方法。</p><pre><code class="java">package com.typeinfo;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:30 */public class HiddenImplementation &#123;    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException,            InvocationTargetException &#123;        A a = HiddenC.makeA();        a.f();        System.out.println(a.getClass().getCanonicalName());        if (a instanceof C) &#123;            C c = (C) a;            c.g();        &#125;        callHiddenMethod(a, &quot;g&quot;);        callHiddenMethod(a, &quot;v&quot;);        callHiddenMethod(a, &quot;u&quot;);        callHiddenMethod(a, &quot;w&quot;);    &#125;    static void callHiddenMethod(Object object, String methodName) throws NoSuchMethodException,            InvocationTargetException, IllegalAccessException &#123;        Method g = object.getClass().getDeclaredMethod(methodName);        g.setAccessible(true);        g.invoke(object);    &#125;&#125;</code></pre><p>output:</p><pre><code class="java">public f().com.typeinfo.Cpublic g().public g().protected v().package u().private w().Process finished with exit code 0</code></pre><p>通过反射，仍旧可以调用所有方法，甚至是private方法，如果知道方法名，可以在Method对象上调用setAccessible(true)。<br>甚至使用发布编译后的代码也无法阻止这种情况，因为在发布的jdk中有反编译器便可突破这一限制。<br>内部类与匿名类也无法阻止反射到达并调用非公共访问权限的方法。</p><pre><code class="java">package com.typeinfo;import java.lang.reflect.InvocationTargetException;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:46 */public class InnerImplementation &#123;    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123;        A a = InnerA.makeA();        a.f();        System.out.println(a.getClass().getName());        HiddenImplementation.callHiddenMethod(a, &quot;g&quot;);        HiddenImplementation.callHiddenMethod(a, &quot;u&quot;);        HiddenImplementation.callHiddenMethod(a, &quot;v&quot;);        HiddenImplementation.callHiddenMethod(a, &quot;w&quot;);    &#125;&#125;class InnerA &#123;    private static class C implements A &#123;        @Override        public void f() &#123;            System.out.println(&quot;C.f()&quot;);        &#125;        public void g() &#123;            System.out.println(&quot;C.g()&quot;);        &#125;        void u() &#123;            System.out.println(&quot;C.u()&quot;);        &#125;        protected void v() &#123;            System.out.println(&quot;C.v()&quot;);        &#125;        private void w() &#123;            System.out.println(&quot;C.w()&quot;);        &#125;    &#125;    public static A makeA()&#123;        return new C();    &#125;&#125;</code></pre><p>output:</p><pre><code class="java">C.f()com.typeinfo.InnerA$CC.g()C.u()C.v()C.w()Process finished with exit code 0</code></pre><pre><code class="java">package com.typeinfo;import java.lang.reflect.InvocationTargetException;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:51 */public class AnonymousImplementation &#123;    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException,            InvocationTargetException &#123;        A a = AnonymousA.makeA();        a.f();        System.out.println(a.getClass().getName());        HiddenImplementation.callHiddenMethod(a, &quot;g&quot;);        HiddenImplementation.callHiddenMethod(a, &quot;u&quot;);        HiddenImplementation.callHiddenMethod(a, &quot;v&quot;);        HiddenImplementation.callHiddenMethod(a, &quot;w&quot;);    &#125;&#125;class AnonymousA &#123;    public static A makeA() &#123;        return new A() &#123;            @Override            public void f() &#123;                System.out.println(&quot;public c.f()&quot;);            &#125;            public void g() &#123;                System.out.println(&quot;public c.g()&quot;);            &#125;            void u() &#123;                System.out.println(&quot;package u()&quot;);            &#125;            protected void v() &#123;                System.out.println(&quot;protected v()&quot;);            &#125;            private void w() &#123;                System.out.println(&quot;private w()&quot;);            &#125;        &#125;;    &#125;&#125;</code></pre><p>output:</p><pre><code class="java">public c.f()com.typeinfo.AnonymousA$1public c.g()package u()protected v()private w()Process finished with exit code 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
            <tag> Java类型信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更改DNS为8.8.8.8访问cn.bing.com</title>
      <link href="/2019/01/24/a7bf16cc5800/"/>
      <url>/2019/01/24/a7bf16cc5800/</url>
      
        <content type="html"><![CDATA[<p>昨天早上开始 <a href="https://cn.bing.com/">https://cn.bing.com</a> 就无法访问：</p><p>今天晚上想去 <a href="https://weibo.com/bingisfordoing">Bing搜索微博</a> 了解一下情况，ping了一下，DNS都是127.0.0.1，将DNS改为8.8.8.8还能正常访问。据说当年Google开始也是出现DNS污染，后来才离开大陆的，想想Bing也没有了，每天只能在百度看百家号那些劣质内容就觉得可怕。</p><span id="more"></span><p>从去年开始就没用百度搜索了，除了CSDN（虽然现在也被广告淹没了）还有点有用的东西。前两天搜点东西，发现不太对，好像所有的结果页面风格都差不多，过两天才看到域名，给我吓到了，前几页全是 <strong>baijiahao.baidu.com</strong> 的文章。给自己家产品引流无可厚非，但是做到这种程度还能算是一个搜索引擎吗？而且好多文章都是文不对题，可能都没有审核。最令人恶心的是竟然都没有评论功能，可能百度也觉得这些低质量内容开放评论会被喷得体无完肤吧。。。</p><p>那时候还没想到是百度搞的导流，还特意去查了各种百度谷歌高级搜索的资料学习了一下，折腾一番但是收效甚微。</p><p>想看看大家对百度搜索的看法，看到一篇很火的文章：<a href="https://www.huxiu.com/article/282406.html">百度搜索引擎已死</a> ， 文章举了几个例子，果然全是百家号的恶心内容。</p><p>没有竞争对手，才能为所欲为吧。</p><p>引用原文中得一句话：<strong>写到这里，很是悲哀：偌大的中文互联网竟已堕落到如此境地，连一个搜索引擎都没有了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> 必应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode之3Sum</title>
      <link href="/2019/01/03/8923673d5906/"/>
      <url>/2019/01/03/8923673d5906/</url>
      
        <content type="html"><![CDATA[<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>输入一个数组，例如{-1 0 1 2 -1 -4}，从数组中找三个数（a,b,c），使得其和0，输出所有的（a,b,c）组合。</p><p>要求abc不能重复，并且a&lt;&#x3D;b&lt;&#x3D;c。</p><p>例：</p><p>S &#x3D; {-1, 0, 1, 2, -1, -4}；</p><p>输出：</p><p>(-1, 0 ,1)</p><p>(-1, -1, 2)</p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一看到题目，不问代码行数，不问时间复杂度，便排出三个循环。。但是循环非常耗时，显然不是题目的本意。想了好长时间没有什么进展。</p><p>先将给定数组排序，然后指定一个数，在数组中找出两个数并且这两个数的和是目标数值的相反数：<a href="http://www.cnblogs.com/xcr1234/p/5285727.html">【LeetCode】3Sum 解题报告</a></p><p>在网上找到了篇比较有新意的文章：[<a href="https://www.cnblogs.com/xcr1234/p/5285727.html">3Sum algorithm - 非常容易理解的实现 （java)</a>] 。</p><hr><p>最后发现维基百科中就有收录：<a href="https://zh.wikipedia.org/zh-hans/3SUM">维基百科—3SUM</a> ，还有更一般的情形 N SUM。</p><pre><code class="pascal"> sort(S); for i=0 to n-3 do    a = S[i];    start = i+1;    end = n-1;    while (start &lt; end) do       b = S[start]       c = S[end];       if (a+b+c == 0) then          output a, b, c;          // Continue search for all triplet combinations summing to zero.           end = end - 1       else if (a+b+c &gt; 0) then          end = end - 1;       else          start = start + 1;       end    end end</code></pre><p>伪代码还挺容易理解的。</p><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p>因为知乎上有人宣称证明了哥德巴赫猜想的原因，这两天还特意了解了下猜想证明的历史，“1+2”、“1+3”之类的证明，虽然一点也没看懂。感觉数学真的很有魅力，严谨清晰的逻辑，精妙完美的结论，自然界中的一切每时每刻都在遵循着其中的规律运行，更加感慨于人类的智慧，都找不到合适的赞美的词了。</p><p>“超越数”、“黄金分割”、“哥德巴赫猜想”、“黎曼猜想”…</p><p>停下思绪，回到现实：<strong>当你理解它的时候你觉得进入了天堂，当你不理解它的时候你仿佛进入了地狱</strong>，看哭了…</p>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 3sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot基础学习笔记</title>
      <link href="/2019/01/01/110f3650bd4f/"/>
      <url>/2019/01/01/110f3650bd4f/</url>
      
        <content type="html"><![CDATA[<h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><ol><li>SpringBoot入门</li><li>SpringBoot配置</li><li>SpringBoot与日志</li><li>SpringBoot与Web开发</li><li>SpringBoot与Docker</li><li>SpringBoot与数据访问</li><li>SpringBoot启动配置原理</li><li>SpringBoot自定义Starters</li><li>SpringBoot与缓存</li><li>SpringBoot与消息</li><li>SpringBoot与检索</li><li>SpringBoot与任务</li><li>SpringBoot与安全</li><li>SpringBoot与分布式</li><li>SpringBoot与开发热部署</li><li>SpringBoot与监控管理</li></ol><h2 id="第一章-SpringBoot入门"><a href="#第一章-SpringBoot入门" class="headerlink" title="第一章 SpringBoot入门"></a>第一章 SpringBoot入门</h2><h3 id="1-1-SpringBoot简介"><a href="#1-1-SpringBoot简介" class="headerlink" title="1.1 SpringBoot简介"></a>1.1 SpringBoot简介</h3><p>特点：约定大于配置；去繁从简；</p><span id="more"></span><p>背景： </p><p>J2EE笨重的开发；</p><p>繁多的配置；</p><p>低下的效率；</p><p>复杂的部署；</p><p>第三方技术集成难度大；</p><p>解决方案：</p><p>SpringBoot：一站式J2EE的解决方案；</p><p>SpringCloud：分布式整体解决方案；</p><p>优点：</p><p>快速创建可独立运行的Spring项目并与主流框架集成；</p><p>starters自动依赖管理及版本控制；</p><p>使用嵌入的Servlet容器，应用无需打包；</p><p>大量的自动配置，简化开发，也可修改默认值；</p><p>无需配置XML，无代码生成，开箱即用；</p><p>准生产环境的运行时应用监控；</p><p>是对Spring技术栈的一个整合。</p><hr><h3 id="1-2-微服务"><a href="#1-2-微服务" class="headerlink" title="1.2 微服务"></a>1.2 微服务</h3><p>单体应用： 开发，测试，部署简单；</p><p>微服务：功能拆分，灵活配置，通信协作。</p><p>SpringBoot官网 &gt; 微服务文档</p><hr><h3 id="1-3-开发环境配置"><a href="#1-3-开发环境配置" class="headerlink" title="1.3 开发环境配置"></a>1.3 开发环境配置</h3><ol><li>JDK版本；</li><li>maven版本；</li><li>开发工具选择；</li><li>框架版本选择；</li></ol><hr><h3 id="1-4-第一个应用：HelloWorld"><a href="#1-4-第一个应用：HelloWorld" class="headerlink" title="1.4 第一个应用：HelloWorld"></a>1.4 第一个应用：HelloWorld</h3><ol><li>创建一个Maven项目；</li><li>导入SpringBoot相关依赖；</li><li>编写主程序，启动SpringBoot应用；</li></ol><pre><code class="java">@SpringBootApplicationpublic class MainApp &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MainApp.class, args);    &#125;&#125;</code></pre><ol><li>编写业务逻辑，服务；</li><li>运行主程序测试；</li><li>打包jar包：</li></ol><pre><code class="xml">&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>运行jar包：</p><pre><code class="shell">java -jar xxx.jar</code></pre><hr><h3 id="1-5-HelloWorld原理探究"><a href="#1-5-HelloWorld原理探究" class="headerlink" title="1.5 HelloWorld原理探究"></a>1.5 HelloWorld原理探究</h3><p>POM文件：</p><ol><li>父项目：</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;父项目：</code></pre><p>SpringBoot的<strong>版本仲裁中心</strong>，导入依赖不需要写版本号。</p><ol><li>导入的依赖：</li></ol><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>spring-boot-starter-web：</p><p>场景启动器：帮我们导入web模块正常运行所需的依赖的组件；</p><p>将所有的功能场景抽取出来，做成启动器，只需要在项目中导入相关的starter，所有的依赖都会被导入，版本由spring-boot自动管理。</p><hr><h3 id="1-6-主程序类原理探究"><a href="#1-6-主程序类原理探究" class="headerlink" title="1.6 主程序类原理探究"></a>1.6 主程序类原理探究</h3><pre><code class="java">package com.hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author zhulongkun20@163.com * @since 18-9-9 下午2:28 */@SpringBootApplicationpublic class MainApp &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MainApp.class, args);    &#125;&#125;</code></pre><p>@SpringBootApplication标注在某个类上，指定SpringBoot的主配置类，由这个类来启动SpringBoot应用。</p><pre><code class="java">@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(    excludeFilters = &#123;@Filter(    type = FilterType.CUSTOM,    classes = &#123;TypeExcludeFilter.class&#125;), @Filter(    type = FilterType.CUSTOM,    classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;</code></pre><p>@SpringBootConfiguration：标注在某个类上，表示该类是SpringBoot的配置类。</p><p>@Configuration：配置类上标注该类。配置类也是一个组件：@Component；</p><p>@EnableAutoConfiguration：开启自动配置，</p><pre><code>需要配置的东西由SpringBoot自动配置。</code></pre><pre><code class="xml">@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code></pre><pre><code>@AutoConfigurationPackage：自动配置包，给容器导入一个组件，导入的组件由AutoConfigurationPackage.Registrar；将主配置类所在的及以下所有的子包里的所有组件添加到Spring容器中。</code></pre><pre><code class="java">@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125;</code></pre><pre><code>@Import：给容器中导入一些组件：AutoConfigurationImportSelector：选择哪些组件导入。    给容器中导入自动配置类（xxxAutoConfiguration）：给容器中导入场景需要的所有的组件并配置好这些组件。</code></pre><p><img src="https://image.youyou-2608.com/springboot/20180909151509.png" alt="配置类"></p><pre><code class="java">    protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);        return configurations;    &#125;</code></pre><p><strong>SpringBoot启动的时候从类路径下META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值，将这些值导入到Spring容器中，自动配置类生效。</strong></p><p>需要自己指定的配置，已经由配置类自动配置好。</p><p>org&#x2F;springframework&#x2F;boot&#x2F;spring-boot-autoconfigure&#x2F;2.0.4.RELEASE&#x2F;spring-boot-autoconfigure-2.0.4.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factories</p><p><img src="https://image.youyou-2608.com/springboot/google-chrome_20180909152808.png" alt="自动配置类"></p><hr><h3 id="1-7-SpringBoot项目初始化器"><a href="#1-7-SpringBoot项目初始化器" class="headerlink" title="1.7 SpringBoot项目初始化器"></a>1.7 SpringBoot项目初始化器</h3><p>SpringBoot项目向导：</p><p><strong>IDEA &gt; New Project &gt; Spring Initializer &gt; 项目详情 &gt; 导入相关场景依赖。</strong></p><p>@RestController注解：</p><p>@ResponseBody和@RequestMapping注解组合。</p><ol><li>自动生成主程序；</li><li>&#x2F;resources中目录结构：<ol><li>static：保存静态资源；</li><li>templates：存所有的模板页面(使用嵌入的tomcat，不支持JSP页面，但是可以使用模板引擎)；</li><li>application.properties：SpringBoot的默认配置文件。</li></ol></li></ol><hr><h2 id="第二章-SpringBoot配置文件"><a href="#第二章-SpringBoot配置文件" class="headerlink" title="第二章 SpringBoot配置文件"></a>第二章 SpringBoot配置文件</h2><h3 id="2-1-SpringBoot配置文件"><a href="#2-1-SpringBoot配置文件" class="headerlink" title="2.1 SpringBoot配置文件"></a>2.1 SpringBoot配置文件</h3><p>SpringBoot使用全局配置文件，配置文件名是固定的。</p><ul><li>application.properties；</li><li>application.yml。</li></ul><p>配置文件的作用：<strong>修改SpringBoot默认配置。</strong></p><p>YAML：不仅仅是一个标记语言，以数据为中心，比json和xml更适合做配置文件。</p><p>YAML：</p><pre><code class="yaml">server:    port: 8081</code></pre><hr><h3 id="2-2-YAML基本语法"><a href="#2-2-YAML基本语法" class="headerlink" title="2.2 YAML基本语法"></a>2.2 YAML基本语法</h3><p>key: value    表示键值对，冒号之后的空格必须有的，以空格来控制层级关系。</p><pre><code class="yaml">server:     port: 8081    path: /hello</code></pre><p><strong>属性和值大小写敏感。</strong></p><p>字面量：字符串默认不加单引号和双引号，<strong>双引号会转义特殊字符</strong>，<strong>单引号会转义特殊字符</strong>。</p><pre><code class="yaml">k: v</code></pre><p>对象(属性和值)：本质是键值对。</p><pre><code class="yaml">student:    name: 张三    age: 14</code></pre><p>行内写法：</p><pre><code class="yaml">student: &#123;name: 张三,age: 15&#125;</code></pre><p>数组(List, Set)：</p><p>用-表示数组中的一个元素。</p><pre><code class="yaml">pets:    - cat    - dog    - pig</code></pre><p>行内写法：</p><pre><code class="yaml">pets: [cat,dog,pig]</code></pre><h4 id="2-2-1配置文件注入："><a href="#2-2-1配置文件注入：" class="headerlink" title="2.2.1配置文件注入："></a>2.2.1配置文件注入：</h4><p>application.yml文件：</p><pre><code class="yaml">server:  port: 8081person:  name: 张三  age: 18  alive: true  birth: 2018/09/11  classes:    - v1    - v2  map:    k1: v1    k2: v2  dog:    name: dog    age: 4</code></pre><p>JavaBean：</p><pre><code class="java">package com.demo.po;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;/** * @author zhulongkun20@163.com * @since 18-9-11 下午8:36 */@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Student &#123;    private String name;    private Integer age;    private boolean alive;    private Date birth;    private List&lt;String&gt; classes;    private Map&lt;String, Object&gt; map;    private Dog dog;    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, alive=&quot; + alive +                &quot;, birth=&quot; + birth +                &quot;, classes=&quot; + classes +                &quot;, map=&quot; + map +                &quot;, dog=&quot; + dog +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>可以导入配置文件处理器之后，编写配置文件有IDE智能提示。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>@ConfigurationProperties(prefix &#x3D; “person”)获取配置文件的值。</p><p><strong>application.properties乱码问题：file encoding勾选将properties配置文件转换成ascii码。</strong></p><p>配置文件的旧写法：</p><pre><code class="xml">&lt;bean class=&quot;person&quot;&gt;    &lt;property name=&quot;lastName&quot; value=&quot;zhagsa&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="2-2-2-Value注入值"><a href="#2-2-2-Value注入值" class="headerlink" title="2.2.2 @Value注入值"></a>2.2.2 @Value注入值</h4><pre><code class="java">public class Student &#123;    @Value(&quot;$&#123;person.name&#125;&quot;)    private String name;    @Value(&quot;#&#123;11*2&#125;&quot;)    private Integer age;    @Value(&quot;true&quot;)    private boolean alive;    private Date birth;    private List&lt;String&gt; classes;    private Map&lt;String, Object&gt; map;    private Dog dog;&#125;</code></pre><h4 id="2-2-3-Value和-ConfigurationProperties获取值比较："><a href="#2-2-3-Value和-ConfigurationProperties获取值比较：" class="headerlink" title="2.2.3 @Value和@ConfigurationProperties获取值比较："></a>2.2.3 @Value和@ConfigurationProperties获取值比较：</h4><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>单个指定变量的值</td></tr><tr><td>松散绑定</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="2-2-4-Value和-ConfigurationProperties的比较"><a href="#2-2-4-Value和-ConfigurationProperties的比较" class="headerlink" title="2.2.4 @Value和@ConfigurationProperties的比较"></a>2.2.4 @Value和@ConfigurationProperties的比较</h4><p><strong>如果只是在某个业务逻辑中需要获取一下配置文件中的值，那就用@Value；如果专门编写了Java bean和配置文件进行映射，就直接使用@ConfigurationProperties。</strong></p><pre><code class="java">package com.demo.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author zhulongkun20@163.com * @since 18-9-12 下午9:30 */@RestControllerpublic class DemoController &#123;    @Value(&quot;$&#123;person.name&#125;&quot;)    private String name;    @RequestMapping(&quot;/demo.do&quot;)    public String sayHello() &#123;        return &quot;Hello, &quot; + name;    &#125;&#125;</code></pre><hr><h3 id="2-3-PropertySource和-ImportSource"><a href="#2-3-PropertySource和-ImportSource" class="headerlink" title="2.3 @PropertySource和@ImportSource"></a>2.3 @PropertySource和@ImportSource</h3><p><strong>@ConfigurationProperties默认从全局配置文件中获取值。</strong></p><h4 id="2-3-1-PropertySource获取配置文件的值："><a href="#2-3-1-PropertySource获取配置文件的值：" class="headerlink" title="2.3.1 @PropertySource获取配置文件的值："></a>2.3.1 @PropertySource获取配置文件的值：</h4><pre><code>@ConfigurationProperties(prefix = &quot;person&quot;)@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)</code></pre><h4 id="2-3-2-ImportSource：导入Spring配置文件，是配置文件中的配置生效。"><a href="#2-3-2-ImportSource：导入Spring配置文件，是配置文件中的配置生效。" class="headerlink" title="2.3.2 @ImportSource：导入Spring配置文件，是配置文件中的配置生效。"></a>2.3.2 @ImportSource：导入Spring配置文件，是配置文件中的配置生效。</h4><p>SpringBoot默认没有加载Spring配置文件，手动编写的配置文件也无法识别，想让配置文件生效，将@ImportSource标注在主配置类上。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;demoService&quot; class=&quot;com.demo.service.DemoService&quot;/&gt;&lt;/beans&gt;</code></pre><pre><code class="java">    @Autowired    private ApplicationContext applicationContext;    @Test    public void demoServiceTest() &#123;        boolean hasDemoService = applicationContext.containsBean(&quot;demoService&quot;);        System.out.println(hasDemoService);    &#125;</code></pre><h4 id="2-3-3-SpringBoot推荐的添加组件方式"><a href="#2-3-3-SpringBoot推荐的添加组件方式" class="headerlink" title="2.3.3 SpringBoot推荐的添加组件方式"></a>2.3.3 SpringBoot推荐的添加组件方式</h4><p>SpringBoot推荐给容器中添加组件的方式：使用全注解，@Configuration标注配置类。</p><p>@Bean：**<u>将方法的返回值添加到容器中，组件的默认id就是方法名。</u>**</p><pre><code class="java">package com.demo.config;import com.demo.service.DemoService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author zhulongkun20@163.com * @since 18-9-12 下午9:52 */@Configurationpublic class AppConfig &#123;    /**     * @return     * @desc 将方法的返回值添加到容器中，组件的默认id就是方法名     */    @Bean    public DemoService demoService() &#123;        System.out.println(&quot;给容器中添加组件&quot;);        return new DemoService();    &#125;&#125;</code></pre><hr><h3 id="2-4-配置文件占位符"><a href="#2-4-配置文件占位符" class="headerlink" title="2.4 配置文件占位符"></a>2.4 配置文件占位符</h3><pre><code class="yaml">server:  port: 8081person:  name: 张三$&#123;random.value&#125;  age: $&#123;random.int&#125;  birth: 2018/09/11  map:    k1: $&#123;random.value&#125;    k2: v2  dog:    name: $&#123;person.hello:defau&#125;    age: 4  alive: true  classes:    - v1    - v2</code></pre><ol><li>随机数：</li></ol><p>${random.value}，${random.int}，${random.long}，${random.int(10)}，${random.int[1,10]}</p><ol><li>占位符获取配置之前的值，${app.name:默认值}</li></ol><hr><h3 id="2-5-Profile多环境支持"><a href="#2-5-Profile多环境支持" class="headerlink" title="2.5 Profile多环境支持"></a>2.5 Profile多环境支持</h3><blockquote><p>profile为不同环境提供不同配置的功能。</p></blockquote><ol><li><p>多profile文件的方式：</p><p>在主配置文件编写的时候，文件名可以是application-{profile}.properties&#x2F;application-{profile}.yml；</p><p>SpringBoot默认使用全局环境配置</p></li><li><p>激活指定profile：</p><pre><code class="yaml">spring:  profiles:    active: dev</code></pre><p><strong>命令行方式：</strong></p><p>–spring.profiles.active&#x3D;dev&#x2F;prod</p><p><strong>虚拟机参数：</strong></p><p>-Dspring.profiles.active&#x3D;dev&#x2F;prod</p></li><li><p>yaml支持文档块的方式：</p><pre><code class="yaml">server:  port: 8080spring:  profiles:    active: dev---server:  port: 8083spring:  profiles: dev  ---server:     port: 8084spring:  profiles: prod</code></pre></li></ol><p>见下图：<img src="https://image.youyou-2608.com/springboot/20180913201726.jpg" alt="厉害了"></p><hr><h3 id="2-6-配置文件加载位置"><a href="#2-6-配置文件加载位置" class="headerlink" title="2.6 配置文件加载位置"></a>2.6 配置文件加载位置</h3><p>SpringBoot启动会扫描以下位置的application.properties或者application.yml文件作为SpringBoot的默认配置文件：</p><ul><li>file：.&#x2F;config&#x2F;</li><li>file：.&#x2F;</li><li>classpath：&#x2F;config&#x2F;</li><li>classpath：&#x2F;</li></ul><p><strong>以上位置优先级从高到低。所有位置的配置文件都会被加载，高优先级的配置会覆盖低优先级的配置，高优先级和低优先级配置文件形成互补配置。</strong></p><p>server.context-path&#x3D;&#x2F;config02 -&gt; <a href="http://localhost:8080/config02/hello.do">http://localhost:8080/config02/hello.do</a></p><p><strong>还可以通过spring.config.location来改变默认的配置文件位置(项目打包后可以使用命令行参数的形式启动项目时候来指定配置文件的位置，指定的配置文件和默认加载的配置文件会形成互补配置)。</strong></p><p>见下图：</p><p><img src="https://image.youyou-2608.com/springboot/20180913202351.jpg" alt="图片丢失"></p><hr><h3 id="2-7-外部配置文件加载顺序"><a href="#2-7-外部配置文件加载顺序" class="headerlink" title="2.7 外部配置文件加载顺序"></a>2.7 外部配置文件加载顺序</h3><p>SpringBoot也可以从以下位置加载配置文件，优先级从高到低，<strong>高优先级的配置会覆盖低优先级的配置，高低优先级的配置会形成互补配置</strong>。</p><ol><li><a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#using-boot-devtools-globalsettings">Devtools global settings properties</a> on your home directory (<code>~/.spring-boot-devtools.properties</code> when devtools is active).</li><li><a href="https://docs.spring.io/spring/docs/5.0.9.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html"><code>@TestPropertySource</code></a> annotations on your tests.</li><li><a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/api/org/springframework/boot/test/context/SpringBootTest.html"><code>@SpringBootTest#properties</code></a> annotation attribute on your tests.</li><li>Command line arguments.</li><li>Properties from <code>SPRING_APPLICATION_JSON</code> (inline JSON embedded in an environment variable or system property).</li><li><code>ServletConfig</code> init parameters.</li><li><code>ServletContext</code> init parameters.</li><li>JNDI attributes from <code>java:comp/env</code>.</li><li>Java System properties (<code>System.getProperties()</code>).</li><li>OS environment variables.</li><li>A <code>RandomValuePropertySource</code> that has properties only in <code>random.*</code>.</li><li><a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features-external-config-profile-specific-properties">Profile-specific application properties</a> outside of your packaged jar (<code>application-&#123;profile&#125;.properties</code> and YAML variants).</li><li><a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features-external-config-profile-specific-properties">Profile-specific application properties</a> packaged inside your jar (<code>application-&#123;profile&#125;.properties</code> and YAML variants).</li><li>Application properties outside of your packaged jar (<code>application.properties</code> and YAML variants).</li><li>Application properties packaged inside your jar (<code>application.properties</code> and YAML variants).</li><li><a href="https://docs.spring.io/spring/docs/5.0.9.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a> annotations on your <code>@Configuration</code> classes.</li><li>Default properties (specified by setting <code>SpringApplication.setDefaultProperties</code>).</li></ol><p>由jar包外向jar包内进行查找。</p><p>命令行参数（多个参数用空格分开）；</p><ul><li>java -jar xxx.jar –server.port&#x3D;8081 server.context.path&#x3D;&#x2F;ab</li></ul><p>优先加载带profile的配置文件。</p><ul><li>jar包外的application-{profile}或application-{yml}或不带spring.profile的配置文件；</li><li>jar包内的application-{profile}或application-{yml}或不带spring.profile的配置文件；</li></ul><p>再加载带不profile的配置文件。</p><ul><li><p>jar包外的application-{profile}或application-{yml}或不带spring.profile的配置文件；</p></li><li><p>jar包内的application-{profile}或application-{yml}或不带spring.profile的配置文件；</p></li><li><p>@Configuration注解类上的@PropertySource；</p></li><li><p>通过SpringApplication.setDefaultProperties指定的默认属性。</p></li></ul><p>详细参见SpringBoot官网：<a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features">SpringBoot外部配置文件加载顺序</a></p><hr><h3 id="2-8-自动配置原理"><a href="#2-8-自动配置原理" class="headerlink" title="2.8 自动配置原理"></a>2.8 自动配置原理</h3><p>配置文件能写什么，怎么写？</p><p>自动配置原理：</p><ol><li>SpringBoot在启动的时候加载主配置类，开启了自动配置功能：@EnableAutoConfiguration；</li><li>@EnableAutoConfiguration的作用：<ol><li>利用@EnableAutoConfigurationImportSelector给容器导入一些组件；</li><li>可以查看selectImports中的内容；</li><li>List<String> configurations &#x3D; getCandidateConfigurations(annotationMetadata, attributes) 方法；<ul><li>SpringFactoriesLoader.loadFactoryNames()；</li><li>扫描所有jar包类路径下：META-INF&#x2F;spring.factories；</li><li>将扫描到的文件内容加载包装成properties对象。</li></ul></li></ol></li><li>每一个自动配置类进行功能的自动配置；</li><li>所有在配置文件中能配置的属性都在xxxProperties类中配置着，配置文件能配置什么都参照配置文件中的值；</li></ol><p>SpringBoot的特点：</p><ol><li>SpringBoot启动时会加载大量的自动配置类；</li><li>看SpringBoot有没有自动配置类；</li><li>如果有，不用自己再写自动配置类。</li><li>给容器中自动配置类添加组件的时候，会从properties类中读取某些属性，我们就可以在配置文件中指定这些属性的值。</li></ol><hr><h3 id="2-9-Conditional自动配置"><a href="#2-9-Conditional自动配置" class="headerlink" title="2.9 @Conditional自动配置"></a>2.9 @Conditional自动配置</h3><blockquote><p>自动配置类需要在一定条件下才能生效。</p></blockquote><p>注解的作用：必须是@Conditional指定的条件成立，才能给容器中添加组件，配置里面的所有内容才生效。</p><table><thead><tr><th>@Conditional扩展</th><th>作用(判断是否满足当前条件)</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的Java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定的bean</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定的bean</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式</td></tr><tr><td>@ConditionalOnClass</td><td>容器中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>容器中没有指定的类</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定属性是有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的bean，或者这个bean是首选的bean</td></tr></tbody></table><p>自动配置文件：org&#x2F;springframework&#x2F;boot&#x2F;spring-boot-autoconfigure&#x2F;2.0.5.RELEASE&#x2F;spring-boot-autoconfigure-2.0.5.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factories</p><pre><code class="properties"># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityRequestMatcherProviderAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</code></pre><p>开启SpringBoot的debug，可以通过debug&#x3D;true让控制台打印自动配置报告，便可以方便的知道哪些自动配置类生效了。</p><pre><code class="text">============================CONDITIONS EVALUATION REPORT============================Positive matches:-----------------   CodecsAutoConfiguration matched:      - @ConditionalOnClass found required class &#39;org.springframework.http.codec.CodecConfigurer&#39;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)   CodecsAutoConfiguration.JacksonCodecConfiguration matched:      - @ConditionalOnClass found required class &#39;com.fasterxml.jackson.databind.ObjectMapper&#39;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)</code></pre><pre><code class="text">Negative matches:-----------------   ActiveMQAutoConfiguration:      Did not match:         - @ConditionalOnClass did not find required classes &#39;javax.jms.ConnectionFactory&#39;, &#39;org.apache.activemq.ActiveMQConnectionFactory&#39; (OnClassCondition)   AopAutoConfiguration:      Did not match:         - @ConditionalOnClass did not find required classes &#39;org.aspectj.lang.annotation.Aspect&#39;, &#39;org.aspectj.lang.reflect.Advice&#39;, &#39;org.aspectj.weaver.AnnotatedElement&#39; (OnClassCondition)</code></pre><h2 id="第三章-SpringBoot与日志"><a href="#第三章-SpringBoot与日志" class="headerlink" title="第三章 SpringBoot与日志"></a>第三章 SpringBoot与日志</h2><hr><h3 id="3-1-日志框架"><a href="#3-1-日志框架" class="headerlink" title="3.1 日志框架"></a>3.1 日志框架</h3><ul><li>System.out.println(“welcome!”);  不利于代码维护；</li><li>使用日志框架；</li><li>加入异步，自动归档等功能；</li><li>与程序耦合控制；</li><li>统一的接口层：日志门面。</li></ul><p>常见的日志框架：</p><ul><li>JUL（java.util.logging）；</li><li>JCL；</li><li>jboss-logging；</li><li>logback；</li><li>log4j；</li><li>log4j2；</li><li>slf4j；</li></ul><p>日志门面：SLF4J；</p><p>日志实现：Logback。</p><p>SpringBoot：底层是Spring框架，SpringBoot框架默认是JCL</p><p><strong>SpringBoot选用SLF4J，Logback。</strong></p><hr><h3 id="3-2-SLF4J的使用"><a href="#3-2-SLF4J的使用" class="headerlink" title="3.2 SLF4J的使用"></a>3.2 SLF4J的使用</h3><hr><h4 id="3-2-1-如何在系统中使用SLF4J"><a href="#3-2-1-如何在系统中使用SLF4J" class="headerlink" title="3.2.1 如何在系统中使用SLF4J"></a>3.2.1 如何在系统中使用SLF4J</h4><p>开发的时候，日志记录的方法调用，应该直接调用日志抽象层里的方法，而不是日志的实现类。</p><p>给系统导入slf4j的jar和logback的实现jar：</p><pre><code class="java">import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123;  public static void main(String[] args) &#123;    Logger logger = LoggerFactory.getLogger(HelloWorld.class);    logger.info(&quot;Hello World&quot;);  &#125;&#125;</code></pre><p>图示：</p><p><img src="https://image.youyou-2608.com/springboot/concrete-bindings.png" alt="具体关系"></p><p>每一个日志框架都有自己的配置文件，使用slf4j以后，<strong>配置文件还是作为日志实现框架本身的配置文件。</strong></p><hr><h4 id="3-2-2-遗留问题"><a href="#3-2-2-遗留问题" class="headerlink" title="3.2.2 遗留问题"></a>3.2.2 遗留问题</h4><p>a（slf4j + logback）：Spring(commons-logging)，Hibernate(jboss-logging)</p><p>统一日志记录，即便是别的框架也使用同一日志框架。</p><p><img src="https://image.youyou-2608.com/springboot/legacy.png"></p><p>如何让系统中所有的日志都统一到slf4j：</p><ol><li><u>将系统中其他日志框架排除在外；</u></li><li><u>用中间适配层包替换原有日志框架；</u></li><li><u>导入slf4j其他的实现。</u></li></ol><hr><h3 id="3-3-SpringBoot日志关系"><a href="#3-3-SpringBoot日志关系" class="headerlink" title="3.3 SpringBoot日志关系"></a>3.3 SpringBoot日志关系</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>SpringBoot的日志功能：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;    &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>SpringBoot底层依赖关系（pom.xml文件，show diagram查看maven项目依赖关系）：</p><p><img src="https://image.youyou-2608.com/springboot/irei.png"></p><ol><li>SpringBoot底层也是用slf4j + logback的方式进行日志记录；</li><li>SpringBoot也把其他的日志都替换成了slf4j；</li><li>中间替换包；</li><li>如果要引入其他框架，一定要把这个框架的默认日志依赖移除。</li></ol><p><strong>SpringBoot自动适应所有的日志框架，而且底层使用了slf4j + logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖移除掉。</strong></p><hr><h3 id="3-4-SpringBoot默认日志配置"><a href="#3-4-SpringBoot默认日志配置" class="headerlink" title="3.4 SpringBoot默认日志配置"></a>3.4 SpringBoot默认日志配置</h3><p>日志的级别，由低到高，可以调整日志输出的级别：</p><pre><code class="java">        Logger logger = LoggerFactory.getLogger(getClass());        //日志的级别，由低到高        logger.trace(&quot;这是日志...&quot;);        logger.debug(&quot;这是debug日志...&quot;);        logger.info(&quot;这是Info信息...&quot;);        logger.warn(&quot;这是警告...&quot;);        logger.error(&quot;这是错误信息...&quot;);</code></pre><p>SpringBoot默认日志输出级别为info。</p><p>可以在application.yml中自定义日志输出级别： logging.level.com.hape.nmsl&#x3D;trace</p><p>在当前项目下生成日志文件：logging.file&#x3D;springboot.log</p><p>不指定路径在项目路径下生成日志文件。</p><p>logfile优先级高于logpath。</p><p>logpath：指定日志文件的路径，默认文件名spring.log。</p><p>logging.pattern.console：控制台输出日志的格式。</p><p>logging.pattern.file：日志文件输出格式。</p><p>日志输出格式：</p><pre><code class="properties">%d：表示日期时间；%thread：表示线程号；%-5level：级别从左显示5个字符宽度；%logger&#123;50&#125;：表示logger名字最长50个字符，否则按照句点分割；%msg：日志信息；%n：换行符。</code></pre><p>日志格式配置实例：</p><pre><code class="properties">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</code></pre><hr><h3 id="3-5-指定日志文件和日志profile功能"><a href="#3-5-指定日志文件和日志profile功能" class="headerlink" title="3.5 指定日志文件和日志profile功能"></a>3.5 指定日志文件和日志profile功能</h3><p>给类路径下放上每个日志框架自己配置文件即可，</p><blockquote><p>Because the standard <code>logback.xml</code> configuration file is loaded too early, you cannot use extensions in it. You need to either use <code>logback-spring.xml</code> or define a <code>logging.config</code> property.</p></blockquote><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>logback.xml：直接被日志框架识别；</p><p><strong>logback-spring.xml：日志框架不直接加载配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级功能profile。</strong></p><pre><code class="xml">可以指定某一段配置只在某个环境下生效&lt;springProfile name=&quot;staging&quot;&gt;    &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;&lt;/springProfile&gt;&lt;springProfile name=&quot;dev, staging&quot;&gt;    &lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active--&gt;&lt;/springProfile&gt;&lt;springProfile name=&quot;!production&quot;&gt;    &lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;&lt;/springProfile&gt;</code></pre><hr><h3 id="3-6-切换日志框架"><a href="#3-6-切换日志框架" class="headerlink" title="3.6 切换日志框架"></a>3.6 切换日志框架</h3><p>可以按照slf4j适配图进行相关的切换。</p><ol><li>排除不使用的包；</li><li>导入相关的适配包；</li></ol><p>不推荐更换SpringBoot默认使用的日志记录框架。</p><hr><h2 id="第四章-SpringBoot与Web开发"><a href="#第四章-SpringBoot与Web开发" class="headerlink" title="第四章 SpringBoot与Web开发"></a>第四章 SpringBoot与Web开发</h2><p>使用SpringBoot：</p><ul><li>创建SpringBoot应用，选中需要的模块；</li><li>SpringBoot自动配置好场景，需要在配置文件中指定少量配置，即可运行程序；</li><li>编写相关的业务逻辑。</li></ul><p>依赖于SpringBoot的自动配置。</p><hr><h3 id="4-1-webjar与静态资源映射规则"><a href="#4-1-webjar与静态资源映射规则" class="headerlink" title="4.1 webjar与静态资源映射规则"></a>4.1 webjar与静态资源映射规则</h3><p>SpringBoot对静态资源的映射规则：（WebMvcAutoConfiguration.java）</p><pre><code class="java">@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    if (!this.resourceProperties.isAddMappings()) &#123;        logger.debug(&quot;Default resource handling disabled&quot;);        return;    &#125;    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();    CacheControl cacheControl = this.resourceProperties.getCache()        .getCachecontrol().toHttpCacheControl();    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;        customizeResourceHandlerRegistration(registry                                             .addResourceHandler(&quot;/webjars/**&quot;)                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)                                             .setCachePeriod(getSeconds(cachePeriod))                                             .setCacheControl(cacheControl));    &#125;    String staticPathPattern = this.mvcProperties.getStaticPathPattern();    if (!registry.hasMappingForPattern(staticPathPattern)) &#123;        customizeResourceHandlerRegistration(            registry.addResourceHandler(staticPathPattern)            .addResourceLocations(getResourceLocations(                this.resourceProperties.getStaticLocations()))            .setCachePeriod(getSeconds(cachePeriod))            .setCacheControl(cacheControl));    &#125;&#125;</code></pre><ul><li><p>所有的&#x2F;webjars&#x2F;**，都到classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars找资源；</p><p>webjars以jar包的方式引入静态资源。</p><p><img src="https://image.youyou-2608.com/springboot/webjars.png"></p></li></ul><p>在访问的时候只需要写webjars下的资源名称即可。（<a href="http://localhost:8080/webjars/jquery/3.3.1-1/jquery.js%EF%BC%89">http://localhost:8080/webjars/jquery/3.3.1-1/jquery.js）</a></p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.webjars&lt;/groupId&gt;    &lt;artifactId&gt;jquery&lt;/artifactId&gt;    &lt;version&gt;3.3.1-1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li><p>访问当前项目下的任何资源（静态资源的文件夹）</p><pre><code class="xml">&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;,&quot;classpath:/public/&quot;</code></pre></li><li><p>配置欢迎页</p><pre><code class="java">@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(    ApplicationContext applicationContext) &#123;    return new WelcomePageHandlerMapping(        new TemplateAvailabilityProviders(applicationContext),        applicationContext, getWelcomePage(),        this.mvcProperties.getStaticPathPattern());&#125;</code></pre><p>静态文件夹下的所有index.html页面；</p><p>映射到 private String staticPathPattern &#x3D; “&#x2F;**”;</p></li><li><p>配置喜欢的图标</p><pre><code class="java">@Configuration@ConditionalOnProperty(value = &quot;spring.mvc.favicon.enabled&quot;, matchIfMissing = true)public static class FaviconConfiguration implements ResourceLoaderAware &#123;    private final ResourceProperties resourceProperties;    private ResourceLoader resourceLoader;    public FaviconConfiguration(ResourceProperties resourceProperties) &#123;        this.resourceProperties = resourceProperties;    &#125;</code></pre><p>映射到**favicon.ico静态资源文件夹。</p></li></ul><hr><h3 id="4-2-引入Thymeleaf模板引擎"><a href="#4-2-引入Thymeleaf模板引擎" class="headerlink" title="4.2 引入Thymeleaf模板引擎"></a>4.2 引入Thymeleaf模板引擎</h3><blockquote><p>thymeleaf, jsp, freemaker, velocity</p></blockquote><p>SpringBoot推荐的thymeleaf：</p><ol><li>引入thymeleaf；</li><li>自定义thymeleaf版本。</li></ol><pre><code class="xml">&lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt;&lt;!--布局功能支持程序  thymeleaf3  layout2以上版本适配--&gt;&lt;thymeleaf.layout.dialect.version&gt;2.1.1&lt;/thymeleaf.layout.dialect.version&gt;</code></pre><hr><h3 id="4-3-Thymeleaf语法"><a href="#4-3-Thymeleaf语法" class="headerlink" title="4.3 Thymeleaf语法"></a>4.3 Thymeleaf语法</h3><p>默认请求路径：classpath:templates&#x2F;xxx.html</p><p>文档地址：<a href="https://www.thymeleaf.org/documentation.html">Thymeleaf参考文档</a></p><p>使用方法：</p><ul><li><p>导入Thymeleaf名称空间；</p><pre><code class="html">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http:y//www.thymeleaf.org&quot;&gt;</code></pre></li><li><p>使用Thymeleaf语法；</p><pre><code class="html">&lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;显示欢迎信息&lt;/div&gt;</code></pre></li><li><p>thymeleaf语法规则：</p><ul><li><p>th:text：改变text文本值；</p></li><li><p>th:任意属性都可以替换；</p></li><li><p>文档第十章&#x2F;Attributes&#x2F;优先级；</p><p><img src="https://image.youyou-2608.com/springboot/DeepinScreenshot_select-area_20181001125611.png"></p></li></ul></li><li><p>thymeleaf表达式；</p><pre><code class="properties">Simple expressions:    Variable Expressions: $&#123;...&#125;    Selection Variable Expressions: *&#123;...&#125;    Message Expressions: #&#123;...&#125;    Link URL Expressions: @&#123;...&#125;    Fragment Expressions: ~&#123;...&#125;Literals    Text literals: &#39;one text&#39; , &#39;Another one!&#39; ,...    Number literals: 0 , 34 , 3.0 , 12.3 ,...    Boolean literals: true , false    Null literal: null    Literal tokens: one , sometext , main ,...Text operations:    String concatenation: +    Literal substitutions: |The name is $&#123;name&#125;|    Arithmetic operations:    Binary operators: + , - , * , / , %    Minus sign (unary operator): -Boolean operations:    Binary operators: and , or    Boolean negation (unary operator): ! , notComparisons and equality:    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )    Equality operators: == , != ( eq , ne )Conditional operators:    If-then: (if) ? (then)    If-then-else: (if) ? (then) : (else)    Default: (value) ?: (defaultvalue)Special tokens:    Page 17 of 106No-Operation: _</code></pre><p>内置对象：</p><pre><code class="properties">#ctx : the context object.#vars: the context variables.#locale : the context locale.#request : (only in Web Contexts) the HttpServletRequest object.#response : (only in Web Contexts) the HttpServletResponse object.#session : (only in Web Contexts) the HttpSession object.#servletContext : (only in Web Contexts) the ServletContext object.</code></pre></li></ul><hr><h3 id="4-4-SpringMVC自动配置功能"><a href="#4-4-SpringMVC自动配置功能" class="headerlink" title="4.4 SpringMVC自动配置功能"></a>4.4 SpringMVC自动配置功能</h3><p>SpringBoot文档地址：<a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications">官方文档地址</a></p><h4 id="4-4-1-SpringMVC自动配置项"><a href="#4-4-1-SpringMVC自动配置项" class="headerlink" title="4.4.1 SpringMVC自动配置项"></a>4.4.1 SpringMVC自动配置项</h4><p>SpringMVC自动配置：</p><ul><li>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</li><li>Support for serving static resources, including support for WebJars (covered <a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content">later in this document</a>)).</li><li>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, and <code>Formatter</code> beans.</li><li>Support for <code>HttpMessageConverters</code> (covered <a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-message-converters">later in this document</a>).</li><li>Automatic registration of <code>MessageCodesResolver</code> (covered <a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features-spring-message-codes">later in this document</a>).</li><li>Static <code>index.html</code> support.</li><li>Custom <code>Favicon</code> support (covered <a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-favicon">later in this document</a>).</li><li>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (covered <a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-web-binding-initializer">later in this document</a>).</li></ul><pre><code class="java">@Bean@ConditionalOnBean(ViewResolver.class)@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123;    ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();    resolver.setContentNegotiationManager(        beanFactory.getBean(ContentNegotiationManager.class));    // ContentNegotiatingViewResolver uses all the other view resolvers to locate    // a view so it should have a high precedence    resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);    return resolver;&#125;</code></pre><pre><code class="java">@Overridepublic void addFormatters(FormatterRegistry registry) &#123;    for (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123;        registry.addConverter(converter);    &#125;    for (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123;        registry.addConverter(converter);    &#125;    for (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123;        registry.addFormatter(formatter);    &#125;&#125;</code></pre><pre><code class="java">@Overridepublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;    this.messageConvertersProvider.ifAvailable((customConverters) -&gt; converters                                               .addAll(customConverters.getConverters()));&#125;</code></pre><ul><li>如果用户有配置(@Bean，@Component)，则使用组合配置；</li></ul><h4 id="4-4-2-扩展SpringMVC配置"><a href="#4-4-2-扩展SpringMVC配置" class="headerlink" title="4.4.2 扩展SpringMVC配置"></a>4.4.2 扩展SpringMVC配置</h4><p>添加一个配置类并且继承自WebMvcConfigurerAdapter。</p><p>将hello.do请求映射到hello.html视图：</p><pre><code class="java">package com.web.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;/** * @author zhulongkun20@163.com * @since 18-10-1 下午1:51 */@Configurationpublic class MvcConfig extends WebMvcConfigurerAdapter &#123;    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;//        super.addViewControllers(registry);        registry.addViewController(&quot;/hello.do&quot;).setViewName(&quot;/hello.html&quot;);    &#125;&#125;</code></pre><ul><li>WebMvcAutoConfiguration是SpringMVC的自动配置类；</li><li>在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)。</li></ul><pre><code class="java">@Autowired(required = false)public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;    if (!CollectionUtils.isEmpty(configurers)) &#123;        this.configurers.addWebMvcConfigurers(configurers);    &#125;&#125;</code></pre><ul><li><p>容器中所有的WebMvcConfiguration都会被调用。</p><p>所有的配置都会共同起作用。</p></li></ul><h4 id="4-4-3-全面接管SpringMVC"><a href="#4-4-3-全面接管SpringMVC" class="headerlink" title="4.4.3 全面接管SpringMVC"></a>4.4.3 全面接管SpringMVC</h4><p>在配置类中添加@EnableWebMvc：丢弃所有的自动配置，手动配置所有的配置。</p><p>原理：</p><p>WebMvc：</p><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123;&#125;</code></pre><p>DelegatingWebMvcConfiguration：</p><pre><code class="java">@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();&#125;</code></pre><p>WebMvcAutoConfiguration：</p><pre><code class="java">@Configuration@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)//容器中缺少此组件，该自动配置生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class,        ValidationAutoConfiguration.class &#125;)</code></pre><hr><h3 id="4-5-引入资源"><a href="#4-5-引入资源" class="headerlink" title="4.5 引入资源"></a>4.5 引入资源</h3><p>SpringBoot中使用<strong>webjars</strong>引入jquery和bootstrap之类的资源：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;index&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;webjars/bootstrap/4.1.3/css/bootstrap.css&#125;&quot; th:type=&quot;text/css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>即使更换项目访问名也可以正常加载静态资源。</strong></p><pre><code class="java">package com.web.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;/** * @author zhulongkun20@163.com * @since 18-10-1 下午1:51 *///@EnableWebMvc@Configurationpublic class MvcConfig extends WebMvcConfigurerAdapter &#123;    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;//        super.addViewControllers(registry);        registry.addViewController(&quot;/hello.do&quot;).setViewName(&quot;/hello.html&quot;);        registry.addViewController(&quot;/&quot;).setViewName(&quot;/hello.html&quot;);    &#125;    public WebMvcConfigurerAdapter webMvcConfigurerAdapter() &#123;        return new WebMvcConfigurerAdapter() &#123;            @Override            public void addViewControllers(ViewControllerRegistry registry) &#123;                registry.addViewController(&quot;/&quot;).setViewName(&quot;/hello.html&quot;);            &#125;        &#125;;    &#125;&#125;</code></pre><hr><h3 id="4-6-国际化"><a href="#4-6-国际化" class="headerlink" title="4.6 国际化"></a>4.6 国际化</h3><ol><li><strong>编写国际化配置文件；</strong></li><li>使用ResourceBundleMessageSource管理国际化资源文件；</li><li>在页面使用fmt:message取出国际化内容。</li></ol><p>配置如下图：</p><p><img src="https://image.youyou-2608.com/springboot/international.png"></p><p>SpringBoot自动配置（MessageSourceAutoConfiguration.java）：</p><pre><code class="java">@Bean//类路径下配置文件spring.messages@ConfigurationProperties(prefix = &quot;spring.messages&quot;)public MessageSourceProperties messageSourceProperties() &#123;    return new MessageSourceProperties();&#125;@Beanpublic MessageSource messageSource() &#123;    MessageSourceProperties properties = messageSourceProperties();    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();    if (StringUtils.hasText(properties.getBasename())) &#123;        //设置国际化资源文件的基础名（去除国际语言代码）        messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(            StringUtils.trimAllWhitespace(properties.getBasename())));    &#125;    if (properties.getEncoding() != null) &#123;        messageSource.setDefaultEncoding(properties.getEncoding().name());    &#125;    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());    Duration cacheDuration = properties.getCacheDuration();    if (cacheDuration != null) &#123;        messageSource.setCacheMillis(cacheDuration.toMillis());    &#125;    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());    return messageSource;&#125;</code></pre><p>设置配置文件地址：</p><pre><code class="properties">spring.message=login</code></pre><p>页面中获取国际化资源：</p><pre><code class="html">&lt;lable class=&quot;sr-only&quot; th:message=&quot;#&#123;login.tip&#125;&quot;&gt;Tips&lt;/lable&gt;&lt;lable class=&quot;sr-only&quot; th:message=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/lable&gt;&lt;lable class=&quot;sr-only&quot; th:message=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/lable&gt;&lt;lable class=&quot;sr-only&quot; th:message=&quot;#&#123;login.remember&#125;&quot;&gt;remember&lt;/lable&gt;</code></pre><p>浏览器根据浏览器语言设置的信息自动切换国际化。</p><p>SpringMVC区域信息组件：</p><pre><code class="java">@Bean@ConditionalOnMissingBean@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)public LocaleResolver localeResolver() &#123;    if (this.mvcProperties        .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;        return new FixedLocaleResolver(this.mvcProperties.getLocale());    &#125;    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());    return localeResolver;&#125;//默认根据请求头获取的区域信息展示国际化信息。</code></pre><p><strong>可以在请求参数上携带区域信息实现国际化：</strong></p><pre><code class="html">https://localhost:8080/hello.do?language=zh_CNhttps://localhost:8080/hello.do?language=en_US</code></pre><p>手动配置区域信息解析器：</p><pre><code class="java">package com.web.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.LocaleResolver;import org.thymeleaf.util.StringUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;/** * @author zhulongkun20@163.com * @since 18-10-3 下午4:43 */@Configurationpublic class MyLocaleResolver implements LocaleResolver &#123;    @Override    public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123;        String language = httpServletRequest.getParameter(&quot;language&quot;);        Locale locale = Locale.getDefault();        if (!StringUtils.isEmpty(language)) &#123;            String[] regionInfo = language.split(&quot;_&quot;);            locale = new Locale(regionInfo[0], regionInfo[1]);        &#125;        return locale;    &#125;    @Override    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;            &#125;&#125;</code></pre><hr><h3 id="4-7-拦截器"><a href="#4-7-拦截器" class="headerlink" title="4.7 拦截器"></a>4.7 拦截器</h3><ul><li>PostMapping()：RestfulAPI注解；</li><li>开发期间禁用Thymeleaf的缓存：spring.thymeleaf.cache&#x3D;false；</li><li>错误消息的显示；</li><li>防止表单重复提交，添加视图视图映射后，使用重定向。</li><li>使用拦截器进行身份校验；</li><li>编写拦截器，在配置类中注册拦截器。</li><li>页面中使用Thymeleaf获取值。</li></ul><hr><h3 id="4-8-CRUD实验"><a href="#4-8-CRUD实验" class="headerlink" title="4.8 CRUD实验"></a>4.8 CRUD实验</h3><h4 id="4-8-1-实验要求"><a href="#4-8-1-实验要求" class="headerlink" title="4.8.1 实验要求"></a>4.8.1 实验要求</h4><p>实验要求：</p><ol><li><p>RestfulAPI风格：</p><ol><li>URI：&#x2F;资源名称&#x2F;资源标识；</li><li>HTTP请求方式区分对资源的CRUD操作；</li></ol><table><thead><tr><th>操作</th><th>普通CRUD</th><th>RestfulCRUD</th></tr></thead><tbody><tr><td>查询</td><td>getEmp</td><td>emp—GET</td></tr><tr><td>添加</td><td>addEmp?xxx</td><td>emp—POST</td></tr><tr><td>修改</td><td>updateEmp?id&#x3D;xxx&amp;xxx&#x3D;xxx</td><td>emp&#x2F;{id}—PUT</td></tr><tr><td>删除</td><td>deleteEmp?id&#x3D;1</td><td>emp&#x2F;{id}—DELETE</td></tr></tbody></table></li><li><p>实验的请求架构：</p><table><thead><tr><th></th><th>请求URI</th><th>请求方式</th></tr></thead><tbody><tr><td>查询所有的员工</td><td>emps</td><td>GET</td></tr><tr><td>查询某个员工</td><td>emp&#x2F;{id}</td><td>GET</td></tr><tr><td>来到添加界面</td><td>emp</td><td>GET</td></tr><tr><td>添加员工</td><td>emp</td><td>POST</td></tr><tr><td>来到修改界面</td><td>emp&#x2F;{id}</td><td>PUT</td></tr><tr><td>修改员工</td><td>emp</td><td>PUT</td></tr><tr><td>删除员工</td><td>emp&#x2F;{id}</td><td>DELETE</td></tr></tbody></table></li></ol><h4 id="4-8-2-公共页面抽取—列表页"><a href="#4-8-2-公共页面抽取—列表页" class="headerlink" title="4.8.2 公共页面抽取—列表页"></a>4.8.2 公共页面抽取—列表页</h4><ol><li><p>利用Thymeleaf抽取公共页面；</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;body&gt;&lt;div th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>“~{templatename::selector}”：模板名选择器；</p><p>~{templatename::fragmentname}：模板名：片断名。</p></li><li><p>默认效果：</p><p>insert片段都在div标签中</p><pre><code class="html">&lt;body&gt;...&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre></li><li><p>三种引入功能片段的th属性：</p><ol><li><strong>th:insert：将公共片段整个插入到声明引入的元素中；</strong></li><li><strong>th:replace：将声明引入的元素替换为公共片段；</strong></li><li><strong>th:include：将被引入的片段的内容包含进这个标签中。</strong></li></ol></li></ol><hr><h4 id="4-8-3-链接高亮-列表完成"><a href="#4-8-3-链接高亮-列表完成" class="headerlink" title="4.8.3 链接高亮&amp;列表完成"></a>4.8.3 链接高亮&amp;列表完成</h4><p><img src="https://image.youyou-2608.com/springboot/paramterizable.png"></p><p><strong>实现方法：引入公共片段时传入相关参数，公共片段根据参数高亮相关部分。</strong></p><p>Thymeleaf日期工具对象(文档附录 &gt; dates)：</p><pre><code class="tex">#dates : methods for java.util.Date objects: formatting, component extraction, etc.</code></pre><pre><code class="properties">$</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深田恭子的日剧跑</title>
      <link href="/2018/12/02/e664f0e2c371/"/>
      <url>/2018/12/02/e664f0e2c371/</url>
      
        <content type="html"><![CDATA[<p>深田恭子的日剧跑—Bilibili</p><iframe src="//player.bilibili.com/player.html?aid=9855476&cid=16293423&page=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="470px" width="700px"> </iframe><iframe src="//player.bilibili.com/player.html?aid=9921445&cid=16402294&page=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="470px" width="700px"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 日志随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日剧 </tag>
            
            <tag> 深田恭子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习笔记</title>
      <link href="/2018/12/02/12e1cf33dc16/"/>
      <url>/2018/12/02/12e1cf33dc16/</url>
      
        <content type="html"><![CDATA[<p><a href="http://dubbo.apache.org/zh-cn/index.html">dubbo中文官方网站</a></p><p><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html">dubbo官方文档</a></p><span id="more"></span><h2 id="分布式系统及其演变历程"><a href="#分布式系统及其演变历程" class="headerlink" title="分布式系统及其演变历程"></a>分布式系统及其演变历程</h2><p>单一应用架构：</p><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><p>垂直应用架构：</p><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><p>分布式服务架构：</p><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p><p>流动计算架构：</p><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC（Remote Procedure Call）—<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/7854346">远程过程调用</a>，它是一种通过<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C/143243">网络</a>从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<a href="https://baike.baidu.com/item/RPC%E5%8D%8F%E8%AE%AE">RPC协议</a>假定某些<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/8048821">传输协议</a>的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/9636548">网络通信</a>模型中，RPC跨越了<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536">传输层</a>和<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82/4329788">应用层</a>。RPC使得开发包括网络<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a>多程序在内的应用程序更加容易。</p><p>远程过程调用：序列化和网络通信。</p><h2 id="特性一览"><a href="#特性一览" class="headerlink" title="特性一览"></a>特性一览</h2><ul><li>面向接口代理的高性能RPC调用</li><li>智能负载均衡</li><li>服务自动注册与发现</li><li>高度可扩展能力</li><li>运行期流量调度</li><li>可视化的服务治理与运维</li></ul><h2 id="dubbo应用架构"><a href="#dubbo应用架构" class="headerlink" title="dubbo应用架构"></a>dubbo应用架构</h2><p><img src="http://dubbo.apache.org/img/architecture.png" alt="高性能Java RPC框架"></p><h2 id="dubbo快速启动"><a href="#dubbo快速启动" class="headerlink" title="dubbo快速启动"></a>dubbo快速启动</h2><p><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html">dubbo快速启动</a></p><h3 id="dubbo实例"><a href="#dubbo实例" class="headerlink" title="dubbo实例"></a>dubbo实例</h3><pre><code class="java">package bean;import java.io.Serializable;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午7:45 */public class UserAddress implements Serializable &#123;    private Integer id;    private String userId;    private String userAddress;    private String consignee;    private String phoneNum;    private boolean isDefault;    public UserAddress(Integer id, String userId, String userAddress, String consignee, String phoneNum,                       boolean isDefault) &#123;        this.id = id;        this.userId = userId;        this.userAddress = userAddress;        this.consignee = consignee;        this.phoneNum = phoneNum;        this.isDefault = isDefault;    &#125;    @Override    public String toString() &#123;        return &quot;UserAddress&#123;&quot; +                &quot;id=&quot; + id +                &quot;, userId=&#39;&quot; + userId + &#39;\&#39;&#39; +                &quot;, userAddress=&#39;&quot; + userAddress + &#39;\&#39;&#39; +                &quot;, consignee=&#39;&quot; + consignee + &#39;\&#39;&#39; +                &quot;, phoneNum=&#39;&quot; + phoneNum + &#39;\&#39;&#39; +                &quot;, isDefault=&quot; + isDefault +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><pre><code class="java">package service;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午7:46 */public interface OrderService &#123;    String initOrder(String userId);&#125;</code></pre><pre><code class="java">package service;import bean.UserAddress;import java.util.List;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午7:46 */public interface UserService &#123;    List&lt;UserAddress&gt; getUserAddressList(String userId);&#125;</code></pre><pre><code class="java">package service.impl;import bean.UserAddress;import com.alibaba.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;import service.UserService;import java.util.Arrays;import java.util.List;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午7:49 */@Service@Componentpublic class UserServiceImpl implements UserService &#123;    public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123;        UserAddress userAddress1 = new UserAddress(1, &quot;001&quot;, &quot;人民广场&quot;, &quot;100&quot;, &quot;230189&quot;, true);        UserAddress userAddress2 = new UserAddress(2, &quot;002&quot;, &quot;文化公园&quot;, &quot;101&quot;, &quot;230190&quot;, false);        return Arrays.asList(userAddress1, userAddress2);    &#125;&#125;</code></pre><pre><code class="java">package com.dubbo.service.consumer.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午8:43 */@Servicepublic class OrderServiceImpl implements OrderService &#123;    @Autowired    private UserService userService;    public String initOrder(String userId) &#123;        return userService.getUserAddressList(userId);    &#125;&#125;</code></pre><pre><code class="java">package com.dubbo.service.consumer.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午9:00 */@Controllerpublic class OrderController &#123;    @Autowired    private OrderService orderService;    @ResponseBody    @RequestMapping(&quot;/initOrder.do&quot;)    public String initOrder(@RequestParam(&quot;userId&quot;) String userId) &#123;        return orderService.initOrder(userId);    &#125;&#125;</code></pre><pre><code class="java">package com.dubbo.service.consumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@EnableDubbo@SpringBootApplicationpublic class DubboDemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DubboDemoApplication.class, args);    &#125;&#125;</code></pre><pre><code class="properties"># Spring boot applicationspring.application.name = dubbo-provider-demoserver.port = 9090management.port = 9091# Base packages to scan Dubbo Components (e.g., @Service, @Reference)dubbo.scan.basePackages  = com.alibaba.boot.dubbo.demo.provider.service# Dubbo Config properties## ApplicationConfig Beandubbo.application.id = dubbo-provider-demodubbo.application.name = dubbo-provider-demo## ProtocolConfig Beandubbo.protocol.id = dubbodubbo.protocol.name = dubbodubbo.protocol.port = 12345## RegistryConfig Beandubbo.registry.id = my-registrydubbo.registry.address = N/A</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记-第三章-高级装配</title>
      <link href="/2018/11/24/c410417f8b09/"/>
      <url>/2018/11/24/c410417f8b09/</url>
      
        <content type="html"><![CDATA[<p>第三章：高级装配</p><p>本章内容：</p><ul><li>Spring profile</li><li>条件化的bean声明</li><li>自动装配与歧义性</li><li>bean的作用域</li><li>Spring表达式语言</li></ul><hr><h3 id="3-1-环境与profile"><a href="#3-1-环境与profile" class="headerlink" title="3.1 环境与profile"></a>3.1 环境与profile</h3><p>在软件开发的不同阶段需要不同的环境和配置。</p><pre><code class="java">@Bean(destroyMethod = &quot;shutdown&quot;)public DataSource dataSource() &#123;    return new EmbeddedDatabaseBuilder()        .addScript(&quot;classpath:ch3.sql&quot;)        .addScript(&quot;classpath:ch3.1.sql&quot;)        .build();&#125;</code></pre><span id="more"></span><p>为了适应环境更换的需求，可以将所需要的所有的配置类配置到每个bean中，然后在构建阶段选择需要使用的bean，但是从开发环境切换到生产环境时可能会发生问题。</p><h4 id="3-1-1-配置profile-bean"><a href="#3-1-1-配置profile-bean" class="headerlink" title="3.1.1 配置profile bean"></a>3.1.1 配置profile bean</h4><p>Spring为此种场景提供了profile功能。</p><p>使用profile注解来声明在合适的阶段使用合适的bean。将所有的bean整理到一个profile中，确保在需要的时候active相应的bean。</p><pre><code class="java">package com.ch3;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;import org.springframework.jndi.JndiObjectFactoryBean;import javax.sql.DataSource;/** * @author zhulongkun20@163.com * @since 2018/11/24 下午1:00 */@Configurationpublic class DataSourceConfig &#123;    @Bean(destroyMethod = &quot;shutdown&quot;)    @Profile(&quot;dev&quot;)    public DataSource embeddedDataSource() &#123;        return new EmbeddedDatabaseBuilder()                .setType(EmbeddedDatabaseType.H2)                .addScript(&quot;classpath:test.sql&quot;)                .addScript(&quot;classpath:test1.sql&quot;)                .build();    &#125;    @Bean    @Profile(&quot;prod&quot;)    public DataSource jndiDataSource() &#123;        JndiObjectFactoryBean jndiObjectFactoryBean =                new JndiObjectFactoryBean();        jndiObjectFactoryBean.setJndiName(&quot;jndi/myDS&quot;);        jndiObjectFactoryBean.setResourceRef(true);        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);        return (DataSource) jndiObjectFactoryBean.getObject();    &#125;&#125;</code></pre><p><strong>虽然所有的bean都被声明在一个profile里，但是只有当指定的profile被激活时，相应的bean才会被创建，没有指定profile的bean始终都会被创建，与激活的profile没有关系。</strong></p><p>在XML中配置profile：</p><p>可以通过beans元素的profile属性，在xml中配置profile。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd&quot;        profile=&quot;dev&quot;&gt;    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;        &lt;jdbc:script location=&quot;classpath:test.sql&quot;/&gt;        &lt;jdbc:script location=&quot;classpath:test1.sql&quot;/&gt;    &lt;/jdbc:embedded-database&gt;&lt;/beans&gt;</code></pre><p><strong>只有profile属性与当前激活的profile相匹配的配置文件才会被用到。</strong></p><p>重复使用beans属性指定多个profile：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;       xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd&quot;&gt;    &lt;beans profile=&quot;dev&quot;&gt;        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;            &lt;jdbc:script location=&quot;classpath:test.sql&quot;/&gt;            &lt;jdbc:script location=&quot;classpath:test1.sql&quot;/&gt;        &lt;/jdbc:embedded-database&gt;    &lt;/beans&gt;        &lt;beans profile=&quot;prod&quot;&gt;        &lt;jee:jndi-lookup jndi-name=&quot;jdbc/MyDatabase&quot; id=&quot;dataSource&quot; resource-ref=&quot;true&quot; proxy-interface=&quot;javax.sql.DataSource&quot;/&gt;    &lt;/beans&gt;&lt;/beans&gt;</code></pre><p><strong>虽然id都一样，类型都是javax.sql.dataSource，但是只会创建指定profile的bean。</strong></p><h4 id="3-1-2-激活profile"><a href="#3-1-2-激活profile" class="headerlink" title="3.1.2 激活profile"></a>3.1.2 激活profile</h4><p>Spring在确定处于激活状态的profile时，依赖于两个独立的属性：</p><ul><li>spring.profiles.active</li><li>spring.profiles.default</li></ul><p>优先级从上到下，如果spring.profiles.active没有设置，则看spring.profiles.default，否则只会创建没有定义在profiles中的bean。</p><p>有多种方式设置这两个属性：</p><ul><li>作为DispatcherServlet的初始化参数</li><li>作为web应用的上下文参数</li><li>作为JNDI条目</li><li>作为环境变量</li><li>作为JVM属性</li><li>在集成测试类上使用@ActiveProfiles属性</li></ul><p>在web.xml配置文件中设置默认的profile：</p><pre><code class="xml">&lt;context-param&gt;    &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt;    &lt;param-value&gt;dev&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt;    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt;        &lt;param-value&gt;dev&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;</code></pre><p><strong>可以同时激活多个profile，以逗号分隔。</strong></p><p>使用profile进行测试：</p><p>Spring提供了@ActiveProfiles注解，用来指定测试时使用的profile。</p><pre><code class="java">@RunWith(SpringJunit4ClassRunner.class)@ContextConfiguration(classes=&#123;PersistenceTestConfig.class&#125;)@ActiveProfiles(&quot;dev&quot;)public class PersistenceTest &#123;    &#125;</code></pre><hr><h3 id="3-2-条件化的bean"><a href="#3-2-条件化的bean" class="headerlink" title="3.2 条件化的bean"></a>3.2 条件化的bean</h3><p>需求：</p><ol><li>希望一个或多个bean只有在类路径下包含某个特定的库时才创建</li><li>希望某个bean在特定的bean声明之后再创建</li></ol><p>Spring 4引入了@Conditional注解，只有条件计算结果为true才会创建bean，否则不创建。</p><pre><code class="java">package com.ch3;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;/** * @author zhulongkun20@163.com * @since 2018/11/24 下午2:07 */public class MagicExistsCondition implements Condition &#123;    @Override    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;        Environment environment = conditionContext.getEnvironment();        return environment.containsProperty(&quot;magic&quot;);    &#125;&#125;</code></pre><pre><code class="java">@Bean@Conditional(MagicExistsCondition.class)   //条件化创建beanpublic MagicBean magicBean() &#123;    return new MagicBean();&#125;</code></pre><p>ConditionContext接口：</p><pre><code class="java">public interface ConditionContext &#123;    BeanDefinitionRegistry getRegistry();    ConfigurableListableBeanFactory getBeanFactory();    Environment getEnvironment();    ResourceLoader getResourceLoader();    ClassLoader getClassLoader();&#125;</code></pre><ul><li>getRegistry：根据返回值可以检查bean定义</li><li>getEnvirnment：检查环境变量</li><li>getResourceLoader：读取加载的资源</li><li>getClassLoader：加载并检查类是否存在</li></ul><p>AnnotatedTypeMetadata接口：</p><pre><code class="java">public interface AnnotatedTypeMetadata &#123;    boolean isAnnotated(String var1);    Map&lt;String, Object&gt; getAnnotationAttributes(String var1);    Map&lt;String, Object&gt; getAnnotationAttributes(String var1, boolean var2);    MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1);    MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1, boolean var2);&#125;</code></pre><hr><h3 id="3-3-处理启动装配的歧义性"><a href="#3-3-处理启动装配的歧义性" class="headerlink" title="3.3 处理启动装配的歧义性"></a>3.3 处理启动装配的歧义性</h3><p>仅有一个bean匹配所需结果时，自动装配才是有效的，如果有多个bean能够匹配结果的话，这种歧义性会阻碍Spring自动装配属性、构造器参数和方法参数。</p><p>Spring提供的解决方案：</p><ul><li>将可选bean中的其中一个声明为首选（primary）</li><li>使用限定符（qualifier）缩小可选范围</li></ul><h4 id="3-3-1-标示首选的bean"><a href="#3-3-1-标示首选的bean" class="headerlink" title="3.3.1 标示首选的bean"></a>3.3.1 标示首选的bean</h4><p>将其中一个可选的bean声明为首选可以避免自动装配的歧义性。</p><pre><code class="java">@Autowiredpublic void setDessert(Dessert dessert) &#123;    this.dessert = dessert;&#125;@Component@Primarypublic class IceCream implements Dessert &#123;    //...&#125;@Bean@Primarypublic Dessert dessert() &#123;    return new IceCream();&#125;</code></pre><p>xml配置：</p><pre><code class="xml">&lt;bean id=&quot;iceCream&quot; class=&quot;com.test.dessert.IceCream&quot; primary=&quot;true&quot;/&gt;</code></pre><h4 id="3-3-2-限定自动装配的bean"><a href="#3-3-2-限定自动装配的bean" class="headerlink" title="3.3.2 限定自动装配的bean"></a>3.3.2 限定自动装配的bean</h4><p>设置首选bean的局限性在于 <strong>@Primary无法将可选方案范围限定到一个无歧义性的选项中</strong> ，当首选bean的数量超过一个时，无法进一步缩小限定范围。</p><p>@Qualifier注解是使用限定符的主要方式，与@Autowired协同使用，在注入时指定要注入的bean。</p><pre><code class="java">@Autowired@Qualifier(&quot;iceCream&quot;)public void setDessert(Dessert dessert) &#123;    this.dessert = dessert;&#125;</code></pre><p>@Qualifier注解的参数就是想要注入的bean的id，所有使用@Component注解的类都会创建为bean，且id为首字母小写的类名。</p><p>基于默认id作为限定符是简单的，但是当类名被更改之后会使限定符失效。</p><p>创建自定义的限定符：</p><p>可以设置自己的限定符，而不依赖于bean id作为限定符。</p><pre><code class="java">@Component@Qualifier(&quot;cold&quot;)public class IceCream implements Dessert &#123;    &#125;</code></pre><p>此时cold限定符分配给了IceCream bean，只需要在合适的地方引入cold限定符即可自动装配。</p><pre><code class="java">@Bean@Qualifier(&quot;cold&quot;)public Dessert iceCream() &#123;    return new IceCream();&#125;</code></pre><p>此时类限定名的变更不会影响到自动装配。但是当应用中出现同名的注解@Qualifier(“cold”)时，歧义性又会再次出现。</p><p>这时需要多个@Qualifier注解来进一步缩小限定范围。</p><hr><h3 id="3-4-bean的作用域"><a href="#3-4-bean的作用域" class="headerlink" title="3.4 bean的作用域"></a>3.4 bean的作用域</h3><p><strong>默认情况下，Spring应用上下文中的所有bean都是以单例模式创建的。不管给定的bean被注入到其他bean多少次，每次注入的都是同一个实例。</strong></p><p>如果一个类是可变（mutable）的，那么对其进行重用时可能会遇到意想不到的问题。</p><p>Spring定义的bean作用域：</p><ul><li>单例（Singleton）：在整个应用中，只创建一个bean；</li><li>原型（Prototype）：每次注入或者通过上下文获取bean时都创建一个新的bean；</li><li>会话（Session）：在Web应用中，为每个回话创建一个bean；</li><li>请求（Request）：在Web应用中，为每个请求创建一个bean。</li></ul><p>@Scope注解：</p><p>用来指定bean的作用域：</p><pre><code class="java">@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)//或者 @Scope(&quot;prototype&quot;)public class Notepad &#123;    //something&#125;</code></pre><p>XML配置：</p><pre><code class="xml">&lt;bean id=&quot;notepad&quot; class=&quot;com.app.Notepad&quot; scope=&quot;prototype&quot; /&gt;</code></pre><hr><h3 id="3-5-运行时值注入"><a href="#3-5-运行时值注入" class="headerlink" title="3.5 运行时值注入"></a>3.5 运行时值注入</h3><p>Spring提供了两种运行时求值的方式：</p><ul><li>属性占位符（Property placeholder）；</li><li>Spring表达式语言（S片EL）。</li></ul><pre><code class="java">@Configuration@PropertySource(&quot;classpath:/com/soundsys/app.properties&quot;)public class ExpressiveConfig &#123;    @Autowired    Environment env;        @Bean    public BlankDisc disc() &#123;        return new BlankDisc(env.getProperty(&quot;disc.title&quot;), env.getProperty(&quot;disc.artist&quot;));    &#125;&#125;</code></pre><p>Spring的Environment：</p><p>getProperty()方法的四种重载方式：</p><ul><li>String getProperty(String key)；</li><li>String getProperty(String key, String defaultValue)；</li><li>T getProperty(String key, Class<T> type)；</li><li>T getProperty(String key, Class<T> type, T defaultValue)；</li></ul><p>使用重载形式的getProperty()方法可以避免类型转换：</p><pre><code class="java">int connectionCount = env.getProperty(&quot;db.connection.count&quot;, Integer.class, 10);</code></pre><p>Environment常见方法：</p><ul><li>boolean containsProperty(String property)；</li><li>String[] getActiveProfiles()；</li><li>String[] getDefaultProfiles()；</li><li>boolean acceptsProfiles(String… profiles)。</li></ul><p>解析属性占位符：</p><p>Spring支持将属性定义到外部的属性文件中，并使用占位符将其值插入到Spring bean中。在Spring装配中，占位符的形式为使用 “${…}” 的形式包装的属性名称。</p><pre><code class="xml">&lt;bean id=&quot;sgtPeppers&quot; class=&quot;soundsystem.BlankDisc&quot; c:_title=&quot;$&#123;disc.title&#125;&quot; c:_artist=&quot;$&#123;disc.artist&#125;&quot; /&gt;</code></pre><p>使用组件扫描和自动装配时：</p><pre><code class="java">public BlankDisc(@Value(&quot;$&#123;disc.title&#125;&quot; String title, @Value(&quot;$&#123;disc.artist&#125;&quot;) String artist) &#123;    this.title = title;    this.artist = artist;&#125;</code></pre><p>SpEL表达式语言：</p><p>将表达式语言放到 “#{…}” 之中。</p><ul><li>“#{1 + 1}”</li><li>“#{T(System).currentMillis()}”</li><li>“#{sgtPeppers.artist}”</li><li>“#{false}”</li><li>“#{artistSelector.selectArtists().toUpperCase()}”</li></ul><p>SpEL运算符：</p><table><thead><tr><th>运算符类型</th><th>运算符</th></tr></thead><tbody><tr><td>算术运算符</td><td>+、-、*、&#x2F;、%、</td></tr><tr><td>比较运算符</td><td>&lt;、&gt;、&#x3D;&#x3D;、&lt;&#x3D;、&gt;&#x3D;、lt、gt、eq、le、ge</td></tr><tr><td>逻辑运算符</td><td>and、or、not、|</td></tr><tr><td>条件运算符</td><td>?:(ternary)、?:()</td></tr><tr><td>正则表达式</td><td>matches</td></tr></tbody></table><p>计算正则表达式：</p><pre><code class="xml">#&#123;admin.email matches &#39;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com&#39;&#125;</code></pre><p>计算集合：</p><pre><code class="xml">#&#123;jukebox.songs[4].title&#125;#&#123;jukebox.songs[T(java.lang.Math).random()*jukebox.songs.size()].title&#125;#&#123;jukebox.songs.?[artist eq &#39;Aerosmith&#39;]&#125;  //.?[]得到集合的一个子集#&#123;jukebox.songs.^[artist eq &#39;Areosmith&#39;]&#125;  //.^[]查询集合中的第一个匹配项#&#123;jukebox.songs.$[artist eq &#39;Areosmith&#39;].![title]&#125;  //.$[]查询集合中的最后一个匹配项，.![]从集合的每个成员中选择特定的属性放到另外一个集合中</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> bean装配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode之Reverse Polish Notation</title>
      <link href="/2018/11/24/68e2f352944a/"/>
      <url>/2018/11/24/68e2f352944a/</url>
      
        <content type="html"><![CDATA[<h2 id="1-关于Reverse-Polish-Notation"><a href="#1-关于Reverse-Polish-Notation" class="headerlink" title="1. 关于Reverse Polish Notation"></a>1. 关于Reverse Polish Notation</h2><p>摘自 <a href="https://zh.wikipedia.org/zh-hans/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">维基百科</a> 的解释：</p><blockquote><p><strong>逆波兰表示法</strong>（<strong>Reverse Polish notation</strong>，<strong>RPN</strong>，或<strong>逆波兰记法</strong>），是一种是由<a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0" title="波兰">波兰</a><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%AE%B6" title="数学家">数学家</a><a href="https://zh.wikipedia.org/wiki/%E6%89%AC%C2%B7%E6%AD%A6%E5%8D%A1%E8%B0%A2%E7%BB%B4%E5%A5%87" title="扬·武卡谢维奇">扬·武卡谢维奇</a>1920年引入的数学表达式方式，在逆波兰记法中，所有<a href="https://zh.wikipedia.org/w/index.php?title=%E6%93%8D%E4%BD%9C%E7%AC%A6&action=edit&redlink=1" title="操作符（页面不存在）">操作符</a>置于<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E6%95%B0" title="操作数">操作数</a>的后面，因此也被称为<strong>后缀表示法</strong>。逆波兰记法不需要括号来标识操作符的优先级。</p></blockquote><span id="more"></span><h2 id="2-题目内容"><a href="#2-题目内容" class="headerlink" title="2. 题目内容"></a>2. 题目内容</h2><p>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p><p>Valid operators are+,-,*,&#x2F;. Each operand may be an integer or another expression.<br>Some examples:</p><p> [“2”, “1”, “+”, “3”, “*”] -&gt; ((2 + 1) * 3) -&gt; 9<br> [“4”, “13”, “5”, “&#x2F;“, “+”] -&gt; (4 + (13 &#x2F; 5)) -&gt; 6</p><h2 id="3-解题思路"><a href="#3-解题思路" class="headerlink" title="3. 解题思路"></a>3. 解题思路</h2><p>对于一个合法的字符数组，依次扫描该字符数组：</p><ol><li>如果该字符是”+”,”-“,”*”,”&#x2F;“中的任意一个，则将其放入栈中；</li><li>如果该字符是操作符，则从栈中取出两个操作数按照顺序进行运算；</li><li>直到扫描完毕，取出栈中的最后一个数，即为结果。</li></ol><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><pre><code class="java">public int evalRPN(String[] tokens) &#123;    List&lt;String&gt; operators = new ArrayList&lt;String&gt;() &#123;&#123;        add("+");        add("-");        add("*");        add("/");    &#125;&#125;;    Stack&lt;Integer&gt; tempValue = new Stack&lt;&gt;();    int number1;    int number2;    int result = 0;    for (String token : tokens) &#123;        if (!operators.contains(token)) &#123;            tempValue.push((Integer.valueOf(token)));        &#125; else &#123;            number1 = tempValue.pop();            number2 = tempValue.pop();            switch (token) &#123;                case &quot;+&quot;:                    result = number2 + number1;                    break;                case &quot;-&quot;:                    result = number2 - number1;                    break;                case &quot;*&quot;:                    result = number2 * number1;                    break;                case &quot;/&quot;:                    result = number2 / number1;                    break;            &#125;            tempValue.push(result);        &#125;    &#125;    return tempValue.pop();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 逆波兰表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Python爬取B站数据</title>
      <link href="/2018/11/22/def2d54928c6/"/>
      <url>/2018/11/22/def2d54928c6/</url>
      
        <content type="html"><![CDATA[<h2 id="最初的想法"><a href="#最初的想法" class="headerlink" title="最初的想法"></a>最初的想法</h2><p>最近在想起能不能爬一下B站的用户信息，看看能不能统计一下B站的年龄信息。但是很遗憾，在个人主页里只能看到注册日期和生日，而不能看到完整的生日信息。</p><p>还是换个目标吧，好久没用python了，就当是复习一下基础知识。于是找了一下B站的API，官方没有开放的API可供调用，意料之中，已经有大佬准备好了：<a href="https://github.com/Kotobuki-Tsumugi/Bilibili_Views_spider">GitHub-B站野生接口</a> 。</p><span id="more"></span><pre><code class="python">class BilibiliSpider(object):    def __init__(self):        self.online_api = &quot;https://api.bilibili.com/x/web-interface/online&quot;  # 在线人数        self.video_api = &quot;https://api.bilibili.com/x/web-interface/archive/stat?&amp;aid=%s&quot;  # 视频信息        self.newlist_api = &quot;https://api.bilibili.com/x/web-interface/newlist?&amp;rid=%s&amp;pn=%s&amp;ps=%s&quot;  # 最新视频信息        self.region_api = &quot;https://api.bilibili.com/x/web-interface/dynamic/region?&amp;rid=%s&amp;pn=%s&amp;ps=%s&quot;  # 最新动态信息        self.member_api = &quot;http://space.bilibili.com/ajax/member/GetInfo&quot;  # 用户信息        self.stat_api = &quot;https://api.bilibili.com/x/relation/stat?vmid=%s&quot;  # 用户关注数和粉丝总数        self.upstat_api = &quot;https://api.bilibili.com/x/space/upstat?mid=%s&quot;  # 用户总播放量和总阅读量        self.follower_api = &quot;https://api.bilibili.com/x/relation/followings?vmid=%s&amp;pn=%s&amp;ps=%s&quot;  # 用户关注信息        self.fans_api = &quot;https://api.bilibili.com/x/relation/followers?vmid=%s&amp;pn=%s&amp;ps=%s&quot;  # 用户粉丝信息</code></pre><h2 id="抓取在线人数"><a href="#抓取在线人数" class="headerlink" title="抓取在线人数"></a>抓取在线人数</h2><p>最简单的例子，在 StuPeter 的例子里有现成的代码：</p><pre><code class="python">def member_online_count(self):    ret_val = requests.get(self.online_api)    if ret_val.status_code != 200 or ret_val.content is None:        print(&quot;获取当前在线人数失败&quot;)        return None    ret_content = json.loads(ret_val.content)    return ret_content[&quot;data&quot;][&quot;web_online&quot;]</code></pre><h2 id="将返回数据写入文件"><a href="#将返回数据写入文件" class="headerlink" title="将返回数据写入文件"></a>将返回数据写入文件</h2><p>每次执行脚本都记录下当前时间：</p><pre><code class="python">def write_to_file(self, cnt):    now = datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)    f = open(self.file, &quot;a&quot;)    content_to_write = &quot;[&quot; + now + &quot;] : [&quot; + str(cnt) + &quot;]&quot;    f.write(content_to_write + &quot;\n&quot;)</code></pre><h2 id="配置定时任务"><a href="#配置定时任务" class="headerlink" title="配置定时任务"></a>配置定时任务</h2><p>配置定时任务(Ubantu18.04)每十分钟执行一次：</p><pre><code class="properties">0,10,20,30,40,50 * * * * python /home/username/python/bilibili_spider.py</code></pre><h2 id="matplotlib折线图展示"><a href="#matplotlib折线图展示" class="headerlink" title="matplotlib折线图展示"></a>matplotlib折线图展示</h2><p>爬完数据之后数据数据都在文件里，直接数据文件中读取记录下的 时间 和 人数值，做成折线图：</p><p>还需要再研究研究，to be updated…</p>]]></content>
      
      
      <categories>
          
          <category> 玩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据爬取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客同时部署到github和coding并设置双线解析</title>
      <link href="/2018/11/19/a83f62485648/"/>
      <url>/2018/11/19/a83f62485648/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为github服务器禁止了百度爬虫，所以不能百度收录不了站点，导致访问量很低，本来不想折腾的，想了一下还是将博客也部署到了coding上，方便百度的收录。</p><span id="more"></span><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ol><li><p>在coding上创建一个名为 <strong>用户名</strong> (不是昵称)的项目，并开启pages服务；</p></li><li><p>将本地ssh公钥文件添加到coding的SSH公钥中并测试是否能访问：</p><pre><code class="shell">ssh -T -p 443 git@git-ssh.coding.net</code></pre></li><li><p>在站点配置文件中添加上coding仓库地址：</p><pre><code class="yaml">deploy:  type: git  repository:    github: git@github.com:Kotobuki-Tsumugi/Kotobuki-Tsumugi.github.io.git    coding: git@git.dev.tencent.com:Kobobuki-Tsumugi/Kobobuki-Tsumugi.git  branch: master</code></pre></li><li><p>在站点目录&#x2F;source下创建一个名为Staticfile的空文件；</p></li><li><p>生成并上传静态文件：</p><pre><code class="shell">hexo cleanhexo g -d</code></pre></li><li><p>在域名解析中新增两条CNAME记录，指向username.coding.me，注意区分境外线路和默认线路，指向coding的必须为默认线路，如果不能正常访问，可以先暂停github的解析，待coding的解析成功后再开启github的解析，解析反应不及时。</p></li><li><p>向百度提交站点sitemap文件地址。</p></li></ol><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>其中也遇到一些玄学的问题：</p><p><img src="https://images.happy365.day/24/04/17230745.png" alt="截图"></p><p>比如上图，我如果绑定youyou-2608.com 则一直提示“域名未联通”，即便我已经添加了指向username.coding.me的CNAME记录，添加<a href="http://www.youyou-2608.com/">www.youyou-2608.com</a> 能绑定上，但是绑定状态一直是异常，访问username.coding.me也能正常跳转到 <a href="https://youyou-2608.com/">https://youyou-2608.com</a> ，没太搞明白，既然已经能正常访问，也就作罢了。</p>]]></content>
      
      
      <categories>
          
          <category> 博客维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客维护 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记-第二章-装配Bean</title>
      <link href="/2018/11/17/2083117a3d1e/"/>
      <url>/2018/11/17/2083117a3d1e/</url>
      
        <content type="html"><![CDATA[<p>第二章：装配Bean</p><p>本章内容：</p><ul><li>声明bean</li><li>构造器注入和Setter方法注入</li><li>装配bean</li><li>控制bean的创建和销毁</li></ul><blockquote><p>在Spring中，对象无需自己查找或创建与其所关联的对象，容器负责把需要相互协作的对象引用赋值给各个对象，这种协作关系成为<strong>装配</strong>。</p></blockquote><hr><h2 id="2-1-Spring配置的可选方案"><a href="#2-1-Spring配置的可选方案" class="headerlink" title="2.1 Spring配置的可选方案"></a>2.1 Spring配置的可选方案</h2><blockquote><p>Spring容器负责创建应用程序中的bean并通过DI来协调对象之间的关系。开发人员需要做的是告诉Spring需要创建哪些对象并且如何装配在一起。</p></blockquote><span id="more"></span><p>Spring提供了三种可选方式：</p><ul><li>XML配置</li><li>Java显式配置</li><li>隐式的bean发现机制和自动装配</li></ul><p>如何选择：<strong>尽可能使用自动配置机制，当必须显式配置时使用JavaConfig，当JavaConfig中没有同样实现时使用XML配置。</strong></p><hr><h2 id="2-2-自动化装配bean"><a href="#2-2-自动化装配bean" class="headerlink" title="2.2 自动化装配bean"></a>2.2 自动化装配bean</h2><ul><li>自动扫描</li><li>自动装配</li></ul><h3 id="2-2-1-创建可被发现的bean"><a href="#2-2-1-创建可被发现的bean" class="headerlink" title="2.2.1 创建可被发现的bean"></a>2.2.1 创建可被发现的bean</h3><pre><code class="java">package com.kotobuki2.soundsys;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午7:21 */public interface CompactDisc &#123;    void play();&#125;</code></pre><pre><code class="java">package com.kotobuki2.soundsys;import org.springframework.stereotype.Component;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午7:22 */@Componentpublic class SgtPeppers implements CompactDisc &#123;    private String title = &quot;SgtPeppers title&quot;;    private String artiest = &quot;The Beatles&quot;;    @Override    public void play() &#123;        System.out.println(&quot;playing..&quot;);    &#125;&#125;</code></pre><pre><code class="java">package com.kotobuki2.soundsys;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午7:24 */@Configuration@ComponentScanpublic class CDPlayerConfig &#123;&#125;</code></pre><p>通过XML配置开启注解扫描：</p><pre><code class="xml">&lt;context:component-scan base-package=&quot;soundsys&quot;/&gt;</code></pre><p>自动装配测试：</p><pre><code class="java">package com.test;import com.kotobuki2.soundsys.CDPlayerConfig;import com.kotobuki2.soundsys.CompactDisc;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import static org.junit.Assert.assertNotNull;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午7:28 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)public class CDPlayerTest &#123;    @Autowired    private CompactDisc compactDisc;    @Test    public void cdTest() &#123;        assertNotNull(compactDisc);    &#125;&#125;</code></pre><h3 id="2-2-2-为组件扫描的bean命名"><a href="#2-2-2-为组件扫描的bean命名" class="headerlink" title="2.2.2 为组件扫描的bean命名"></a>2.2.2 为组件扫描的bean命名</h3><p>默认将类名第一个字母小写后的字符串作为bean的id。</p><p>可以通过注解标示bean的别名：</p><pre><code class="java">@Component(&quot;alias&quot;)</code></pre><h3 id="2-2-3-设置组件扫描的基础包"><a href="#2-2-3-设置组件扫描的基础包" class="headerlink" title="2.2.3 设置组件扫描的基础包"></a>2.2.3 设置组件扫描的基础包</h3><p><strong>默认以配置类所在的包为基础包进行扫描。</strong></p><p>自定义扫描包：</p><pre><code class="java">@Configuration@ComponentScan(&quot;package-name&quot;)//扫描多个基础包@ComponentScan(basePackages = &#123;&quot;package1&quot;, &quot;package2&quot;&#125;)</code></pre><p>但是用直接指定包名会出现问题：包名被变更以后便无法扫描到所需要的类，因此，还有另一种指定扫描包的方法：</p><pre><code class="java">@Configuration@ComponentScan(basePackageClasses = &#123;CDPlayer.class, DVDPlayer.class&#125;)</code></pre><p>这种方式下，这些类所在的包都会作为基础包进行扫描，即便代码重构也不会受到影响。</p><h3 id="2-2-4-通过为bean添加注解实现自动装配"><a href="#2-2-4-通过为bean添加注解实现自动装配" class="headerlink" title="2.2.4 通过为bean添加注解实现自动装配"></a>2.2.4 通过为bean添加注解实现自动装配</h3><pre><code class="java">package com.kotobuki2.soundsys;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午8:51 */public interface MediaPlayer &#123;    void play();&#125;</code></pre><pre><code class="java">package com.kotobuki2.soundsys;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午8:50 */@Componentpublic class CDPlayer implements MediaPlayer &#123;    private CompactDisc compactDisc;    @Autowired    public CDPlayer(CompactDisc compactDisc) &#123;        this.compactDisc = compactDisc;    &#125;    @Override    public void play() &#123;        compactDisc.play();    &#125;&#125;</code></pre><p>@Autowired注解不仅能够用在构造器上，也能用在属性的Setter方法上。</p><hr><h2 id="2-3-通过Java装配bean"><a href="#2-3-通过Java装配bean" class="headerlink" title="2.3 通过Java装配bean"></a>2.3 通过Java装配bean</h2><blockquote><p>在进行显式配置的时候，JavaConfig是更好的方案，因为其强大、类型安全并且重构友好。因为其本身就是Java代码。</p></blockquote><p>声明简单的bean：</p><pre><code class="java">@Bean(name=&quot;alias&quot;)public CompactDisc sgtPeppers() &#123;    return new SgtPeppers();&#125;</code></pre><p>借助JavaConfig实现注入：</p><pre><code class="java">@Beanpublic CDPlayer cdPlayer()&#123;    return CDPlayer(new sgtPeppers());&#125;@Beanpublic CDPlayer cdPlayer(CompactDisc disc)&#123;    return new CDplayer(disc);&#125;</code></pre><p>后者不要求disc必须在JavaConfig中声明，实际上它可以通过组件扫描功能自动发现或者XML来进行配置。</p><p>通过构造器注入：</p><pre><code class="java">@Beanpublic CDPlayer cdPlayer(CompactDisc disc)&#123;    CDPlayer cdPlayer = new CDPlayer(disc);    cdPlayer.setCompactDisc(disc);    return cdPlayer;&#125;</code></pre><hr><h2 id="2-4-通过XML装配Bean"><a href="#2-4-通过XML装配Bean" class="headerlink" title="2.4 通过XML装配Bean"></a>2.4 通过XML装配Bean</h2><p>在XML配置中，需要创建一个以<beans>作为根元素的XML配置文件。</p><p><strong>可以借助Spring Tool Suite创建和管理Spring XML配置文件</strong>。</p><h3 id="2-4-1-声明一个简单的bean："><a href="#2-4-1-声明一个简单的bean：" class="headerlink" title="2.4.1 声明一个简单的bean："></a>2.4.1 声明一个简单的bean：</h3><pre><code class="xml">&lt;bean id=&quot;bean_id&quot; class=&quot;com.soundsys.SgtPeppers&quot; /&gt;</code></pre><p>如果没有指明id，bean将会根据类全限定名指定，为了减少XML配置的繁琐，只需要对需要按名称引用的bean进行命名。“com.soundsys.SgtPeppers#0”…</p><p><constructor-arg> 元素：</p><pre><code class="xml">&lt;bean id=&quot;cdPlayer&quot; class=&quot;com.soundsys.CDPlayer&quot;&gt;    &lt;constructor-arg ref=&quot;compactDisc&quot; /&gt;&lt;/bean&gt;</code></pre><h3 id="2-4-2-c命名空间"><a href="#2-4-2-c命名空间" class="headerlink" title="2.4.2 c命名空间"></a>2.4.2 c命名空间</h3><p><a href="https://blog.csdn.net/elim168/article/details/74516439">p命名空间和c命名空间</a></p><h3 id="2-4-3-将字面量注入到构造器中："><a href="#2-4-3-将字面量注入到构造器中：" class="headerlink" title="2.4.3 将字面量注入到构造器中："></a>2.4.3 将字面量注入到构造器中：</h3><pre><code class="xml">&lt;bean id=&quot;compactDisc&quot; class=&quot;com.soundsys.BlackDisc&quot;&gt;    &lt;constructor-arg value=&quot;title&quot; /&gt;    &lt;constructor-arg value=&quot;The Beatles&quot; /&gt;&lt;/bean&gt;</code></pre><p>使用 value 属性，将给定的值注入到构造器中。</p><h3 id="2-4-3-装配集合"><a href="#2-4-3-装配集合" class="headerlink" title="2.4.3 装配集合"></a>2.4.3 装配集合</h3><pre><code class="xml">&lt;bean id=&quot;beat&quot; class=&quot;com.soundsys.beat&quot;&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;constructor-arg&gt;        &lt;list&gt;            &lt;ref bean=&quot;bean1&quot;/&gt;            &lt;ref bean=&quot;bean2&quot;/&gt;            &lt;ref bean=&quot;bean3&quot;/&gt;        &lt;/list&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><p>或者</p><pre><code class="xml">&lt;bean id=&quot;beat&quot; class=&quot;com.soundsys.beat&quot;&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;constructor-arg&gt;        &lt;set&gt;            &lt;value&gt;SgtPeppers&lt;/value&gt;            &lt;value&gt;The Beatles&lt;/value&gt;        &lt;/set&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><p>使用两者的区别就是 list 和 set 会忽略重复元素。</p><h3 id="2-4-4-p命名空间"><a href="#2-4-4-p命名空间" class="headerlink" title="2.4.4 p命名空间"></a>2.4.4 p命名空间</h3><p><a href="https://blog.csdn.net/elim168/article/details/74516439">p命名空间和c命名空间</a></p><h3 id="2-4-5-导入混合配置"><a href="#2-4-5-导入混合配置" class="headerlink" title="2.4.5 导入混合配置"></a>2.4.5 导入混合配置</h3><p>在 JavaConfig 中引用 JavaConfig 配置：</p><pre><code class="java">@Configuration@Import(CDConfig.class)public class CDPlayerConfig &#123;    @Bean    public CDPlayer cdPlayer(CompactDisc disc) &#123;        return new CDPlayer(disc);    &#125;&#125;</code></pre><p>或者：</p><pre><code class="java">@Configuration@Import(CDPlayerConfig.class, CDConfig.class)public class SoundSysConfig &#123;&#125;</code></pre><p>新建一个配置类，使用@Import导入两个配置类。</p><p>在JavaConfig中引入XML配置：</p><pre><code class="java">@Configuration@Import(CDPlayerConfig.class)@ImportResource(&quot;classpath:cd-config.xml&quot;)public class SoundSysConfig &#123;&#125;</code></pre><p>在XML配置中引用XML配置：</p><pre><code class="xml">&lt;beans&gt;   &lt;import resource=&quot;cd-config.xml&quot;/&gt;   &lt;bean id=&quot;cdPlayer&quot; class=&quot;com.soundsys.CDPlayer&quot; c:cd-ref=&quot;compactDisc&quot;&gt;&lt;/beans&gt;</code></pre><p>在XML中引入JavaConfig配置：</p><pre><code class="xml">&lt;beans&gt;    &lt;bean class=&quot;com.soundsys.CDConfig&quot;/&gt;    &lt;bean id=&quot;cdPlayer&quot; class=&quot;com.soundsys.CDPlayer&quot; c:cd-ref=&quot;compactDisc&quot;/&gt;&lt;/beans&gt;</code></pre><p>或者：</p><pre><code class="xml">&lt;beans&gt;    &lt;bean class=&quot;com.soundsys.CDConfig&quot;/&gt;    &lt;import resource=&quot;cdplayer-config.xml&quot;/&gt;&lt;/beans&gt;</code></pre><p>新建一个配置文件，分别导入JavaConfig配置和XML配置。</p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>Spring框架的核心是Spring容器，负责管理应用中组件的生命周期，它会创建这些组件并保证它们的依赖能够得到满足。</p><p>尽可能使用自动配置，以避免显式配置带来的维护成本。</p><p>如果确实需要显式配置，应优先选择基于Java的配置，因为其更加强大、类型安全且易于重构。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode之单链表重排序</title>
      <link href="/2018/11/17/2b8fadc6b469/"/>
      <url>/2018/11/17/2b8fadc6b469/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>Given a singly linked list <em>L</em>: <em>L</em> 0→<em>L</em> 1→…→<em>L</em> <em>n</em>-1→<em>L</em> n,<br>reorder it to: <em>L</em> 0→<em>L</em> <em>n</em> →<em>L</em> 1→<em>L</em> <em>n</em>-1→<em>L</em> 2→<em>L</em> <em>n</em>-2→…</p><p>You must do this in-place without altering the nodes’ values.</p><p>For example,<br>Given{1,2,3,4}, reorder it to{1,4,2,3}.</p><span id="more"></span><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><ul><li><p>时间限制：1秒</p></li><li><p>空间限制：32768K</p></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>两个游标：一个用来指向下一次将要插入元素的位置，另一个用来遍历链表。从根结点开始遍历，如果当前节点的next节点不为空并且next的next节点不为空，则取最后一个节点插入到当前节点之后，游标一跳两个位置。直到游标一节点的next节点为空或者next的next节点为空。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package com.reorder.list;import com.sort.linkedlist.ListNode;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午4:01 */public class Solution &#123;    public void reorderList(ListNode head) &#123;        if (head == null) &#123;            return;        &#125;        if (head.next == null || head.next.next == null) &#123;            return;        &#125;        ListNode pt = head;        ListNode index = head;        ListNode preIndex = head;        while (pt.next != null &amp;&amp; pt.next.next != null) &#123;            while (index.next != null) &#123;                preIndex = index;                index = index.next;            &#125;            preIndex.next = null;            index.next = pt.next;            pt.next = index;            pt = pt.next.next;        &#125;    &#125;&#125;</code></pre><p>这种方法可行，但是每排序一个节点都需要遍历一次链表，效率比较低，可以看到下图，运行时间较长，占用内存已经 <strong><font color="red">超过空间限制</font></strong> 了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>看了一下网上给出的方案，几乎都是一样的：</p><p>这道链表重排序问题可以拆分为以下三个小问题：</p><ol><li><p>使用快慢指针来找到链表的中点，并将链表从中点处断开，形成两个独立的链表。</p></li><li><p>将第二个链翻转。</p></li><li><p>将第二个链表的元素间隔地插入第一个链表中。</p></li></ol><p>都是将链表拆成两个独立的链表进行重排序。</p><p>剽窃来的代码：</p><pre><code class="C++">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val;这道链表重排序问题可以拆分为以下三个小问题：1. 使用快慢指针来找到链表的中点，并将链表从中点处断开，形成两个独立的链表。2. 将第二个链翻转。3. 将第二个链表的元素间隔地插入第一个链表中。 *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    void reorderList(ListNode *head) &#123;        if (!head || !head-&gt;next || !head-&gt;next-&gt;next) return;        ListNode *fast = head;        ListNode *slow = head;        while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        &#125;        ListNode *mid = slow-&gt;next;        slow-&gt;next = NULL;        ListNode *last = mid;        ListNode *pre = NULL;        while (last) &#123;            ListNode *next = last-&gt;next;            last-&gt;next = pre;            pre = last;            last = next;        &#125;        while (head &amp;&amp; pre) &#123;            ListNode *next = head-&gt;next;            head-&gt;next = pre;            pre = pre-&gt;next;            head-&gt;next-&gt;next = next;            head = next;        &#125;    &#125;&#125;;</code></pre><p>时间空间使用都很少，性能问题没了。</p>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode之二叉树非递归前序遍历</title>
      <link href="/2018/11/17/3e29e2dd1aae/"/>
      <url>/2018/11/17/3e29e2dd1aae/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p>For example:<br>Given binary tree{1,#,2,3},</p><pre><code>   1    \     2    /   3</code></pre><p>return[1,2,3].</p><p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p><p><strong>使用非递归的方法前序遍历二叉树。</strong></p><span id="more"></span><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>前序遍历就是按照中、左、右的顺序对二叉树进行遍历。</p><p>思路很简单，如果当前节点不为空，不断遍历当前节点的左子树，如果当前节点有右子树的话，将其放入栈中以便后期遍历其右子树，如果当前节点为空，则取出栈顶元素按照同样的方式遍历其右子树。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.postorder.raversal;import java.util.ArrayList;import java.util.Stack;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午3:16 */public class PreOrderSolution &#123;    public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        TreeNode pointer = root;        while (pointer != null || !stack.isEmpty()) &#123;            while (pointer != null) &#123;                list.add(pointer.val);                if (pointer.right != null) &#123;                    stack.push(pointer);                &#125;                pointer = pointer.left;            &#125;            if (stack.isEmpty()) &#123;                break;            &#125;            pointer = stack.pop();            pointer = pointer.right;        &#125;        return list;    &#125;&#125;</code></pre><p>牛客网做得还不错，就是现在还是只支持C++和Java。</p>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode之二叉树非递归后续遍历</title>
      <link href="/2018/11/17/be09a6a8aec7/"/>
      <url>/2018/11/17/be09a6a8aec7/</url>
      
        <content type="html"><![CDATA[<p>周末突然降温，哪儿也去不了，不如在家刷题。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p><p>For example:<br>Given binary tree{1,#,2,3},</p><pre><code>   1    \     2    /   3</code></pre><p>return[3,2,1].</p><p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively？</p><p><strong>使用非递归方法后序遍历二叉树。</strong></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>二叉树后序遍历就是对每个节点按照左、右、中的顺序进行遍历。</p><p>详细的解析参见：<a href="https://www.jianshu.com/p/456af5480cee">二叉树遍历(先序、中序、后序)</a> ，讲得非常详细易懂。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.postorder.raversal;import java.util.ArrayList;import java.util.Stack;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午1:49 */public class Solution &#123;    public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        TreeNode pointer = root;        TreeNode lastVisit = root;        while (!stack.isEmpty() || pointer != null) &#123;            while (pointer != null) &#123;                stack.push(pointer);                pointer = pointer.left;            &#125;            pointer = stack.peek();            if (pointer.right == null || pointer.right == lastVisit) &#123;                list.add(pointer.val);                lastVisit = pointer;                stack.pop();                pointer = null;            &#125; else &#123;                pointer = pointer.right;            &#125;        &#125;        return list;    &#125;&#125;</code></pre><p>是时候好好重修一下数据结构了。</p>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode之链表插入排序</title>
      <link href="/2018/11/16/6c260e858eb5/"/>
      <url>/2018/11/16/6c260e858eb5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/practice/152bc6c5b14149e49bf5d8c46f53152b?tpId=46&tqId=29034&tPage=1&rp=1&ru=/ta/leetcode&qru=/ta/leetcode/question-ranking">链表插入排序</a> 是 <a href="https://www.nowcoder.com/">牛客网</a> 上LeetCode在线编程的一道题。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Sort a linked list using insertion sort.</p><p>使用插入排序对链表排序，此处为单链表。</p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>插入排序</strong>就是依次将未排序部分的第一个元素插入到已排序部分合适的位置，使得已排序部分仍然有序。</p><p>列表可以直接根据位置索引元素，但是链表不可以直接取得指定位置的元素。</p><p>根据插入排序的思路：将整个链表按照已排序和未排序分为两部分，未排序部分的首个元素即为将要被排序的元素，问题变为将一个元素插入到一个有序链表中使得该链表仍然有序。分为两种情况：一种是合适位置在有序链表的非末尾，另一种是在有序链表的末尾，然后其他的问题就是注意插入时的赋值顺序。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">public ListNode insertionSortList1(ListNode head) &#123;   ListNode root = new ListNode(-1);   while (head != null) &#123;       ListNode temp = root;       while (temp.next != null &amp;&amp; head.val &gt;= temp.next.val)           temp = temp.next;       if (temp.next == null) &#123;           temp.next = head;           head = head.next;           temp.next.next = null;       &#125; else &#123;           ListNode temp2 = temp.next;           temp.next = head;           head = head.next;           temp.next.next = temp2;       &#125;   &#125;   return root.next;&#125;</code></pre><p>参考：<a href="http://www.cnblogs.com/tonyluis/p/4579295.html">http://www.cnblogs.com/tonyluis/p/4579295.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记-第一章-Spring之旅</title>
      <link href="/2018/11/14/f07872e3a745/"/>
      <url>/2018/11/14/f07872e3a745/</url>
      
        <content type="html"><![CDATA[<p>第一部分：Spring的核心</p><ul><li><p>第一章：Spring之旅</p><p>介绍Spring框架，包括Spring DI和AOP。</p></li><li><p>第二章：装配Bean</p><p>Spring的自动配置、基于Java的配置和XML配置。</p></li><li><p>第三章：高级装配</p><p>Spring的条件化配置，处理自动装配时的歧义性，作用域以及Spring表达式语言。</p></li><li><p>第四章：面向切面的Spring</p><p>展示如何使用Spring的AOP特性把系统级服务从它们所服务的对象中解耦出来。</p></li></ul><span id="more"></span><hr><p>第一章 Spring之旅</p><p>本章内容：</p><ul><li>Spring的Bean容器</li><li>介绍Spring的核心模块</li><li>更为强大的Spring生态系统</li><li>Spring的新功能</li></ul><p><strong>创建Spring的主要目的是用来替代更加重量级的企业级Java技术，尤其是EJB。</strong>相当于EJB来说，Spring提供了更加轻量级和更加简单的编程模型。</p><hr><h2 id="1-1-简化Java开发"><a href="#1-1-简化Java开发" class="headerlink" title="1.1 简化Java开发"></a>1.1 简化Java开发</h2><h3 id="1-1-1-Spring的非侵入式编程"><a href="#1-1-1-Spring的非侵入式编程" class="headerlink" title="1.1.1 Spring的非侵入式编程"></a>1.1.1 Spring的非侵入式编程</h3><p>在基于Spring构建的应用中，一般不会有任何痕迹表明你使用了Spring，最坏的场景是在一个类上使用了Spring注解，但是这个类依旧是一个Pojo类。</p><p>Spring的非侵入式编程模型意味着这个类在Spring应用还是在非Spring应用中都能发挥同样的作用。</p><pre><code class="java">package com.kotobuki;/** * @author zhulongkun20@163.com * @since 2018/11/14 下午9:18 */public class HelloWorld &#123;    public String sayHello() &#123;        return &quot;Hello world&quot;;    &#125;&#125;</code></pre><h3 id="1-1-2-依赖注入"><a href="#1-1-2-依赖注入" class="headerlink" title="1.1.2 依赖注入"></a>1.1.2 依赖注入</h3><p>在一个应用中通常会涉及到很多类，这些类需要相互协作来完成特定的功能，如果让每个类管理与自己协作的类，则会导致应用高度耦合。</p><blockquote><p> 依赖注入带来的最大好处就是松耦合。如果一个对象只通过借口来表明依赖关系，那么这种依赖就能够在对象毫不知情的情况下用不同的实现替换。</p><p>可以让对其他的类有依赖的类自动获得已经准备好的依赖。</p></blockquote><p>一个送外卖的过程：当不是用DI的时候送餐员需要自己准备外卖，然后再配送。</p><pre><code class="java">package com.clerk;import com.com.food.Dinner;/** * @author zhulongkun20@163.com * @since 2018/11/15 下午8:31 */public class DeliveryWithoutDI implements Delivery &#123;    private Dinner dinner;    public DeliveryWithoutDI() &#123;        this.dinner = new Dinner(&quot;rice&quot;);    &#125;    @Override    public void delivery() &#123;        System.out.println(&quot;delivery it on time.&quot;);    &#125;&#125;</code></pre><p>当使用DI之后，当有外卖需要配送的时候，分配送餐员，送餐员会自动获得需要配送的外卖，需要做的只是负责配送，而不用关心其他事情。</p><pre><code class="java">package com.clerk;import com.com.food.Dinner;/** * @author zhulongkun20@163.com * @since 2018/11/15 下午8:24 */public class DeliveryClerk implements Delivery &#123;    private Dinner dinner;    public DeliveryClerk(Dinner dinner) &#123;        this.dinner = dinner;    &#125;    @Override    public void delivery() &#123;        System.out.println(&quot;delivery on time.&quot;);    &#125;&#125;</code></pre><h3 id="1-1-3-应用切面"><a href="#1-1-3-应用切面" class="headerlink" title="1.1.3 应用切面"></a>1.1.3 应用切面</h3><blockquote><p>面向切面编程允许你把遍布应用各处的功能分离出来形成可重用的组件。</p></blockquote><p>一个系统或应用由许多不同的组件构成，但是每一个组件在负责自己的功能之外，通常还要承担额外的责任。一些与核心业务无关的代码会融入到核心业务逻辑中。比如转账，除了发生金钱的转移之外，还要验证身份、记录账单以及给用户发送通知。这些会跨越系统的组件成为横切关注点。它们会使核心业务代码变得复杂。</p><p><img src="https://image.youyou-2608.com/blog/AOP1.png" alt="Spring AOP"></p><p>通过AOP，可以将与核心业务无关的代码分离出来。</p><h3 id="1-1-4-使用模板消除样板式代码"><a href="#1-1-4-使用模板消除样板式代码" class="headerlink" title="1.1.4 使用模板消除样板式代码"></a>1.1.4 使用模板消除样板式代码</h3><p>使用JDBC访问数据库，会产生大量与查询语句无关的代码，还必须要捕捉异常，虽然无济于事。</p><p>Spring旨在通过模板封装来消除样板式代码。</p><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#spring-data-tier">Data Access with JDBC</a></p><h2 id="1-2-容纳你的bean"><a href="#1-2-容纳你的bean" class="headerlink" title="1.2 容纳你的bean"></a>1.2 容纳你的bean</h2><blockquote><p>在Spring应用中，你的应用对象生存于Spring容器中，Spring容器负责创建对象，装配并管理它们的整个生命周期。</p></blockquote><p>使用应用上下文：</p><ul><li>AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。</li><li>AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载Spring Web应用上下文。</li><li>ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义。</li><li>FileSystemXmlApplicationContext：从文件系统下的一个或多个XML配置文件中加载上下文定义。</li><li>XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中还在上下文定义。</li></ul><p>bean的生命周期：</p><p><img src="https://image.youyou-2608.com/bean-lifecycle.png" alt="bean的生命周期"></p><p><img src="https://image.youyou-2608.com/bean2.png" alt="Bean的生命周期"></p><h2 id="1-3-俯瞰Spring风景线"><a href="#1-3-俯瞰Spring风景线" class="headerlink" title="1.3 俯瞰Spring风景线"></a>1.3 俯瞰Spring风景线</h2><p>Spring的模块：</p><p><img src="https://image.youyou-2608.com/springmodel" alt="Spring模块"></p><table><thead><tr><th><a href="https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/core.html#spring-core">Core</a></th><th>IoC container, Events, Resources, i18n, Validation, Data Binding, Type Conversion, SpEL, AOP.</th></tr></thead><tbody><tr><td><a href="https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/testing.html#testing">Testing</a></td><td>Mock objects, TestContext framework, Spring MVC Test, WebTestClient.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/data-access.html#spring-data-tier">Data Access</a></td><td>Transactions, DAO support, JDBC, ORM, Marshalling XML.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/web.html#spring-web">Web Servlet</a></td><td>Spring MVC, WebSocket, SockJS, STOMP messaging.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/web-reactive.html#spring-webflux">Web Reactive</a></td><td>Spring WebFlux, WebClient, WebSocket.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/integration.html#spring-integration">Integration</a></td><td>Remoting, JMS, JCA, JMX, Email, Tasks, Scheduling, Cache.</td></tr><tr><td><a href="https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/languages.html#languages">Languages</a></td><td>Kotlin, Groovy, Dynamic languages.</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode之水仙花数</title>
      <link href="/2018/11/11/a80e137e58a1/"/>
      <url>/2018/11/11/a80e137e58a1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-水仙花数"><a href="#1-水仙花数" class="headerlink" title="1. 水仙花数"></a>1. 水仙花数</h2><p>以下是摘自 <a href="https://zh.wikipedia.org/zh-hans/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0">维基百科</a> 中的释义：</p><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E8%AE%BA" title="数论">数论</a>中，**<a href="https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1" title="水仙花">水仙花</a>数<strong>（</strong>Narcissistic number<strong>）<sup><a href="https://zh.wikipedia.org/zh-hans/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0#cite_note-mw-1">[1]</a></sup><sup><a href="https://zh.wikipedia.org/zh-hans/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0#cite_note-moore-2">[2]</a></sup>，也被称为</strong>超完全数字不变数<strong>（</strong>pluperfect digital invariant, PPDI<strong>）<sup><a href="https://zh.wikipedia.org/zh-hans/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0#cite_note-3">[3]</a></sup>、</strong><a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%88%80" title="自恋">自恋</a>数<strong>、</strong>自幂数<strong>、</strong><a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%A7%86%E6%96%AF%E5%A3%AF" title="阿姆斯壮">阿姆斯壮</a>数<strong>或</strong>阿姆斯特朗数<strong>（</strong>Armstrong number<strong>）<sup><a href="https://zh.wikipedia.org/zh-hans/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0#cite_note-4">[4]</a></sup> ，用来描述一个</strong>N<strong>位非负整数，其各位数字的</strong>N**次方和等于该数本身。</p></blockquote><p>这里定义的N&#x3D;3。</p><span id="more"></span><h2 id="2-问题描述"><a href="#2-问题描述" class="headerlink" title="2. 问题描述"></a>2. 问题描述</h2><p>春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的： “水仙花数”是指一个三位数，它的各位数字的立方和等于其本身，比如：153&#x3D;1^3+5^3+3^3。 现在要求输出所有在m和n范围内的水仙花数。</p><p>对于每个测试实例，要求输出所有在给定范围内的水仙花数，就是说，输出的水仙花数必须大于等于m,并且小于等于n，如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开;<br>如果给定的范围内不存在水仙花数，则输出no;<br>每个测试实例的输出占一行。</p><p>输入：<br>100 120<br>300 380</p><p>输出：<br>no<br>370 371</p><h2 id="3-问题分析"><a href="#3-问题分析" class="headerlink" title="3. 问题分析"></a>3. 问题分析</h2><p>我的解决思路：先将给出的数字按照个位十位百位的顺序拆解，然后计算各数位三次方之和，再和原数进行比较比较。思路比较简单。</p><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><pre><code class="java">package com.odd.number;import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * @author zhulongkun20@163.com * @since 2018/11/3 下午12:58 */public class Solution &#123;    private static List&lt;Integer&gt; getNumbers(int start, int end) &#123;        List&lt;Integer&gt; comps = new ArrayList&lt;&gt;();        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        double num;        for (int i = start; i &lt;= end; i++) &#123;            num = 0;            comps.clear();            comps = getNumberComponent(i);            for (Integer comp : comps) &#123;                num += Math.pow(comp, 3);            &#125;            if (num == i) &#123;                result.add(i);            &#125;        &#125;        return result;    &#125;    private static List&lt;Integer&gt; getNumberComponent(int number) &#123;        int base = 10;        int comp;        int lastComp;        List&lt;Integer&gt; components = new ArrayList&lt;&gt;();        while (number % (base / 10) != number) &#123;            int power = 0;            lastComp = 0;            for (Integer index : components) &#123;                lastComp += index * Math.pow(10, power);                power += 1;            &#125;            comp = ((number - lastComp) % base) / (base / 10);            components.add(comp);            base *= 10;        &#125;        return components;    &#125;    public static void main(String[] args) &#123;        List&lt;Integer&gt; result;        Scanner input = new Scanner(System.in);        while (input.hasNextLine()) &#123;            String str = input.nextLine();            String[] numbers = str.split(&quot; &quot;);            for (int i = 0; i &lt; numbers.length - 1; i++) &#123;                int start = Integer.valueOf(numbers[i]);                int end = Integer.valueOf(numbers[i + 1]);                result = getNumbers(start, end);                if (result.isEmpty()) &#123;                    System.out.println(&quot;no&quot;);                &#125; else &#123;                    for (Integer aResult : result) &#123;                        System.out.print(aResult + &quot; &quot;);                    &#125;                    System.out.println();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="5-他山之石"><a href="#5-他山之石" class="headerlink" title="5. 他山之石"></a>5. 他山之石</h2><p>貌似在评论区里看到了有用python解决的：</p><p><img src="https://images2.imgbox.com/be/68/HnUhQ8il_o.png" alt="图片"></p><p>没太看懂。</p>]]></content>
      
      
      <categories>
          
          <category> 解题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 水仙花数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
